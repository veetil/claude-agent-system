# Step 3: CLI Agent Spawning Implementation

## Objective
Implement the core functionality to spawn Claude CLI processes as agents with proper isolation and communication.

## Tasks

### 3.1 CLI Process Manager Implementation

#### Test Suite First (TDD)
```typescript
// src/cli/__tests__/CLIProcessManager.test.ts
import { CLIProcessManager } from '../CLIProcessManager';
import { IAgentConfig } from '../../agents/base/types';

describe('CLIProcessManager', () => {
  let manager: CLIProcessManager;

  beforeEach(() => {
    manager = new CLIProcessManager();
  });

  afterEach(async () => {
    await manager.shutdown();
  });

  describe('spawn agent', () => {
    it('should spawn a new Claude CLI process', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-1',
        name: 'CLI Test Agent',
        type: 'research',
        workingDirectory: '/tmp/cli-agent-1',
        systemPrompt: 'You are a research agent'
      };

      const process = await manager.spawnAgent(config);

      expect(process).toBeDefined();
      expect(process.pid).toBeGreaterThan(0);
      expect(manager.getActiveAgents()).toContain('cli-agent-1');
    });

    it('should create isolated working directory', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-2',
        name: 'CLI Test Agent 2',
        type: 'developer',
        workingDirectory: '/tmp/cli-agent-2',
        systemPrompt: 'You are a developer agent'
      };

      await manager.spawnAgent(config);

      expect(fs.existsSync(config.workingDirectory)).toBe(true);
      expect(fs.existsSync(path.join(config.workingDirectory, '.claude'))).toBe(true);
    });

    it('should handle spawn failures gracefully', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-3',
        name: 'CLI Test Agent 3',
        type: 'invalid',
        workingDirectory: '/invalid/path',
        systemPrompt: 'Test'
      };

      await expect(manager.spawnAgent(config)).rejects.toThrow('Failed to spawn agent');
    });
  });

  describe('agent communication', () => {
    it('should send task to agent and receive response', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-4',
        name: 'CLI Test Agent 4',
        type: 'test',
        workingDirectory: '/tmp/cli-agent-4',
        systemPrompt: 'You are a test agent. Respond with "Task completed: {description}"'
      };

      const process = await manager.spawnAgent(config);
      
      const task = {
        id: 'task-1',
        type: 'test',
        description: 'Test task'
      };

      const result = await manager.sendTask(config.id, task);

      expect(result).toContain('Task completed: Test task');
    });

    it('should handle multiple concurrent tasks', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-5',
        name: 'CLI Test Agent 5',
        type: 'test',
        workingDirectory: '/tmp/cli-agent-5',
        systemPrompt: 'You are a test agent'
      };

      await manager.spawnAgent(config);

      const tasks = Array.from({ length: 5 }, (_, i) => ({
        id: `task-${i}`,
        type: 'test',
        description: `Test task ${i}`
      }));

      const results = await Promise.all(
        tasks.map(task => manager.sendTask(config.id, task))
      );

      expect(results).toHaveLength(5);
      results.forEach((result, i) => {
        expect(result).toBeDefined();
      });
    });
  });

  describe('resource management', () => {
    it('should track resource usage per agent', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-6',
        name: 'CLI Test Agent 6',
        type: 'test',
        workingDirectory: '/tmp/cli-agent-6',
        systemPrompt: 'You are a test agent'
      };

      await manager.spawnAgent(config);
      const stats = await manager.getAgentStats(config.id);

      expect(stats).toHaveProperty('cpu');
      expect(stats).toHaveProperty('memory');
      expect(stats).toHaveProperty('uptime');
    });

    it('should terminate agent on request', async () => {
      const config: IAgentConfig = {
        id: 'cli-agent-7',
        name: 'CLI Test Agent 7',
        type: 'test',
        workingDirectory: '/tmp/cli-agent-7',
        systemPrompt: 'You are a test agent'
      };

      await manager.spawnAgent(config);
      expect(manager.getActiveAgents()).toContain(config.id);

      await manager.terminateAgent(config.id);
      expect(manager.getActiveAgents()).not.toContain(config.id);
    });
  });
});
```

### 3.2 CLI Process Manager Implementation

```typescript
// src/cli/CLIProcessManager.ts
import { spawn, ChildProcess } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';
import { IAgentConfig, ITask } from '../agents/base/types';
import { Logger } from 'winston';
import { AgentLogger } from '../utils/logger';

interface IAgentProcess {
  id: string;
  process: ChildProcess;
  config: IAgentConfig;
  busy: boolean;
  taskQueue: Array<{
    task: ITask;
    resolve: (result: string) => void;
    reject: (error: Error) => void;
  }>;
  stats: {
    startTime: number;
    tasksCompleted: number;
    tasksFailed: number;
  };
}

export class CLIProcessManager extends EventEmitter {
  private agents: Map<string, IAgentProcess> = new Map();
  private logger: Logger;

  constructor() {
    super();
    this.logger = AgentLogger.create('CLIProcessManager');
  }

  async spawnAgent(config: IAgentConfig): Promise<ChildProcess> {
    try {
      // Ensure working directory exists
      await this.prepareWorkingDirectory(config.workingDirectory);

      // Create system prompt file
      const promptFile = path.join(config.workingDirectory, 'system-prompt.txt');
      await fs.writeFile(promptFile, config.systemPrompt);

      // Spawn Claude CLI process
      const args = [
        '--working-directory', config.workingDirectory,
        '--system-prompt-file', promptFile,
        '--mode', 'agent',
        '--json-output'
      ];

      if (config.model) {
        args.push('--model', config.model);
      }

      const process = spawn('claude', args, {
        cwd: config.workingDirectory,
        env: {
          ...process.env,
          CLAUDE_AGENT_ID: config.id,
          CLAUDE_AGENT_TYPE: config.type
        }
      });

      // Set up event handlers
      this.setupProcessHandlers(process, config);

      // Store agent process
      const agentProcess: IAgentProcess = {
        id: config.id,
        process,
        config,
        busy: false,
        taskQueue: [],
        stats: {
          startTime: Date.now(),
          tasksCompleted: 0,
          tasksFailed: 0
        }
      };

      this.agents.set(config.id, agentProcess);

      this.logger.info(`Spawned agent ${config.id} with PID ${process.pid}`);
      this.emit('agent:spawned', { agentId: config.id, pid: process.pid });

      return process;

    } catch (error) {
      this.logger.error(`Failed to spawn agent ${config.id}:`, error);
      throw new Error(`Failed to spawn agent: ${error.message}`);
    }
  }

  async sendTask(agentId: string, task: ITask): Promise<string> {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent ${agentId} not found`);
    }

    return new Promise((resolve, reject) => {
      // Queue the task
      agent.taskQueue.push({ task, resolve, reject });

      // Process queue if agent is not busy
      if (!agent.busy) {
        this.processTaskQueue(agentId);
      }
    });
  }

  private async processTaskQueue(agentId: string): Promise<void> {
    const agent = this.agents.get(agentId);
    if (!agent || agent.busy || agent.taskQueue.length === 0) {
      return;
    }

    agent.busy = true;
    const { task, resolve, reject } = agent.taskQueue.shift()!;

    try {
      // Create task file
      const taskFile = path.join(
        agent.config.workingDirectory,
        `task-${task.id}.json`
      );
      await fs.writeFile(taskFile, JSON.stringify(task, null, 2));

      // Send task to Claude CLI
      agent.process.stdin?.write(JSON.stringify({
        type: 'task',
        taskFile,
        taskId: task.id
      }) + '\n');

      // Set up response handler
      const responseHandler = (data: Buffer) => {
        const lines = data.toString().split('\n').filter(line => line.trim());
        
        for (const line of lines) {
          try {
            const response = JSON.parse(line);
            if (response.taskId === task.id) {
              if (response.status === 'completed') {
                agent.stats.tasksCompleted++;
                resolve(response.result);
              } else {
                agent.stats.tasksFailed++;
                reject(new Error(response.error || 'Task failed'));
              }
              
              // Clean up
              agent.process.stdout?.removeListener('data', responseHandler);
              agent.busy = false;
              
              // Process next task in queue
              if (agent.taskQueue.length > 0) {
                this.processTaskQueue(agentId);
              }
              
              break;
            }
          } catch (e) {
            // Not JSON, might be regular output
            this.logger.debug(`Non-JSON output from agent ${agentId}: ${line}`);
          }
        }
      };

      agent.process.stdout?.on('data', responseHandler);

    } catch (error) {
      agent.stats.tasksFailed++;
      agent.busy = false;
      reject(error);
      
      // Process next task
      if (agent.taskQueue.length > 0) {
        this.processTaskQueue(agentId);
      }
    }
  }

  async getAgentStats(agentId: string): Promise<any> {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent ${agentId} not found`);
    }

    const uptime = Date.now() - agent.stats.startTime;
    
    // Get process stats (simplified for now)
    return {
      uptime,
      tasksCompleted: agent.stats.tasksCompleted,
      tasksFailed: agent.stats.tasksFailed,
      queueLength: agent.taskQueue.length,
      busy: agent.busy,
      cpu: 0, // TODO: Implement actual CPU monitoring
      memory: process.memoryUsage().heapUsed // Approximate
    };
  }

  async terminateAgent(agentId: string): Promise<void> {
    const agent = this.agents.get(agentId);
    if (!agent) {
      return;
    }

    try {
      // Graceful shutdown signal
      agent.process.stdin?.write(JSON.stringify({ type: 'shutdown' }) + '\n');
      
      // Wait for graceful shutdown
      await new Promise<void>((resolve) => {
        const timeout = setTimeout(() => {
          agent.process.kill('SIGTERM');
          resolve();
        }, 5000);

        agent.process.once('exit', () => {
          clearTimeout(timeout);
          resolve();
        });
      });

      this.agents.delete(agentId);
      this.logger.info(`Terminated agent ${agentId}`);
      this.emit('agent:terminated', { agentId });

    } catch (error) {
      this.logger.error(`Error terminating agent ${agentId}:`, error);
      // Force kill if graceful shutdown fails
      agent.process.kill('SIGKILL');
      this.agents.delete(agentId);
    }
  }

  getActiveAgents(): string[] {
    return Array.from(this.agents.keys());
  }

  async shutdown(): Promise<void> {
    this.logger.info('Shutting down all agents...');
    
    const shutdownPromises = Array.from(this.agents.keys()).map(
      agentId => this.terminateAgent(agentId)
    );
    
    await Promise.all(shutdownPromises);
    this.logger.info('All agents terminated');
  }

  private async prepareWorkingDirectory(dir: string): Promise<void> {
    await fs.mkdir(dir, { recursive: true });
    await fs.mkdir(path.join(dir, '.claude'), { recursive: true });
    await fs.mkdir(path.join(dir, 'tasks'), { recursive: true });
    await fs.mkdir(path.join(dir, 'results'), { recursive: true });
  }

  private setupProcessHandlers(process: ChildProcess, config: IAgentConfig): void {
    process.on('error', (error) => {
      this.logger.error(`Agent ${config.id} process error:`, error);
      this.emit('agent:error', { agentId: config.id, error });
    });

    process.on('exit', (code, signal) => {
      this.logger.info(`Agent ${config.id} exited with code ${code} signal ${signal}`);
      this.agents.delete(config.id);
      this.emit('agent:exit', { agentId: config.id, code, signal });
    });

    process.stderr?.on('data', (data) => {
      this.logger.error(`Agent ${config.id} stderr: ${data}`);
    });
  }
}
```

### 3.3 File and Folder Mapping

```typescript
// src/cli/FileFolderMapper.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface IFileMapping {
  name: string;
  srcPath: string;
  destPath: string;
}

export interface IFolderMapping {
  name: string;
  srcPath: string;
  destPath: string;
}

export interface IGitMapping {
  github: string;
  destPath: string;
  branch?: string;
}

export class FileFolderMapper {
  async mapFiles(workingDir: string, mappings: IFileMapping[]): Promise<void> {
    for (const mapping of mappings) {
      const destFullPath = path.join(workingDir, mapping.destPath, mapping.name);
      const destDir = path.dirname(destFullPath);
      
      // Ensure destination directory exists
      await fs.mkdir(destDir, { recursive: true });
      
      // Copy file
      await fs.copyFile(mapping.srcPath, destFullPath);
    }
  }

  async mapFolders(workingDir: string, mappings: IFolderMapping[]): Promise<void> {
    for (const mapping of mappings) {
      const destFullPath = path.join(workingDir, mapping.destPath);
      
      // Ensure destination directory exists
      await fs.mkdir(destFullPath, { recursive: true });
      
      // Copy folder recursively
      await this.copyRecursive(mapping.srcPath, destFullPath);
    }
  }

  async cloneGitRepos(workingDir: string, mappings: IGitMapping[]): Promise<void> {
    for (const mapping of mappings) {
      const destFullPath = path.join(workingDir, mapping.destPath);
      
      // Ensure destination directory exists
      await fs.mkdir(path.dirname(destFullPath), { recursive: true });
      
      // Clone repository
      const branch = mapping.branch || 'main';
      const { stderr } = await execAsync(
        `git clone --branch ${branch} ${mapping.github} ${destFullPath}`,
        { cwd: workingDir }
      );
      
      if (stderr && !stderr.includes('Cloning into')) {
        throw new Error(`Git clone failed: ${stderr}`);
      }
    }
  }

  private async copyRecursive(src: string, dest: string): Promise<void> {
    const stats = await fs.stat(src);
    
    if (stats.isDirectory()) {
      await fs.mkdir(dest, { recursive: true });
      const entries = await fs.readdir(src, { withFileTypes: true });
      
      for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);
        
        if (entry.isDirectory()) {
          await this.copyRecursive(srcPath, destPath);
        } else {
          await fs.copyFile(srcPath, destPath);
        }
      }
    } else {
      await fs.copyFile(src, dest);
    }
  }
}
```

## Success Criteria
- [x] Claude CLI processes can be spawned successfully
- [x] Each agent has isolated working directory
- [x] Tasks can be sent to agents and responses received
- [x] Multiple concurrent tasks are handled properly
- [x] Resource tracking works correctly
- [x] Graceful shutdown is implemented
- [x] File/folder mapping works as specified
- [x] Git repository cloning works
- [x] All tests pass with 100% coverage

## Estimated Time
4-5 hours

## Dependencies
- Step 1 (Project Setup) must be complete
- Step 2 (BaseAgent) must be complete
- Claude CLI must be installed on the system

## Output
- Working CLI process spawning system
- File and folder mapping functionality
- Resource tracking and management
- Communication protocol between orchestrator and CLI agents