# Step 1: TDD Infrastructure and Testing Framework

## Objective
Establish a comprehensive Test-Driven Development (TDD) infrastructure using London School methodology with 100% code coverage requirement. This forms the foundation for all subsequent development.

## Prerequisites
- Step 0 POC completed with GO decision
- Node.js 18+ and TypeScript 5+ installed
- Understanding of London School TDD (outside-in, mockist approach)

## Project Structure

```
claude-multi-agent/
├── src/
│   ├── agents/
│   │   ├── __tests__/
│   │   ├── base-agent.ts
│   │   └── index.ts
│   ├── cli/
│   │   ├── __tests__/
│   │   ├── process-manager.ts
│   │   └── index.ts
│   ├── messaging/
│   │   ├── __tests__/
│   │   ├── message-queue.ts
│   │   └── index.ts
│   ├── repository/
│   │   ├── __tests__/
│   │   ├── worktree-manager.ts
│   │   └── index.ts
│   ├── types/
│   │   └── index.ts
│   └── utils/
│       ├── __tests__/
│       └── logger.ts
├── test/
│   ├── fixtures/
│   ├── mocks/
│   ├── builders/
│   ├── matchers/
│   ├── setup.ts
│   └── teardown.ts
├── coverage/
├── .github/
│   └── workflows/
│       └── test.yml
├── jest.config.ts
├── tsconfig.json
├── tsconfig.test.json
├── package.json
└── README.md
```

## Implementation

### 1.1 Jest Configuration

```typescript
// jest.config.ts
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/test'],
  testMatch: [
    '**/__tests__/**/*.spec.ts',
    '**/__tests__/**/*.test.ts'
  ],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts',
    '!src/**/__tests__/**'
  ],
  coverageThreshold: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],
  globalTeardown: '<rootDir>/test/teardown.ts',
  testTimeout: 30000,
  verbose: true,
  // Mock modules
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@test/(.*)$': '<rootDir>/test/$1'
  }
};

export default config;
```

### 1.2 Test Setup and Teardown

```typescript
// test/setup.ts
import { jest } from '@jest/globals';

// Extend Jest matchers
import './matchers';

// Global test configuration
beforeAll(() => {
  // Set test environment variables
  process.env.NODE_ENV = 'test';
  process.env.LOG_LEVEL = 'silent';
  process.env.CLAUDE_TEST_MODE = 'true';
});

// Reset mocks between tests
beforeEach(() => {
  jest.clearAllMocks();
  jest.restoreAllMocks();
});

// Cleanup after each test
afterEach(() => {
  // Clear any test artifacts
});

// test/teardown.ts
export default async function globalTeardown() {
  // Clean up any global resources
  console.log('Test suite completed');
}
```

### 1.3 Mock Infrastructure

```typescript
// test/mocks/MockFactory.ts
import { jest } from '@jest/globals';
import { ChildProcess } from 'child_process';
import { EventEmitter } from 'events';

export class MockFactory {
  /**
   * Creates a mock ChildProcess for testing CLI interactions
   */
  static createMockChildProcess(): jest.Mocked<ChildProcess> {
    const mockProcess = new EventEmitter() as jest.Mocked<ChildProcess>;
    
    // Mock stdout/stderr as EventEmitters
    mockProcess.stdout = new EventEmitter() as any;
    mockProcess.stderr = new EventEmitter() as any;
    
    // Mock stdin
    mockProcess.stdin = {
      write: jest.fn().mockReturnValue(true),
      end: jest.fn(),
      setEncoding: jest.fn(),
      pipe: jest.fn()
    } as any;
    
    // Mock process methods
    mockProcess.kill = jest.fn().mockReturnValue(true);
    mockProcess.pid = Math.floor(Math.random() * 10000);
    mockProcess.exitCode = null;
    mockProcess.killed = false;
    
    return mockProcess;
  }

  /**
   * Creates a mock Logger for testing
   */
  static createMockLogger(): jest.Mocked<Logger> {
    return {
      debug: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
      child: jest.fn().mockReturnThis()
    };
  }

  /**
   * Creates a mock Claude SDK response
   */
  static createMockClaudeResponse(
    overrides?: Partial<ClaudeSDKResponse>
  ): ClaudeSDKResponse {
    return {
      type: 'result',
      subtype: 'success',
      cost_usd: 0.0001,
      duration_ms: 1000,
      duration_api_ms: 800,
      is_error: false,
      num_turns: 1,
      result: 'Mock response',
      session_id: `session_${Date.now()}`,
      ...overrides
    };
  }

  /**
   * Creates a mock file system
   */
  static createMockFileSystem() {
    return {
      readFile: jest.fn(),
      writeFile: jest.fn(),
      mkdir: jest.fn(),
      rm: jest.fn(),
      stat: jest.fn(),
      access: jest.fn()
    };
  }
}
```

### 1.4 Test Builders

```typescript
// test/builders/TaskBuilder.ts
export class TaskBuilder {
  private task: Partial<ITask> = {
    id: `task_${Date.now()}_${Math.random()}`,
    type: 'research',
    priority: 'medium',
    status: 'pending',
    createdAt: new Date(),
    description: 'Test task'
  };

  withId(id: string): this {
    this.task.id = id;
    return this;
  }

  withType(type: TaskType): this {
    this.task.type = type;
    return this;
  }

  withPriority(priority: Priority): this {
    this.task.priority = priority;
    return this;
  }

  withDescription(description: string): this {
    this.task.description = description;
    return this;
  }

  withContext(context: any): this {
    this.task.context = context;
    return this;
  }

  build(): ITask {
    return this.task as ITask;
  }
}

// test/builders/AgentBuilder.ts
export class AgentBuilder {
  private config: Partial<IAgentConfig> = {
    id: `agent_${Date.now()}`,
    type: 'research',
    maxTurns: 10
  };

  withId(id: string): this {
    this.config.id = id;
    return this;
  }

  withType(type: AgentType): this {
    this.config.type = type;
    return this;
  }

  withSystemPrompt(prompt: string): this {
    this.config.systemPrompt = prompt;
    return this;
  }

  withAllowedTools(tools: string[]): this {
    this.config.allowedTools = tools;
    return this;
  }

  build(): IAgentConfig {
    return this.config as IAgentConfig;
  }
}
```

### 1.5 Custom Matchers

```typescript
// test/matchers/index.ts
import { expect } from '@jest/globals';

declare global {
  namespace jest {
    interface Matchers<R> {
      toBeValidClaudeResponse(): R;
      toBeValidTask(): R;
      toHaveBeenCalledWithMessage(expectedMessage: Partial<IMessage>): R;
    }
  }
}

expect.extend({
  toBeValidClaudeResponse(received: any) {
    const pass = 
      received?.type === 'result' &&
      ['success', 'error_max_turns', 'error'].includes(received?.subtype) &&
      typeof received?.session_id === 'string' &&
      typeof received?.cost_usd === 'number' &&
      typeof received?.duration_ms === 'number';

    if (pass) {
      return {
        message: () => `expected ${JSON.stringify(received)} not to be a valid Claude response`,
        pass: true
      };
    } else {
      return {
        message: () => `expected ${JSON.stringify(received)} to be a valid Claude response`,
        pass: false
      };
    }
  },

  toBeValidTask(received: any) {
    const pass = 
      received?.id &&
      received?.type &&
      received?.priority &&
      received?.status &&
      received?.description;

    return {
      pass,
      message: () => pass
        ? `expected ${JSON.stringify(received)} not to be a valid task`
        : `expected ${JSON.stringify(received)} to be a valid task`
    };
  },

  toHaveBeenCalledWithMessage(received: jest.Mock, expectedMessage: Partial<IMessage>) {
    const calls = received.mock.calls;
    const found = calls.some(([message]) => {
      return Object.entries(expectedMessage).every(
        ([key, value]) => message[key] === value
      );
    });

    return {
      pass: found,
      message: () => found
        ? `expected not to be called with message containing ${JSON.stringify(expectedMessage)}`
        : `expected to be called with message containing ${JSON.stringify(expectedMessage)}`
    };
  }
});
```

### 1.6 Test Utilities

```typescript
// test/utils/TestHelpers.ts
export class TestHelpers {
  /**
   * Wait for a condition to be true
   */
  static async waitFor(
    condition: () => boolean | Promise<boolean>,
    timeout: number = 5000,
    interval: number = 100
  ): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      if (await condition()) {
        return;
      }
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error('Timeout waiting for condition');
  }

  /**
   * Create a deferred promise for testing async flows
   */
  static createDeferred<T>(): {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (error: Error) => void;
  } {
    let resolve: (value: T) => void;
    let reject: (error: Error) => void;
    
    const promise = new Promise<T>((res, rej) => {
      resolve = res;
      reject = rej;
    });
    
    return { promise, resolve: resolve!, reject: reject! };
  }

  /**
   * Capture console output during tests
   */
  static captureConsole() {
    const originalLog = console.log;
    const originalError = console.error;
    const logs: string[] = [];
    const errors: string[] = [];
    
    console.log = (...args) => logs.push(args.join(' '));
    console.error = (...args) => errors.push(args.join(' '));
    
    return {
      logs,
      errors,
      restore: () => {
        console.log = originalLog;
        console.error = originalError;
      }
    };
  }
}
```

### 1.7 Example Test Structure

```typescript
// src/agents/__tests__/base-agent.spec.ts
import { BaseAgent } from '../base-agent';
import { MockFactory } from '@test/mocks/MockFactory';
import { TaskBuilder } from '@test/builders/TaskBuilder';
import { TestHelpers } from '@test/utils/TestHelpers';

describe('BaseAgent', () => {
  let mockLogger: jest.Mocked<Logger>;
  let mockCLIManager: jest.Mocked<CLIProcessManager>;
  let mockMemoryManager: jest.Mocked<MemoryManager>;

  // Test implementation of abstract BaseAgent
  class TestAgent extends BaseAgent {
    async onInitialize(): Promise<void> {
      // Test implementation
    }

    async prepareContext(task: ITask): Promise<IExecutionContext> {
      return { workingDirectory: '/test' };
    }

    async processResponse(response: ClaudeSDKResponse, task: ITask): Promise<string> {
      return response.result || '';
    }

    async onTerminate(): Promise<void> {
      // Test implementation
    }
  }

  beforeEach(() => {
    // Create mocks
    mockLogger = MockFactory.createMockLogger();
    mockCLIManager = createMock<CLIProcessManager>();
    mockMemoryManager = createMock<MemoryManager>();
  });

  describe('constructor', () => {
    it('should initialize with valid configuration', () => {
      // Arrange
      const config = new AgentBuilder()
        .withId('test-agent')
        .withType('research')
        .build();

      // Act
      const agent = new TestAgent(config, mockLogger, mockCLIManager, mockMemoryManager);

      // Assert
      expect(agent.id).toBe('test-agent');
      expect(agent.type).toBe('research');
      expect(agent.getState()).toBe('idle');
    });

    it('should reject invalid configuration', () => {
      // Arrange
      const invalidConfig = { type: 'research' } as any;

      // Act & Assert
      expect(() => new TestAgent(invalidConfig, mockLogger))
        .toThrow('Invalid agent configuration: id is required');
    });
  });

  describe('initialization', () => {
    let agent: TestAgent;

    beforeEach(() => {
      const config = new AgentBuilder().build();
      agent = new TestAgent(config, mockLogger, mockCLIManager, mockMemoryManager);
    });

    it('should initialize successfully', async () => {
      // Arrange
      mockCLIManager.createSession.mockResolvedValue(
        MockFactory.createMockClaudeResponse({ session_id: 'test-session' })
      );

      // Act
      await agent.initialize();

      // Assert
      expect(agent.getState()).toBe('ready');
      expect(agent.sessionId).toBe('test-session');
      expect(mockCLIManager.createSession).toHaveBeenCalledWith(
        expect.objectContaining({
          systemPrompt: expect.any(String),
          outputFormat: 'json'
        })
      );
    });

    it('should handle initialization failure', async () => {
      // Arrange
      mockCLIManager.createSession.mockRejectedValue(new Error('Session failed'));

      // Act & Assert
      await expect(agent.initialize()).rejects.toThrow('Agent initialization failed');
      expect(agent.getState()).toBe('error');
    });

    it('should prevent double initialization', async () => {
      // Arrange
      mockCLIManager.createSession.mockResolvedValue(
        MockFactory.createMockClaudeResponse()
      );

      // Act
      await agent.initialize();
      await agent.initialize();

      // Assert
      expect(mockCLIManager.createSession).toHaveBeenCalledTimes(1);
      expect(mockLogger.warn).toHaveBeenCalledWith('Agent already initialized');
    });
  });

  describe('task execution', () => {
    let agent: TestAgent;

    beforeEach(async () => {
      const config = new AgentBuilder().build();
      agent = new TestAgent(config, mockLogger, mockCLIManager, mockMemoryManager);
      
      mockCLIManager.createSession.mockResolvedValue(
        MockFactory.createMockClaudeResponse({ session_id: 'test-session' })
      );
      
      await agent.initialize();
    });

    it('should execute task successfully', async () => {
      // Arrange
      const task = new TaskBuilder()
        .withId('task-123')
        .withType('research')
        .build();

      mockCLIManager.execute.mockResolvedValue(
        MockFactory.createMockClaudeResponse({
          result: 'Task completed successfully',
          cost_usd: 0.01,
          num_turns: 2
        })
      );

      // Act
      const result = await agent.execute(task);

      // Assert
      expect(result).toMatchObject({
        taskId: 'task-123',
        agentId: agent.id,
        status: 'completed',
        result: 'Task completed successfully'
      });
      expect(result.metrics.cost_usd).toBe(0.01);
      expect(result.metrics.turns_used).toBe(2);
    });

    it('should handle task execution failure', async () => {
      // Arrange
      const task = new TaskBuilder().build();
      mockCLIManager.execute.mockRejectedValue(new Error('Execution failed'));

      // Act
      const result = await agent.execute(task);

      // Assert
      expect(result.status).toBe('failed');
      expect(result.error?.message).toBe('Execution failed');
    });

    it('should validate task compatibility', async () => {
      // Arrange
      const agent = new TestAgent(
        new AgentBuilder().withType('research').build(),
        mockLogger,
        mockCLIManager,
        mockMemoryManager
      );
      
      await agent.initialize();

      const incompatibleTask = new TaskBuilder()
        .withType('implementation')
        .build();

      // Act & Assert
      await expect(agent.execute(incompatibleTask))
        .rejects.toThrow('Task type \'implementation\' not compatible');
    });
  });

  describe('state management', () => {
    it('should track state transitions', async () => {
      // Arrange
      const agent = new TestAgent(
        new AgentBuilder().build(),
        mockLogger,
        mockCLIManager,
        mockMemoryManager
      );

      const stateChanges: any[] = [];
      agent.on('stateChange', (change) => stateChanges.push(change));

      mockCLIManager.createSession.mockResolvedValue(
        MockFactory.createMockClaudeResponse()
      );

      // Act
      await agent.initialize();

      // Assert
      expect(stateChanges).toEqual([
        { previousState: 'idle', currentState: 'initializing' },
        { previousState: 'initializing', currentState: 'ready' }
      ]);
    });
  });

  describe('cleanup', () => {
    it('should clean up resources on termination', async () => {
      // Arrange
      const agent = new TestAgent(
        new AgentBuilder().build(),
        mockLogger,
        mockCLIManager,
        mockMemoryManager
      );

      mockCLIManager.createSession.mockResolvedValue(
        MockFactory.createMockClaudeResponse({ session_id: 'test-session' })
      );

      await agent.initialize();

      // Act
      await agent.terminate();

      // Assert
      expect(agent.getState()).toBe('terminated');
      expect(mockCLIManager.endSession).toHaveBeenCalledWith('test-session');
    });
  });
});
```

### 1.8 Coverage Scripts

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:coverage:html": "jest --coverage --coverageReporters=html",
    "test:ci": "jest --ci --coverage --maxWorkers=2",
    "test:debug": "node --inspect-brk ./node_modules/.bin/jest --runInBand"
  }
}
```

### 1.9 CI/CD Configuration

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linter
      run: npm run lint
    
    - name: Run type check
      run: npm run type-check
    
    - name: Run tests with coverage
      run: npm run test:ci
    
    - name: Check coverage thresholds
      run: npm run test:coverage
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/coverage-final.json
        flags: unittests
        name: codecov-umbrella
    
    - name: Archive test results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: |
          coverage/
          junit.xml
```

## Testing Best Practices

### London School TDD Approach
1. **Outside-In**: Start with the public API, work inward
2. **Mock Everything**: Mock all collaborators
3. **Test Behavior**: Focus on interactions, not implementation
4. **Isolated Units**: Each test should be independent

### Test Organization
```
describe('ComponentName', () => {
  describe('methodName', () => {
    it('should behavior when condition', () => {
      // Arrange
      // Act  
      // Assert
    });
  });
});
```

### Coverage Requirements
- **100% Code Coverage**: Enforced by Jest
- **Branch Coverage**: All if/else paths
- **Function Coverage**: All functions tested
- **Line Coverage**: Every line executed
- **Statement Coverage**: All statements covered

## Success Criteria
- ✅ Jest configured with TypeScript support
- ✅ 100% coverage thresholds enforced
- ✅ Mock infrastructure established
- ✅ Test builders and custom matchers ready
- ✅ CI/CD pipeline configured
- ✅ Example tests demonstrating patterns

## Next Steps
With TDD infrastructure in place:
1. All new code must be test-driven
2. No code without tests
3. Tests must pass before commits
4. Coverage must remain at 100%
5. Proceed to Step 2: Core Types and Interfaces