# Step 3: CLI Process Manager Implementation

## Objective
Implement a robust CLI Process Manager that handles Claude CLI spawning, session management, and communication using SDK print mode. This is the core infrastructure for agent-Claude interaction.

## Prerequisites
- Step 0 POC validated CLI SDK mode
- Step 1 TDD infrastructure ready
- Step 2 Core types defined
- 100% test coverage requirement

## Test-First Implementation

### 3.1 CLI Process Manager Tests

```typescript
// src/cli/__tests__/cli-process-manager.spec.ts
import { CLIProcessManager } from '../cli-process-manager';
import { spawn } from 'child_process';
import { MockFactory } from '@test/mocks/MockFactory';
import { TestHelpers } from '@test/utils/TestHelpers';
import type { ISessionConfig, IClaudeSDKResponse } from '@/types';

jest.mock('child_process');

describe('CLIProcessManager', () => {
  let manager: CLIProcessManager;
  let mockLogger: jest.Mocked<ILogger>;
  let mockSpawn: jest.MockedFunction<typeof spawn>;
  let mockChildProcess: ReturnType<typeof MockFactory.createMockChildProcess>;

  beforeEach(() => {
    mockLogger = MockFactory.createMockLogger();
    mockSpawn = spawn as jest.MockedFunction<typeof spawn>;
    mockChildProcess = MockFactory.createMockChildProcess();
    mockSpawn.mockReturnValue(mockChildProcess as any);
    
    manager = new CLIProcessManager(mockLogger);
  });

  afterEach(async () => {
    await manager.shutdown();
  });

  describe('createSession', () => {
    it('should create session with correct arguments', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test prompt',
        systemPrompt: 'You are a test agent',
        outputFormat: 'json',
        maxTurns: 5,
        allowedTools: ['Read(**)', 'Bash(ls:*)'],
        disallowedTools: ['Edit(**)', 'Bash(rm:*)'],
        skipPermissions: true
      };

      const mockResponse: IClaudeSDKResponse = {
        type: 'result',
        subtype: 'success',
        session_id: 'test-session-123',
        result: 'Session created',
        cost_usd: 0.001,
        duration_ms: 100,
        duration_api_ms: 80,
        num_turns: 1,
        is_error: false
      };

      // Act
      const responsePromise = manager.createSession(config);
      
      // Simulate Claude response
      process.nextTick(() => {
        mockChildProcess.stdout.emit('data', JSON.stringify(mockResponse));
        mockChildProcess.emit('close', 0);
      });
      
      const response = await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude', [
        '-p', 'Test prompt',
        '--system-prompt', 'You are a test agent',
        '--output-format', 'json',
        '--max-turns', '5',
        '--allowedTools', 'Read(**)',
        '--allowedTools', 'Bash(ls:*)',
        '--disallowedTools', 'Edit(**)',
        '--disallowedTools', 'Bash(rm:*)',
        '--dangerously-skip-permissions'
      ], expect.objectContaining({
        env: expect.objectContaining({
          NO_COLOR: '1',
          CLAUDE_NO_COLOR: '1'
        })
      }));
      
      expect(response).toEqual(mockResponse);
      expect(response).toBeValidClaudeResponse();
      expect(manager.getActiveSessionCount()).toBe(1);
    });

    it('should handle working directory and environment', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test',
        outputFormat: 'json',
        workingDirectory: '/custom/path',
        env: {
          CUSTOM_VAR: 'custom_value'
        }
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.stdout.emit('data', JSON.stringify(
        MockFactory.createMockClaudeResponse()
      ));
      mockChildProcess.emit('close', 0);
      await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude', 
        expect.any(Array),
        expect.objectContaining({
          cwd: '/custom/path',
          env: expect.objectContaining({
            CUSTOM_VAR: 'custom_value'
          })
        })
      );
    });

    it('should handle JSON parsing errors', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.stdout.emit('data', 'Invalid JSON');
      mockChildProcess.emit('close', 0);

      // Assert
      await expect(responsePromise).rejects.toThrow('Failed to parse JSON');
    });

    it('should handle process errors', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.emit('error', new Error('Spawn failed'));

      // Assert
      await expect(responsePromise).rejects.toThrow('Spawn failed');
    });

    it('should handle non-zero exit codes', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.stderr.emit('data', 'Error message');
      mockChildProcess.emit('close', 1);

      // Assert
      await expect(responsePromise).rejects.toThrow('Claude exited with code 1');
    });
  });

  describe('execute', () => {
    beforeEach(async () => {
      // Create a session first
      const createPromise = manager.createSession({
        prompt: 'Init',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        session_id: 'existing-session',
        result: 'Ready',
        cost_usd: 0.001,
        duration_ms: 100,
        duration_api_ms: 80,
        num_turns: 1,
        is_error: false
      }));
      mockChildProcess.emit('close', 0);
      
      await createPromise;
      
      // Reset mock for next calls
      mockChildProcess = MockFactory.createMockChildProcess();
      mockSpawn.mockReturnValue(mockChildProcess as any);
    });

    it('should execute with session continuation', async () => {
      // Arrange
      const config = {
        sessionId: 'existing-session',
        prompt: 'Continue conversation',
        outputFormat: 'json' as const
      };

      // Act
      const responsePromise = manager.execute(config);
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        result: 'Continued response',
        session_id: 'existing-session',
        cost_usd: 0.002,
        duration_ms: 150,
        duration_api_ms: 120,
        num_turns: 1,
        is_error: false
      }));
      mockChildProcess.emit('close', 0);
      
      const response = await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude',
        expect.arrayContaining(['--continue', '-p', 'Continue conversation']),
        expect.any(Object)
      );
      expect(response.result).toBe('Continued response');
    });

    it('should handle session resume', async () => {
      // Arrange
      const config = {
        sessionId: 'existing-session',
        prompt: 'Resume after break',
        outputFormat: 'json' as const,
        resume: true
      };

      // Act
      const responsePromise = manager.execute(config);
      
      mockChildProcess.stdout.emit('data', JSON.stringify(
        MockFactory.createMockClaudeResponse()
      ));
      mockChildProcess.emit('close', 0);
      
      await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude',
        expect.arrayContaining(['--resume', 'existing-session']),
        expect.any(Object)
      );
    });

    it('should reject execution with invalid session', async () => {
      // Arrange
      const config = {
        sessionId: 'non-existent-session',
        prompt: 'Test',
        outputFormat: 'json' as const
      };

      // Act & Assert
      await expect(manager.execute(config)).rejects.toThrow(
        'Session non-existent-session not found'
      );
    });
  });

  describe('executeStreaming', () => {
    it('should stream JSON messages', async () => {
      // Arrange
      const config = {
        sessionId: 'test-session',
        prompt: 'Stream test',
        outputFormat: 'stream-json' as const
      };

      const messages: IStreamMessage[] = [];
      
      // Create session
      const createPromise = manager.createSession({
        prompt: 'Init',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        session_id: 'test-session',
        result: 'Ready',
        cost_usd: 0.001,
        duration_ms: 100,
        duration_api_ms: 80,
        num_turns: 1,
        is_error: false
      }));
      mockChildProcess.emit('close', 0);
      
      await createPromise;
      
      // Reset for streaming
      mockChildProcess = MockFactory.createMockChildProcess();
      mockSpawn.mockReturnValue(mockChildProcess as any);

      // Act
      const streamPromise = (async () => {
        for await (const message of manager.executeStreaming(config)) {
          messages.push(message);
          if (message.type === 'result') break;
        }
      })();

      // Simulate streaming messages
      await TestHelpers.waitFor(() => mockSpawn.mock.calls.length > 1);
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'system',
        subtype: 'init',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'assistant',
        content: 'Streaming response',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.emit('close', 0);
      
      await streamPromise;

      // Assert
      expect(messages).toHaveLength(3);
      expect(messages[0].type).toBe('system');
      expect(messages[1].type).toBe('assistant');
      expect(messages[2].type).toBe('result');
    });

    it('should handle partial JSON lines', async () => {
      // Arrange - setup session first
      const createPromise = manager.createSession({
        prompt: 'Init',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        session_id: 'test-session',
        result: 'Ready',
        cost_usd: 0.001,
        duration_ms: 100,
        duration_api_ms: 80,
        num_turns: 1,
        is_error: false
      }));
      mockChildProcess.emit('close', 0);
      
      await createPromise;
      
      mockChildProcess = MockFactory.createMockChildProcess();
      mockSpawn.mockReturnValue(mockChildProcess as any);

      const messages: IStreamMessage[] = [];

      // Act
      const streamPromise = (async () => {
        for await (const message of manager.executeStreaming({
          sessionId: 'test-session',
          prompt: 'Test',
          outputFormat: 'stream-json'
        })) {
          messages.push(message);
          if (message.type === 'result') break;
        }
      })();

      await TestHelpers.waitFor(() => mockSpawn.mock.calls.length > 1);

      // Send partial JSON
      const fullMessage = JSON.stringify({
        type: 'assistant',
        content: 'Long message',
        session_id: 'test-session'
      });
      
      mockChildProcess.stdout.emit('data', fullMessage.substring(0, 20));
      mockChildProcess.stdout.emit('data', fullMessage.substring(20) + '\n');
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.emit('close', 0);
      
      await streamPromise;

      // Assert
      expect(messages.some(m => m.content === 'Long message')).toBe(true);
    });
  });

  describe('resource management', () => {
    it('should enforce process timeout', async () => {
      // Arrange
      manager = new CLIProcessManager(mockLogger, {
        processTimeout: 100
      });

      const config: ISessionConfig = {
        prompt: 'Long running task',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      
      // Wait for timeout
      await TestHelpers.waitFor(() => mockChildProcess.kill.mock.calls.length > 0, 200);

      // Assert
      expect(mockChildProcess.kill).toHaveBeenCalledWith('SIGTERM');
      await expect(responsePromise).rejects.toThrow('Process timeout');
    });

    it('should limit concurrent processes', async () => {
      // Arrange
      manager = new CLIProcessManager(mockLogger, {
        maxConcurrentProcesses: 2
      });

      // Act - try to create 3 sessions
      const promises = [];
      for (let i = 0; i < 3; i++) {
        promises.push(manager.createSession({
          prompt: `Session ${i}`,
          outputFormat: 'json'
        }));
      }

      // Complete first two
      mockChildProcess.stdout.emit('data', JSON.stringify(
        MockFactory.createMockClaudeResponse({ session_id: 'session-1' })
      ));
      mockChildProcess.emit('close', 0);

      // Third should be queued
      await expect(Promise.race([
        promises[2],
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 100))
      ])).rejects.toThrow('Timeout');
    });
  });

  describe('error recovery', () => {
    it('should implement circuit breaker', async () => {
      // Arrange - fail multiple times
      for (let i = 0; i < 5; i++) {
        try {
          const promise = manager.createSession({
            prompt: 'Test',
            outputFormat: 'json'
          });
          mockChildProcess.emit('error', new Error('Connection failed'));
          await promise;
        } catch (e) {
          // Expected
        }
      }

      // Act - circuit should be open
      const promise = manager.createSession({
        prompt: 'Test',
        outputFormat: 'json'
      });

      // Assert
      await expect(promise).rejects.toThrow('Circuit breaker is open');
    });

    it('should implement rate limiting', async () => {
      // Arrange
      manager = new CLIProcessManager(mockLogger, {
        rateLimitConfig: {
          maxRequests: 2,
          windowMs: 1000
        }
      });

      // Act - make requests quickly
      const promises = [];
      for (let i = 0; i < 3; i++) {
        promises.push(manager.createSession({
          prompt: `Request ${i}`,
          outputFormat: 'json'
        }));
      }

      // First two should work
      mockChildProcess.stdout.emit('data', JSON.stringify(
        MockFactory.createMockClaudeResponse()
      ));
      mockChildProcess.emit('close', 0);

      // Third should be rate limited
      await expect(promises[2]).rejects.toThrow('Rate limit exceeded');
    });
  });

  describe('session management', () => {
    it('should track sessions correctly', async () => {
      // Arrange & Act
      const sessions = [];
      for (let i = 0; i < 3; i++) {
        const promise = manager.createSession({
          prompt: `Session ${i}`,
          outputFormat: 'json'
        });
        
        mockChildProcess.stdout.emit('data', JSON.stringify(
          MockFactory.createMockClaudeResponse({ session_id: `session-${i}` })
        ));
        mockChildProcess.emit('close', 0);
        
        sessions.push(await promise);
        
        mockChildProcess = MockFactory.createMockChildProcess();
        mockSpawn.mockReturnValue(mockChildProcess as any);
      }

      // Assert
      expect(manager.getActiveSessionCount()).toBe(3);
      expect(manager.hasSession('session-1')).toBe(true);
      expect(manager.hasSession('session-999')).toBe(false);
    });

    it('should clean up stale sessions', async () => {
      // Arrange
      jest.useFakeTimers();
      
      manager = new CLIProcessManager(mockLogger, {
        sessionTimeout: 1000 // 1 second
      });

      const promise = manager.createSession({
        prompt: 'Test',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify(
        MockFactory.createMockClaudeResponse({ session_id: 'stale-session' })
      ));
      mockChildProcess.emit('close', 0);
      
      await promise;

      // Act - advance time
      jest.advanceTimersByTime(2000);

      // Assert
      expect(manager.hasSession('stale-session')).toBe(false);
      
      jest.useRealTimers();
    });
  });

  describe('shutdown', () => {
    it('should clean up all resources on shutdown', async () => {
      // Arrange - create multiple sessions
      for (let i = 0; i < 2; i++) {
        const promise = manager.createSession({
          prompt: `Session ${i}`,
          outputFormat: 'json'
        });
        
        mockChildProcess.stdout.emit('data', JSON.stringify(
          MockFactory.createMockClaudeResponse({ session_id: `session-${i}` })
        ));
        mockChildProcess.emit('close', 0);
        
        await promise;
        
        mockChildProcess = MockFactory.createMockChildProcess();
        mockSpawn.mockReturnValue(mockChildProcess as any);
      }

      expect(manager.getActiveSessionCount()).toBe(2);

      // Act
      await manager.shutdown();

      // Assert
      expect(manager.getActiveSessionCount()).toBe(0);
      await expect(manager.createSession({
        prompt: 'After shutdown',
        outputFormat: 'json'
      })).rejects.toThrow('CLI Process Manager is shutting down');
    });

    it('should kill active processes on shutdown', async () => {
      // Arrange - start a long-running process
      const promise = manager.createSession({
        prompt: 'Long task',
        outputFormat: 'json'
      });

      // Don't complete the process

      // Act
      const shutdownPromise = manager.shutdown();
      
      // Should kill the process
      await TestHelpers.waitFor(() => mockChildProcess.kill.mock.calls.length > 0);
      
      mockChildProcess.emit('exit', 0);
      
      await shutdownPromise;

      // Assert
      expect(mockChildProcess.kill).toHaveBeenCalledWith('SIGTERM');
    });
  });
});
```

### 3.2 CLI Process Manager Implementation

```typescript
// src/cli/cli-process-manager.ts
import { spawn, ChildProcess, SpawnOptions } from 'child_process';
import { EventEmitter } from 'events';
import type {
  ILogger,
  ISessionConfig,
  IExecutionConfig,
  IClaudeSDKResponse,
  IStreamMessage,
  IProcessOptions,
  ISessionInfo
} from '@/types';
import { SessionManager } from './session-manager';
import { CircuitBreaker } from './circuit-breaker';
import { RateLimiter } from './rate-limiter';
import { ProcessQueue } from './process-queue';

export class CLIProcessManager extends EventEmitter {
  private sessionManager: SessionManager;
  private circuitBreaker: CircuitBreaker;
  private rateLimiter: RateLimiter;
  private processQueue: ProcessQueue;
  private activeProcesses = new Map<string, ChildProcess>();
  private shuttingDown = false;
  private options: Required<IProcessOptions>;

  constructor(
    private logger: ILogger,
    options: IProcessOptions = {}
  ) {
    super();
    
    this.options = {
      maxConcurrentProcesses: options.maxConcurrentProcesses || 10,
      processTimeout: options.processTimeout || 120000,
      memoryLimit: options.memoryLimit || 512,
      cpuLimit: options.cpuLimit || 1,
      retryAttempts: options.retryAttempts || 3,
      retryDelay: options.retryDelay || 1000,
      sessionTimeout: options.sessionTimeout || 30 * 60 * 1000,
      rateLimitConfig: options.rateLimitConfig || {
        maxRequests: 100,
        windowMs: 60000
      }
    };
    
    this.sessionManager = new SessionManager(this.logger, {
      timeout: this.options.sessionTimeout
    });
    
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      resetTimeout: 60000,
      logger: this.logger
    });
    
    this.rateLimiter = new RateLimiter(this.options.rateLimitConfig);
    
    this.processQueue = new ProcessQueue({
      maxConcurrent: this.options.maxConcurrentProcesses,
      logger: this.logger
    });
    
    this.setupEventHandlers();
  }

  async createSession(config: ISessionConfig): Promise<IClaudeSDKResponse> {
    this.validateNotShuttingDown();
    await this.rateLimiter.checkLimit();
    
    return this.circuitBreaker.execute(async () => {
      const args = this.buildArgs(config);
      const spawnOptions = this.buildSpawnOptions(config);
      const processId = `session_${Date.now()}_${Math.random()}`;
      
      this.logger.debug('Creating new Claude session', { 
        processId,
        args: args.filter(arg => !arg.includes('--')), // Log non-sensitive args
        workingDirectory: spawnOptions.cwd 
      });
      
      try {
        const response = await this.executeCommand(
          processId,
          args,
          spawnOptions,
          config.prompt
        );
        
        if (response.session_id) {
          this.sessionManager.registerSession(response.session_id, {
            sessionId: response.session_id,
            agentId: config.metadata?.agentId || 'unknown',
            createdAt: new Date(),
            lastUsed: new Date(),
            config: config
          });
        }
        
        this.emit('sessionCreated', { sessionId: response.session_id, config });
        
        return response;
      } catch (error) {
        this.logger.error('Failed to create session', { processId, error });
        throw error;
      }
    });
  }

  async execute(config: IExecutionConfig): Promise<IClaudeSDKResponse> {
    this.validateNotShuttingDown();
    await this.rateLimiter.checkLimit();
    
    if (!this.sessionManager.hasSession(config.sessionId)) {
      throw new Error(`Session ${config.sessionId} not found`);
    }
    
    return this.circuitBreaker.execute(async () => {
      const args = this.buildArgsForExecution(config);
      const spawnOptions = this.buildSpawnOptions(config);
      const processId = `exec_${Date.now()}_${Math.random()}`;
      
      this.logger.debug('Executing command in session', {
        processId,
        sessionId: config.sessionId,
        resume: config.resume
      });
      
      try {
        const response = await this.executeCommand(
          processId,
          args,
          spawnOptions,
          config.prompt
        );
        
        this.sessionManager.updateSessionUsage(config.sessionId);
        
        return response;
      } catch (error) {
        this.logger.error('Command execution failed', {
          processId,
          sessionId: config.sessionId,
          error
        });
        throw error;
      }
    });
  }

  async *executeStreaming(config: IExecutionConfig): AsyncIterable<IStreamMessage> {
    this.validateNotShuttingDown();
    await this.rateLimiter.checkLimit();
    
    if (!this.sessionManager.hasSession(config.sessionId)) {
      throw new Error(`Session ${config.sessionId} not found`);
    }
    
    const args = this.buildArgsForExecution({
      ...config,
      outputFormat: 'stream-json'
    });
    const spawnOptions = this.buildSpawnOptions(config);
    const processId = `stream_${Date.now()}_${Math.random()}`;
    
    const claude = spawn('claude', args, spawnOptions);
    this.activeProcesses.set(processId, claude);
    
    try {
      yield* this.streamOutput(claude, processId);
    } finally {
      this.activeProcesses.delete(processId);
      this.cleanupProcess(claude);
    }
  }

  async endSession(sessionId: string): Promise<void> {
    this.logger.debug('Ending session', { sessionId });
    this.sessionManager.removeSession(sessionId);
    this.emit('sessionEnded', { sessionId });
  }

  getActiveSessionCount(): number {
    return this.sessionManager.getActiveCount();
  }

  hasSession(sessionId: string): boolean {
    return this.sessionManager.hasSession(sessionId);
  }

  async shutdown(): Promise<void> {
    this.logger.info('Shutting down CLI Process Manager');
    this.shuttingDown = true;
    
    this.circuitBreaker.open();
    
    // Kill all active processes
    const killPromises = Array.from(this.activeProcesses.entries()).map(
      ([id, process]) => this.killProcess(id, process)
    );
    
    await Promise.all(killPromises);
    
    this.sessionManager.clearAll();
    this.removeAllListeners();
    
    this.logger.info('CLI Process Manager shutdown complete');
  }

  private buildArgs(config: ISessionConfig): string[] {
    const args: string[] = ['-p', config.prompt];
    
    if (config.systemPrompt) {
      args.push('--system-prompt', config.systemPrompt);
    }
    
    if (config.appendSystemPrompt) {
      args.push('--append-system-prompt', config.appendSystemPrompt);
    }
    
    args.push('--output-format', config.outputFormat);
    
    if (config.maxTurns) {
      args.push('--max-turns', String(config.maxTurns));
    }
    
    if (config.maxTokens) {
      args.push('--max-tokens', String(config.maxTokens));
    }
    
    if (config.temperature !== undefined) {
      args.push('--temperature', String(config.temperature));
    }
    
    if (config.allowedTools?.length) {
      config.allowedTools.forEach(tool => {
        args.push('--allowedTools', tool);
      });
    }
    
    if (config.disallowedTools?.length) {
      config.disallowedTools.forEach(tool => {
        args.push('--disallowedTools', tool);
      });
    }
    
    if (config.skipPermissions) {
      args.push('--dangerously-skip-permissions');
    }
    
    return args;
  }

  private buildArgsForExecution(config: IExecutionConfig): string[] {
    const args = this.buildArgs(config);
    
    if (config.resume) {
      const promptIndex = args.indexOf('-p');
      if (promptIndex !== -1) {
        args.splice(promptIndex, 2);
        args.unshift('--resume', config.sessionId);
        args.push('-p', config.prompt);
      }
    } else {
      const promptIndex = args.indexOf('-p');
      if (promptIndex !== -1) {
        args.splice(promptIndex, 0, '--continue');
      }
    }
    
    return args;
  }

  private buildSpawnOptions(config: ISessionConfig | IExecutionConfig): SpawnOptions {
    return {
      cwd: config.workingDirectory || process.cwd(),
      env: {
        ...process.env,
        ...config.env,
        NO_COLOR: '1',
        CLAUDE_NO_COLOR: '1',
        NODE_OPTIONS: `--max-old-space-size=${this.options.memoryLimit}`
      },
      stdio: ['pipe', 'pipe', 'pipe']
    };
  }

  private async executeCommand(
    processId: string,
    args: string[],
    spawnOptions: SpawnOptions,
    prompt?: string
  ): Promise<IClaudeSDKResponse> {
    return this.processQueue.enqueue(async () => {
      return new Promise((resolve, reject) => {
        const claude = spawn('claude', args, spawnOptions);
        this.activeProcesses.set(processId, claude);
        
        let stdout = '';
        let stderr = '';
        let timeout: NodeJS.Timeout | undefined;
        
        if (this.options.processTimeout) {
          timeout = setTimeout(() => {
            this.logger.warn('Process timeout reached', { processId });
            claude.kill('SIGTERM');
            reject(new Error('Process timeout'));
          }, this.options.processTimeout);
        }
        
        claude.stdout?.on('data', (data) => {
          stdout += data.toString();
        });
        
        claude.stderr?.on('data', (data) => {
          stderr += data.toString();
          this.logger.debug('Claude stderr', { processId, data: data.toString() });
        });
        
        claude.on('close', (code) => {
          if (timeout) clearTimeout(timeout);
          this.activeProcesses.delete(processId);
          
          if (code === 0) {
            try {
              const response = JSON.parse(stdout) as IClaudeSDKResponse;
              resolve(response);
            } catch (error) {
              this.logger.error('Failed to parse Claude output', { 
                processId, 
                stdout: stdout.substring(0, 1000),
                stderr 
              });
              reject(new Error(`Failed to parse JSON: ${error.message}`));
            }
          } else {
            reject(new Error(`Claude exited with code ${code}: ${stderr}`));
          }
        });
        
        claude.on('error', (error) => {
          if (timeout) clearTimeout(timeout);
          this.activeProcesses.delete(processId);
          reject(error);
        });
      });
    });
  }

  private async *streamOutput(
    claude: ChildProcess,
    processId: string
  ): AsyncIterable<IStreamMessage> {
    let buffer = '';
    
    const processChunk = (chunk: Buffer): IStreamMessage[] => {
      buffer += chunk.toString();
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      const messages: IStreamMessage[] = [];
      
      for (const line of lines) {
        if (line.trim()) {
          try {
            const message = JSON.parse(line) as IStreamMessage;
            messages.push(message);
          } catch (error) {
            this.logger.warn('Failed to parse stream message', { 
              processId, 
              line, 
              error 
            });
          }
        }
      }
      
      return messages;
    };
    
    // Create async iterator from stdout
    const stdoutIterator = claude.stdout![Symbol.asyncIterator]();
    
    try {
      for await (const chunk of stdoutIterator) {
        const messages = processChunk(chunk);
        for (const message of messages) {
          yield message;
          
          if (message.type === 'result') {
            return;
          }
        }
      }
      
      // Process any remaining buffer
      if (buffer.trim()) {
        try {
          const message = JSON.parse(buffer) as IStreamMessage;
          yield message;
        } catch (error) {
          this.logger.warn('Failed to parse final stream message', { 
            processId, 
            buffer, 
            error 
          });
        }
      }
    } catch (error) {
      this.logger.error('Stream processing error', { processId, error });
      throw error;
    }
  }

  private cleanupProcess(process: ChildProcess): void {
    try {
      process.stdout?.removeAllListeners();
      process.stderr?.removeAllListeners();
      process.removeAllListeners();
      
      if (process.exitCode === null && !process.killed) {
        process.kill('SIGTERM');
      }
    } catch (error) {
      this.logger.warn('Error during process cleanup', { error });
    }
  }

  private async killProcess(id: string, process: ChildProcess): Promise<void> {
    this.logger.debug('Killing process', { id, pid: process.pid });
    
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        if (!process.killed) {
          process.kill('SIGKILL');
        }
        resolve();
      }, 5000);
      
      process.once('exit', () => {
        clearTimeout(timeout);
        resolve();
      });
      
      if (!process.killed) {
        process.kill('SIGTERM');
      } else {
        clearTimeout(timeout);
        resolve();
      }
    });
  }

  private validateNotShuttingDown(): void {
    if (this.shuttingDown) {
      throw new Error('CLI Process Manager is shutting down');
    }
  }

  private setupEventHandlers(): void {
    // Monitor process health
    setInterval(() => {
      if (!this.shuttingDown) {
        const stats = {
          activeProcesses: this.activeProcesses.size,
          activeSessions: this.sessionManager.getActiveCount(),
          circuitBreakerState: this.circuitBreaker.getState(),
          rateLimiterRemaining: this.rateLimiter.getRemaining(),
          queueDepth: this.processQueue.getQueueDepth()
        };
        
        this.logger.debug('Process manager stats', stats);
        this.emit('stats', stats);
      }
    }, 30000);
  }
}
```

### 3.3 Supporting Components

```typescript
// src/cli/session-manager.ts
export class SessionManager {
  private sessions = new Map<string, ISessionInfo>();
  private cleanupInterval: NodeJS.Timeout;

  constructor(
    private logger: ILogger,
    private options: { timeout: number }
  ) {
    this.cleanupInterval = setInterval(() => this.cleanup(), 60000);
  }

  registerSession(sessionId: string, info: ISessionInfo): void {
    this.sessions.set(sessionId, info);
    this.logger.debug('Session registered', { sessionId });
  }

  hasSession(sessionId: string): boolean {
    return this.sessions.has(sessionId);
  }

  getSession(sessionId: string): ISessionInfo | undefined {
    return this.sessions.get(sessionId);
  }

  updateSessionUsage(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastUsed = new Date();
    }
  }

  removeSession(sessionId: string): void {
    this.sessions.delete(sessionId);
    this.logger.debug('Session removed', { sessionId });
  }

  getActiveCount(): number {
    return this.sessions.size;
  }

  clearAll(): void {
    clearInterval(this.cleanupInterval);
    this.sessions.clear();
  }

  private cleanup(): void {
    const now = Date.now();
    const expired: string[] = [];
    
    for (const [sessionId, info] of this.sessions.entries()) {
      if (now - info.lastUsed.getTime() > this.options.timeout) {
        expired.push(sessionId);
      }
    }
    
    for (const sessionId of expired) {
      this.removeSession(sessionId);
      this.logger.info('Session expired', { sessionId });
    }
  }
}

// src/cli/circuit-breaker.ts
export class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';

  constructor(
    private options: {
      failureThreshold: number;
      resetTimeout: number;
      logger: ILogger;
    }
  ) {}

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > this.options.resetTimeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  getState(): string {
    return this.state;
  }

  open(): void {
    this.state = 'open';
    this.options.logger.warn('Circuit breaker opened');
  }

  private onSuccess(): void {
    this.failures = 0;
    if (this.state === 'half-open') {
      this.state = 'closed';
      this.options.logger.info('Circuit breaker closed');
    }
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.options.failureThreshold) {
      this.open();
    }
  }
}

// src/cli/rate-limiter.ts
export class RateLimiter {
  private requests: number[] = [];

  constructor(
    private options: {
      maxRequests: number;
      windowMs: number;
    }
  ) {}

  async checkLimit(): Promise<void> {
    const now = Date.now();
    const windowStart = now - this.options.windowMs;
    
    this.requests = this.requests.filter(time => time > windowStart);
    
    if (this.requests.length >= this.options.maxRequests) {
      throw new Error('Rate limit exceeded');
    }
    
    this.requests.push(now);
  }

  getRemaining(): number {
    const now = Date.now();
    const windowStart = now - this.options.windowMs;
    const activeRequests = this.requests.filter(time => time > windowStart);
    return Math.max(0, this.options.maxRequests - activeRequests.length);
  }
}

// src/cli/process-queue.ts
export class ProcessQueue {
  private queue: Array<() => Promise<any>> = [];
  private running = 0;

  constructor(
    private options: {
      maxConcurrent: number;
      logger: ILogger;
    }
  ) {}

  async enqueue<T>(fn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await fn();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.processNext();
    });
  }

  getQueueDepth(): number {
    return this.queue.length;
  }

  private async processNext(): Promise<void> {
    if (this.running >= this.options.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const task = this.queue.shift()!;
    
    try {
      await task();
    } finally {
      this.running--;
      this.processNext();
    }
  }
}
```

## Integration Tests

### 3.4 Integration Tests

```typescript
// src/cli/__tests__/cli-process-manager.integration.spec.ts
import { CLIProcessManager } from '../cli-process-manager';
import { createLogger } from '@/utils/logger';

describe('CLIProcessManager Integration', () => {
  let manager: CLIProcessManager;
  let logger: ILogger;

  beforeAll(() => {
    if (!process.env.CLAUDE_INTEGRATION_TEST) {
      console.log('Skipping integration tests. Set CLAUDE_INTEGRATION_TEST=true to run.');
      return;
    }
  });

  beforeEach(() => {
    logger = createLogger({ level: 'debug' });
    manager = new CLIProcessManager(logger);
  });

  afterEach(async () => {
    await manager.shutdown();
  });

  it('should create real session with Claude CLI', async () => {
    const response = await manager.createSession({
      prompt: 'Say exactly "INTEGRATION_TEST_SUCCESS"',
      outputFormat: 'json',
      maxTurns: 1
    });

    expect(response).toBeValidClaudeResponse();
    expect(response.result).toContain('INTEGRATION_TEST_SUCCESS');
    expect(response.session_id).toBeDefined();
  });

  it('should maintain session context', async () => {
    // Create session
    const session = await manager.createSession({
      prompt: 'Remember the number 12345',
      outputFormat: 'json'
    });

    // Continue session
    const response = await manager.execute({
      sessionId: session.session_id,
      prompt: 'What number did I ask you to remember?',
      outputFormat: 'json'
    });

    expect(response.result).toContain('12345');
  });

  it('should handle concurrent sessions', async () => {
    const promises = [];
    
    for (let i = 0; i < 3; i++) {
      promises.push(manager.createSession({
        prompt: `You are Agent ${i}. What is your agent number?`,
        outputFormat: 'json',
        systemPrompt: `You are Agent ${i}`
      }));
    }

    const responses = await Promise.all(promises);
    
    responses.forEach((response, i) => {
      expect(response.result).toContain(String(i));
    });
  });
});
```

## Success Criteria
- ✅ 100% test coverage
- ✅ All unit tests passing
- ✅ Integration tests passing (when enabled)
- ✅ Session management working
- ✅ Error handling robust
- ✅ Resource management implemented
- ✅ Performance within targets

## Next Steps
- Proceed to Step 4: Base Agent Implementation
- Use CLI Process Manager for all Claude interactions
- Maintain test coverage at 100%