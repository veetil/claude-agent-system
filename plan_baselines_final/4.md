# Step 4: Terminal Pool and Workspace Isolation

## Objective
Implement terminal pool management and workspace isolation to ensure multiple agents can work concurrently without conflicts. Each agent gets its own isolated terminal session and working directory.

## Prerequisites
- Step 3 CLI Process Manager complete
- Understanding of process isolation
- Git worktree knowledge

## Test-First Implementation

### 4.1 Terminal Pool Tests

```typescript
// src/terminal/__tests__/terminal-pool.spec.ts
import { TerminalPool } from '../terminal-pool';
import { VirtualTerminal } from '../virtual-terminal';
import { MockFactory } from '@test/mocks/MockFactory';
import { TestHelpers } from '@test/utils/TestHelpers';
import * as fs from 'fs/promises';
import * as path from 'path';

jest.mock('fs/promises');
jest.mock('child_process');

describe('TerminalPool', () => {
  let pool: TerminalPool;
  let mockLogger: jest.Mocked<ILogger>;
  let mockFs: jest.Mocked<typeof fs>;

  beforeEach(() => {
    mockLogger = MockFactory.createMockLogger();
    mockFs = fs as jest.Mocked<typeof fs>;
    mockFs.mkdir.mockResolvedValue(undefined);
    mockFs.rm.mockResolvedValue(undefined);
    
    pool = new TerminalPool(mockLogger, {
      maxTerminals: 3,
      maxIdleTime: 1000,
      baseWorkDir: '/tmp/claude-agents'
    });
  });

  afterEach(async () => {
    await pool.shutdown();
  });

  describe('allocation', () => {
    it('should allocate unique terminal per agent', async () => {
      // Act
      const terminal1 = await pool.allocate('agent-1');
      const terminal2 = await pool.allocate('agent-2');

      // Assert
      expect(terminal1.id).not.toBe(terminal2.id);
      expect(terminal1.agentId).toBe('agent-1');
      expect(terminal2.agentId).toBe('agent-2');
      expect(terminal1.workingDirectory).toContain('agent-1');
      expect(terminal2.workingDirectory).toContain('agent-2');
      expect(pool.getActiveCount()).toBe(2);
    });

    it('should reuse terminal for same agent', async () => {
      // Act
      const terminal1 = await pool.allocate('agent-1');
      const terminal2 = await pool.allocate('agent-1');

      // Assert
      expect(terminal1.id).toBe(terminal2.id);
      expect(pool.getActiveCount()).toBe(1);
    });

    it('should create isolated working directory', async () => {
      // Act
      const terminal = await pool.allocate('test-agent');

      // Assert
      expect(mockFs.mkdir).toHaveBeenCalledWith(
        expect.stringContaining('test-agent'),
        { recursive: true }
      );
      expect(terminal.workingDirectory).toMatch(/\/tmp\/claude-agents\/test-agent\/term_/);
    });

    it('should set isolated environment variables', async () => {
      // Act
      const terminal = await pool.allocate('test-agent');

      // Assert
      expect(terminal.env).toMatchObject({
        CLAUDE_AGENT_ID: 'test-agent',
        CLAUDE_TERMINAL_ID: terminal.id,
        HOME: terminal.workingDirectory,
        PWD: terminal.workingDirectory
      });
    });

    it('should enforce maximum terminals limit', async () => {
      // Arrange - allocate max terminals
      await pool.allocate('agent-1');
      await pool.allocate('agent-2');
      const terminal3 = await pool.allocate('agent-3');
      
      // Update last used time for terminal 3
      terminal3.lastUsed = new Date();

      // Act - try to allocate one more
      await pool.allocate('agent-4');

      // Assert - LRU (agent-1) should be evicted
      expect(pool.getTerminalForAgent('agent-1')).toBeUndefined();
      expect(pool.getActiveCount()).toBe(3);
    });
  });

  describe('release', () => {
    it('should release terminal and clean up', async () => {
      // Arrange
      const terminal = await pool.allocate('test-agent');
      const terminalId = terminal.id;

      // Act
      await pool.release('test-agent');

      // Assert
      expect(pool.getTerminalForAgent('test-agent')).toBeUndefined();
      expect(pool.getActiveCount()).toBe(0);
      expect(mockFs.rm).toHaveBeenCalledWith(
        terminal.workingDirectory,
        { recursive: true, force: true }
      );
    });

    it('should handle release of non-existent agent', async () => {
      // Act & Assert - should not throw
      await expect(pool.release('non-existent')).resolves.not.toThrow();
    });
  });

  describe('idle cleanup', () => {
    it('should clean up idle terminals', async () => {
      jest.useFakeTimers();
      
      // Arrange
      const terminal = await pool.allocate('idle-agent');
      expect(pool.getActiveCount()).toBe(1);

      // Act - advance time past idle timeout
      jest.advanceTimersByTime(2000);
      
      // Give cleanup timer a chance to run
      await TestHelpers.waitFor(() => pool.getActiveCount() === 0, 100);

      // Assert
      expect(pool.getActiveCount()).toBe(0);
      expect(mockLogger.info).toHaveBeenCalledWith(
        'Evicted idle terminal',
        expect.objectContaining({ agentId: 'idle-agent' })
      );
      
      jest.useRealTimers();
    });

    it('should not evict recently used terminals', async () => {
      jest.useFakeTimers();
      
      // Arrange
      const terminal = await pool.allocate('active-agent');
      
      // Act - use terminal and advance time
      terminal.lastUsed = new Date();
      jest.advanceTimersByTime(500);
      
      // Assert
      expect(pool.getActiveCount()).toBe(1);
      
      jest.useRealTimers();
    });
  });

  describe('shutdown', () => {
    it('should clean up all terminals on shutdown', async () => {
      // Arrange
      await pool.allocate('agent-1');
      await pool.allocate('agent-2');
      expect(pool.getActiveCount()).toBe(2);

      // Act
      await pool.shutdown();

      // Assert
      expect(pool.getActiveCount()).toBe(0);
      expect(mockFs.rm).toHaveBeenCalledTimes(2);
    });
  });
});
```

### 4.2 Virtual Terminal Tests

```typescript
// src/terminal/__tests__/virtual-terminal.spec.ts
import { VirtualTerminal } from '../virtual-terminal';
import { spawn } from 'child_process';
import { MockFactory } from '@test/mocks/MockFactory';
import { TestHelpers } from '@test/utils/TestHelpers';

jest.mock('child_process');
jest.mock('fs/promises');

describe('VirtualTerminal', () => {
  let terminal: VirtualTerminal;
  let mockSpawn: jest.MockedFunction<typeof spawn>;
  let mockProcess: ReturnType<typeof MockFactory.createMockChildProcess>;

  beforeEach(() => {
    mockSpawn = spawn as jest.MockedFunction<typeof spawn>;
    mockProcess = MockFactory.createMockChildProcess();
    mockSpawn.mockReturnValue(mockProcess as any);
  });

  afterEach(async () => {
    if (terminal && !terminal.isDestroyed()) {
      await terminal.destroy();
    }
  });

  describe('initialization', () => {
    it('should create terminal with isolated environment', async () => {
      // Act
      terminal = new VirtualTerminal('test-agent', {
        baseWorkDir: '/tmp/test'
      });
      await terminal.initialize();

      // Assert
      expect(terminal.agentId).toBe('test-agent');
      expect(terminal.workingDirectory).toMatch(/\/tmp\/test\/test-agent/);
      expect(terminal.env.CLAUDE_AGENT_ID).toBe('test-agent');
      expect(mockSpawn).toHaveBeenCalledWith(
        expect.any(String), // shell
        ['-i'],
        expect.objectContaining({
          cwd: terminal.workingDirectory,
          env: expect.objectContaining({
            CLAUDE_AGENT_ID: 'test-agent'
          })
        })
      );
    });

    it('should wait for shell to be ready', async () => {
      // Arrange
      terminal = new VirtualTerminal('test-agent', {});
      
      // Mock ready check
      let executeCallCount = 0;
      terminal.execute = jest.fn().mockImplementation(async () => {
        executeCallCount++;
        if (executeCallCount === 1) {
          return { output: 'READY', exitCode: 0 };
        }
        return terminal.execute.mock.results[0].value;
      });

      // Act
      await terminal.initialize();

      // Assert
      expect(terminal.execute).toHaveBeenCalledWith('echo "READY"');
    });
  });

  describe('command execution', () => {
    beforeEach(async () => {
      terminal = new VirtualTerminal('test-agent', {});
      
      // Mock initialization
      terminal.execute = jest.fn().mockResolvedValueOnce({
        output: 'READY',
        exitCode: 0
      });
      
      await terminal.initialize();
      
      // Restore execute for actual tests
      terminal.execute = VirtualTerminal.prototype.execute.bind(terminal);
    });

    it('should execute commands and return results', async () => {
      // Arrange
      const commandPromise = terminal.execute('echo "Hello World"');
      
      // Simulate command execution
      await TestHelpers.waitFor(() => mockProcess.stdin.write.mock.calls.length > 0);
      
      const writtenCommand = mockProcess.stdin.write.mock.calls[0][0];
      expect(writtenCommand).toContain('echo "Hello World"');
      
      // Extract delimiter from command
      const delimiterMatch = writtenCommand.match(/CLAUDE_CMD_([^>]+)>>>/);
      const delimiter = `<<<CLAUDE_CMD_${delimiterMatch[1]}>>>`;
      
      // Simulate output
      mockProcess.stdout.emit('data', Buffer.from(`${delimiter}_START\n`));
      mockProcess.stdout.emit('data', Buffer.from('Hello World\n'));
      mockProcess.stdout.emit('data', Buffer.from(`${delimiter}_END:0\n`));

      // Act
      const result = await commandPromise;

      // Assert
      expect(result).toMatchObject({
        command: 'echo "Hello World"',
        output: expect.stringContaining('Hello World'),
        exitCode: 0,
        duration: expect.any(Number)
      });
    });

    it('should handle command errors', async () => {
      // Arrange
      const commandPromise = terminal.execute('false');
      
      await TestHelpers.waitFor(() => mockProcess.stdin.write.mock.calls.length > 0);
      
      const writtenCommand = mockProcess.stdin.write.mock.calls[0][0];
      const delimiterMatch = writtenCommand.match(/CLAUDE_CMD_([^>]+)>>>/);
      const delimiter = `<<<CLAUDE_CMD_${delimiterMatch[1]}>>>`;
      
      // Simulate error
      mockProcess.stdout.emit('data', Buffer.from(`${delimiter}_START\n`));
      mockProcess.stderr.emit('data', Buffer.from('Command failed\n'));
      mockProcess.stdout.emit('data', Buffer.from(`${delimiter}_END:1\n`));

      // Act
      const result = await commandPromise;

      // Assert
      expect(result.exitCode).toBe(1);
      expect(result.error).toContain('Command failed');
    });

    it('should queue multiple commands', async () => {
      // Arrange
      const commands = [
        terminal.execute('echo "1"'),
        terminal.execute('echo "2"'),
        terminal.execute('echo "3"')
      ];

      // Process each command
      for (let i = 0; i < 3; i++) {
        await TestHelpers.waitFor(() => 
          mockProcess.stdin.write.mock.calls.length > i
        );
        
        const writtenCommand = mockProcess.stdin.write.mock.calls[i][0];
        const delimiterMatch = writtenCommand.match(/CLAUDE_CMD_([^>]+)>>>/);
        const delimiter = `<<<CLAUDE_CMD_${delimiterMatch[1]}>>>`;
        
        mockProcess.stdout.emit('data', Buffer.from(`${delimiter}_START\n`));
        mockProcess.stdout.emit('data', Buffer.from(`${i + 1}\n`));
        mockProcess.stdout.emit('data', Buffer.from(`${delimiter}_END:0\n`));
      }

      // Act
      const results = await Promise.all(commands);

      // Assert
      expect(results[0].output).toContain('1');
      expect(results[1].output).toContain('2');
      expect(results[2].output).toContain('3');
    });
  });

  describe('output management', () => {
    beforeEach(async () => {
      terminal = new VirtualTerminal('test-agent', {});
      terminal.execute = jest.fn().mockResolvedValueOnce({
        output: 'READY',
        exitCode: 0
      });
      await terminal.initialize();
      terminal.execute = VirtualTerminal.prototype.execute.bind(terminal);
    });

    it('should capture output history', () => {
      // Arrange
      mockProcess.stdout.emit('data', Buffer.from('Line 1\nLine 2\n'));
      mockProcess.stdout.emit('data', Buffer.from('Line 3\n'));
      mockProcess.stderr.emit('data', Buffer.from('Error line\n'));

      // Act
      const output = terminal.getOutput();

      // Assert
      expect(output).toEqual([
        'Line 1',
        'Line 2',
        'Line 3',
        '[ERROR] Error line'
      ]);
    });

    it('should limit output buffer size', () => {
      // Arrange - add many lines
      for (let i = 0; i < 11000; i++) {
        mockProcess.stdout.emit('data', Buffer.from(`Line ${i}\n`));
      }

      // Act
      const output = terminal.getOutput();

      // Assert
      expect(output.length).toBeLessThanOrEqual(5000);
      expect(output[0]).toMatch(/Line \d{4,}/); // Should start from later lines
    });

    it('should clear output', () => {
      // Arrange
      mockProcess.stdout.emit('data', Buffer.from('Some output\n'));
      expect(terminal.getOutput().length).toBeGreaterThan(0);

      // Act
      terminal.clear();

      // Assert
      expect(terminal.getOutput()).toEqual([]);
    });
  });

  describe('cleanup', () => {
    it('should destroy terminal and clean up resources', async () => {
      // Arrange
      terminal = new VirtualTerminal('test-agent', {});
      await terminal.initialize();

      // Act
      await terminal.destroy();

      // Assert
      expect(mockProcess.kill).toHaveBeenCalledWith('SIGTERM');
      expect(terminal.isDestroyed()).toBe(true);
      
      // Should reject new commands
      await expect(terminal.execute('test')).rejects.toThrow(
        'Terminal has been destroyed'
      );
    });

    it('should force kill if process does not terminate', async () => {
      jest.useFakeTimers();
      
      // Arrange
      terminal = new VirtualTerminal('test-agent', {});
      await terminal.initialize();
      
      // Make process not respond to SIGTERM
      mockProcess.killed = false;

      // Act
      const destroyPromise = terminal.destroy();
      
      // Advance time past force kill timeout
      jest.advanceTimersByTime(6000);
      
      await destroyPromise;

      // Assert
      expect(mockProcess.kill).toHaveBeenCalledWith('SIGTERM');
      expect(mockProcess.kill).toHaveBeenCalledWith('SIGKILL');
      
      jest.useRealTimers();
    });
  });
});
```

### 4.3 Terminal Pool Implementation

```typescript
// src/terminal/terminal-pool.ts
import { VirtualTerminal } from './virtual-terminal';
import { ILogger, ITerminalSession, ITerminalPoolConfig } from '@/types';

export class TerminalPool {
  private terminals = new Map<string, VirtualTerminal>();
  private agentToTerminal = new Map<string, string>();
  private cleanupInterval: NodeJS.Timeout;
  private shuttingDown = false;

  constructor(
    private logger: ILogger,
    private config: ITerminalPoolConfig
  ) {
    this.config = {
      maxTerminals: config.maxTerminals || 50,
      maxIdleTime: config.maxIdleTime || 30 * 60 * 1000,
      baseWorkDir: config.baseWorkDir || '/tmp/claude-agents',
      ...config
    };
    
    this.startCleanupTimer();
  }

  async allocate(agentId: string): Promise<ITerminalSession> {
    // Check if agent already has a terminal
    const existingTerminalId = this.agentToTerminal.get(agentId);
    if (existingTerminalId) {
      const terminal = this.terminals.get(existingTerminalId);
      if (terminal && !terminal.isDestroyed()) {
        terminal.updateLastUsed();
        this.logger.debug('Reusing existing terminal', {
          agentId,
          terminalId: terminal.id
        });
        return terminal;
      }
    }

    // Check capacity
    if (this.terminals.size >= this.config.maxTerminals) {
      await this.evictLeastRecentlyUsed();
    }

    // Create new terminal
    const terminal = new VirtualTerminal(agentId, {
      baseWorkDir: this.config.baseWorkDir,
      env: {
        NODE_ENV: 'agent',
        CLAUDE_EXECUTION_MODE: 'isolated',
        ...this.config.env
      }
    });

    try {
      await terminal.initialize();
      
      this.terminals.set(terminal.id, terminal);
      this.agentToTerminal.set(agentId, terminal.id);

      this.logger.info('Allocated terminal for agent', {
        agentId,
        terminalId: terminal.id,
        workingDirectory: terminal.workingDirectory,
        activeTerminals: this.terminals.size
      });

      return terminal;
    } catch (error) {
      // Clean up on initialization failure
      await terminal.destroy().catch(() => {});
      throw error;
    }
  }

  async release(agentId: string): Promise<void> {
    const terminalId = this.agentToTerminal.get(agentId);
    if (!terminalId) {
      this.logger.debug('No terminal to release', { agentId });
      return;
    }

    const terminal = this.terminals.get(terminalId);
    if (terminal) {
      try {
        await terminal.destroy();
      } catch (error) {
        this.logger.error('Error destroying terminal', { 
          agentId, 
          terminalId, 
          error 
        });
      }
      
      this.terminals.delete(terminalId);
    }

    this.agentToTerminal.delete(agentId);

    this.logger.info('Released terminal', {
      agentId,
      terminalId,
      remainingTerminals: this.terminals.size
    });
  }

  getActiveCount(): number {
    return this.terminals.size;
  }

  getTerminalForAgent(agentId: string): ITerminalSession | undefined {
    const terminalId = this.agentToTerminal.get(agentId);
    return terminalId ? this.terminals.get(terminalId) : undefined;
  }

  async shutdown(): Promise<void> {
    this.shuttingDown = true;
    
    this.logger.info('Shutting down terminal pool', {
      activeTerminals: this.terminals.size
    });

    clearInterval(this.cleanupInterval);

    // Destroy all terminals in parallel
    const destroyPromises = Array.from(this.terminals.values()).map(
      terminal => terminal.destroy().catch(error => {
        this.logger.error('Error destroying terminal during shutdown', {
          terminalId: terminal.id,
          error
        });
      })
    );

    await Promise.all(destroyPromises);

    this.terminals.clear();
    this.agentToTerminal.clear();
    
    this.logger.info('Terminal pool shutdown complete');
  }

  private async evictLeastRecentlyUsed(): Promise<void> {
    let oldestTerminal: VirtualTerminal | undefined;
    let oldestTime = Date.now();
    let oldestAgentId: string | undefined;

    for (const [agentId, terminalId] of this.agentToTerminal.entries()) {
      const terminal = this.terminals.get(terminalId);
      if (terminal && terminal.lastUsed.getTime() < oldestTime) {
        oldestTime = terminal.lastUsed.getTime();
        oldestTerminal = terminal;
        oldestAgentId = agentId;
      }
    }

    if (oldestAgentId) {
      this.logger.info('Evicting LRU terminal', {
        agentId: oldestAgentId,
        lastUsed: new Date(oldestTime)
      });
      await this.release(oldestAgentId);
    }
  }

  private startCleanupTimer(): void {
    this.cleanupInterval = setInterval(async () => {
      if (this.shuttingDown) return;
      
      const now = Date.now();
      const toRemove: string[] = [];

      for (const [terminalId, terminal] of this.terminals.entries()) {
        if (now - terminal.lastUsed.getTime() > this.config.maxIdleTime) {
          // Find agent ID for this terminal
          for (const [agentId, tId] of this.agentToTerminal.entries()) {
            if (tId === terminalId) {
              toRemove.push(agentId);
              break;
            }
          }
        }
      }

      for (const agentId of toRemove) {
        await this.release(agentId);
        this.logger.info('Evicted idle terminal', { agentId });
      }
    }, 60000); // Check every minute
  }
}
```

### 4.4 Virtual Terminal Implementation

```typescript
// src/terminal/virtual-terminal.ts
import { spawn, ChildProcess } from 'child_process';
import { v4 as uuidv4 } from 'uuid';
import * as path from 'path';
import * as fs from 'fs/promises';
import { ITerminalSession, ICommandResult } from '@/types';

interface ITerminalConfig {
  baseWorkDir?: string;
  env?: Record<string, string>;
}

interface IQueuedCommand {
  id: string;
  command: string;
  resolve: (result: ICommandResult) => void;
  reject: (error: Error) => void;
  startTime: number;
}

export class VirtualTerminal implements ITerminalSession {
  public readonly id: string;
  public readonly agentId: string;
  public readonly workingDirectory: string;
  public readonly env: Record<string, string>;
  public readonly createdAt: Date;
  public lastUsed: Date;

  private shell?: ChildProcess;
  private outputBuffer: string[] = [];
  private commandQueue: IQueuedCommand[] = [];
  private isProcessing = false;
  private destroyed = false;
  private maxOutputLines = 5000;

  constructor(agentId: string, config: ITerminalConfig) {
    this.id = `term_${uuidv4()}`;
    this.agentId = agentId;
    this.createdAt = new Date();
    this.lastUsed = new Date();
    
    // Create isolated working directory
    this.workingDirectory = path.join(
      config.baseWorkDir || '/tmp/claude-agents',
      agentId,
      this.id
    );
    
    // Isolated environment
    this.env = {
      ...process.env,
      ...config.env,
      CLAUDE_AGENT_ID: agentId,
      CLAUDE_TERMINAL_ID: this.id,
      HOME: this.workingDirectory,
      PWD: this.workingDirectory,
      // Disable interactive features
      TERM: 'dumb',
      NO_COLOR: '1'
    };
  }

  async initialize(): Promise<void> {
    // Create working directory
    await fs.mkdir(this.workingDirectory, { recursive: true });
    
    // Initialize shell process
    this.shell = spawn(this.getShell(), ['-i'], {
      cwd: this.workingDirectory,
      env: this.env,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    this.setupOutputCapture();
    this.setupErrorHandling();
    
    // Wait for shell to be ready
    await this.waitForReady();
  }

  async execute(command: string): Promise<ICommandResult> {
    if (this.destroyed) {
      throw new Error('Terminal has been destroyed');
    }

    this.updateLastUsed();

    return new Promise((resolve, reject) => {
      const queuedCommand: IQueuedCommand = {
        id: uuidv4(),
        command,
        resolve,
        reject,
        startTime: Date.now()
      };

      this.commandQueue.push(queuedCommand);
      this.processQueue();
    });
  }

  getOutput(): string[] {
    return [...this.outputBuffer];
  }

  clear(): void {
    this.outputBuffer = [];
  }

  isDestroyed(): boolean {
    return this.destroyed;
  }

  updateLastUsed(): void {
    this.lastUsed = new Date();
  }

  async destroy(): Promise<void> {
    if (this.destroyed) return;
    
    this.destroyed = true;
    
    // Reject all pending commands
    for (const cmd of this.commandQueue) {
      cmd.reject(new Error('Terminal destroyed'));
    }
    this.commandQueue = [];
    
    // Kill shell process
    if (this.shell) {
      this.shell.removeAllListeners();
      this.shell.stdout?.removeAllListeners();
      this.shell.stderr?.removeAllListeners();
      
      this.shell.kill('SIGTERM');
      
      // Force kill after timeout
      const forceKillTimeout = setTimeout(() => {
        if (this.shell && !this.shell.killed) {
          this.shell.kill('SIGKILL');
        }
      }, 5000);
      
      // Wait for process to exit
      await new Promise<void>((resolve) => {
        if (!this.shell || this.shell.killed) {
          clearTimeout(forceKillTimeout);
          resolve();
        } else {
          this.shell.once('exit', () => {
            clearTimeout(forceKillTimeout);
            resolve();
          });
        }
      });
    }

    // Clean up working directory
    try {
      await fs.rm(this.workingDirectory, { recursive: true, force: true });
    } catch (error) {
      console.error('Failed to clean up working directory:', error);
    }
  }

  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.commandQueue.length === 0 || this.destroyed) {
      return;
    }

    this.isProcessing = true;
    const command = this.commandQueue.shift()!;

    try {
      const result = await this.executeCommand(command);
      command.resolve(result);
    } catch (error) {
      command.reject(error);
    } finally {
      this.isProcessing = false;
      // Process next command
      setImmediate(() => this.processQueue());
    }
  }

  private async executeCommand(queuedCommand: IQueuedCommand): Promise<ICommandResult> {
    const { command, id, startTime } = queuedCommand;
    
    // Add command delimiter for parsing
    const delimiter = `<<<CLAUDE_CMD_${id}>>>`;
    const fullCommand = `echo "${delimiter}_START"; ${command}; echo -e "\\n${delimiter}_END:$?"`;

    // Write command to shell
    return new Promise((resolve, reject) => {
      if (!this.shell || this.destroyed) {
        reject(new Error('Shell not available'));
        return;
      }
      
      const timeout = setTimeout(() => {
        reject(new Error('Command timeout'));
      }, 30000); // 30 second timeout per command
      
      // Set up output handler
      const output = this.waitForCommandOutput(delimiter);
      
      output.then(result => {
        clearTimeout(timeout);
        const duration = Date.now() - startTime;
        
        resolve({
          command,
          output: result.stdout.trim(),
          error: result.stderr.trim(),
          exitCode: result.exitCode,
          duration,
          timestamp: new Date()
        });
      }).catch(error => {
        clearTimeout(timeout);
        reject(error);
      });
      
      // Write command
      this.shell.stdin!.write(fullCommand + '\n');
    });
  }

  private async waitForCommandOutput(delimiter: string): Promise<{
    stdout: string;
    stderr: string;
    exitCode: number;
  }> {
    const startMarker = `${delimiter}_START`;
    const endMarker = `${delimiter}_END:`;
    
    let stdout = '';
    let stderr = '';
    let capturing = false;

    return new Promise((resolve, reject) => {
      const outputHandler = (data: Buffer) => {
        const text = data.toString();
        const lines = text.split('\n');
        
        for (const line of lines) {
          if (line.includes(startMarker)) {
            capturing = true;
            continue;
          }
          
          if (line.includes(endMarker)) {
            const exitCode = parseInt(line.split(endMarker)[1]) || 0;
            
            // Clean up handlers
            this.shell!.stdout!.removeListener('data', outputHandler);
            this.shell!.stderr!.removeListener('data', errorHandler);
            
            resolve({ stdout, stderr, exitCode });
            return;
          }
          
          if (capturing && line.trim()) {
            stdout += line + '\n';
          }
        }
      };

      const errorHandler = (data: Buffer) => {
        if (capturing) {
          stderr += data.toString();
        }
      };

      this.shell!.stdout!.on('data', outputHandler);
      this.shell!.stderr!.on('data', errorHandler);
    });
  }

  private setupOutputCapture(): void {
    if (!this.shell) return;
    
    // Capture stdout
    this.shell.stdout!.on('data', (data) => {
      const lines = data.toString().split('\n').filter(line => line.trim());
      this.outputBuffer.push(...lines);
      this.trimOutputBuffer();
    });

    // Capture stderr
    this.shell.stderr!.on('data', (data) => {
      const lines = data.toString().split('\n').filter(line => line.trim());
      this.outputBuffer.push(...lines.map(line => `[ERROR] ${line}`));
      this.trimOutputBuffer();
    });
  }

  private setupErrorHandling(): void {
    if (!this.shell) return;
    
    this.shell.on('error', (error) => {
      console.error('Shell process error:', error);
      this.destroyed = true;
      
      // Reject all pending commands
      for (const cmd of this.commandQueue) {
        cmd.reject(error);
      }
      this.commandQueue = [];
    });
    
    this.shell.on('exit', (code, signal) => {
      if (!this.destroyed) {
        console.warn('Shell process exited unexpectedly', { code, signal });
        this.destroyed = true;
        
        // Reject all pending commands
        for (const cmd of this.commandQueue) {
          cmd.reject(new Error(`Shell exited with code ${code}`));
        }
        this.commandQueue = [];
      }
    });
  }

  private trimOutputBuffer(): void {
    if (this.outputBuffer.length > this.maxOutputLines) {
      // Keep the most recent lines
      this.outputBuffer = this.outputBuffer.slice(-this.maxOutputLines / 2);
    }
  }

  private async waitForReady(): Promise<void> {
    const testResult = await this.execute('echo "READY"');
    
    if (!testResult.output.includes('READY')) {
      throw new Error('Failed to initialize terminal');
    }
  }

  private getShell(): string {
    // Prefer bash, fall back to sh
    return process.env.SHELL?.includes('bash') ? 'bash' : '/bin/bash';
  }
}
```

### 4.5 Integration with CLI Manager

```typescript
// src/cli/terminal-aware-cli-manager.ts
import { CLIProcessManager } from './cli-process-manager';
import { TerminalPool } from '@/terminal/terminal-pool';
import type { ILogger, ISessionConfig, IExecutionConfig, IProcessOptions } from '@/types';

export class TerminalAwareCLIManager extends CLIProcessManager {
  constructor(
    logger: ILogger,
    private terminalPool: TerminalPool,
    options?: IProcessOptions
  ) {
    super(logger, options);
  }

  async createSession(config: ISessionConfig): Promise<IClaudeSDKResponse> {
    // Get or create terminal for the requesting agent
    const agentId = config.metadata?.agentId;
    if (!agentId) {
      throw new Error('Agent ID required for terminal allocation');
    }

    const terminal = await this.terminalPool.allocate(agentId);
    
    // Override working directory with terminal's isolated directory
    const enhancedConfig: ISessionConfig = {
      ...config,
      workingDirectory: terminal.workingDirectory,
      env: {
        ...config.env,
        ...terminal.env
      }
    };

    this.logger.debug('Creating session with terminal context', {
      agentId,
      terminalId: terminal.id,
      workingDirectory: terminal.workingDirectory
    });

    return super.createSession(enhancedConfig);
  }

  async execute(config: IExecutionConfig): Promise<IClaudeSDKResponse> {
    // Ensure terminal context is maintained
    const agentId = config.metadata?.agentId;
    if (agentId) {
      const terminal = this.terminalPool.getTerminalForAgent(agentId);
      if (terminal) {
        config.workingDirectory = terminal.workingDirectory;
        config.env = { ...config.env, ...terminal.env };
      } else {
        this.logger.warn('No terminal found for agent', { agentId });
      }
    }

    return super.execute(config);
  }

  async executeStreaming(config: IExecutionConfig): AsyncIterable<IStreamMessage> {
    // Ensure terminal context for streaming
    const agentId = config.metadata?.agentId;
    if (agentId) {
      const terminal = this.terminalPool.getTerminalForAgent(agentId);
      if (terminal) {
        config.workingDirectory = terminal.workingDirectory;
        config.env = { ...config.env, ...terminal.env };
      }
    }

    return super.executeStreaming(config);
  }

  async shutdown(): Promise<void> {
    // Shutdown both CLI manager and terminal pool
    await Promise.all([
      super.shutdown(),
      this.terminalPool.shutdown()
    ]);
  }
}
```

## Resource Monitoring

### 4.6 Terminal Resource Monitor

```typescript
// src/terminal/resource-monitor.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { execFile } from 'child_process';
import { promisify } from 'util';
import { ITerminalMetrics, ITerminalSession } from '@/types';

const execFileAsync = promisify(execFile);

export class TerminalResourceMonitor {
  private metrics = new Map<string, ITerminalMetrics>();

  async collectMetrics(terminal: ITerminalSession): Promise<ITerminalMetrics> {
    const metrics: ITerminalMetrics = {
      terminalId: terminal.id,
      agentId: terminal.agentId,
      cpuUsage: await this.getCPUUsage(terminal),
      memoryUsage: await this.getMemoryUsage(terminal),
      diskUsage: await this.getDiskUsage(terminal.workingDirectory),
      commandCount: terminal.getOutput().length,
      uptime: Date.now() - terminal.createdAt.getTime()
    };

    this.metrics.set(terminal.id, metrics);
    return metrics;
  }

  async enforceResourceLimits(
    terminal: ITerminalSession,
    limits: {
      maxMemory?: number;
      maxDisk?: number;
      maxCommands?: number;
    }
  ): Promise<void> {
    const metrics = await this.collectMetrics(terminal);
    
    // Check memory limit
    if (limits.maxMemory && metrics.memoryUsage > limits.maxMemory) {
      throw new Error(
        `Terminal ${terminal.id} exceeded memory limit: ${metrics.memoryUsage} > ${limits.maxMemory}`
      );
    }
    
    // Check disk usage
    if (limits.maxDisk && metrics.diskUsage > limits.maxDisk) {
      throw new Error(
        `Terminal ${terminal.id} exceeded disk limit: ${metrics.diskUsage} > ${limits.maxDisk}`
      );
    }
    
    // Check command count
    if (limits.maxCommands && metrics.commandCount > limits.maxCommands) {
      throw new Error(
        `Terminal ${terminal.id} exceeded command limit: ${metrics.commandCount} > ${limits.maxCommands}`
      );
    }
  }

  getMetrics(terminalId: string): ITerminalMetrics | undefined {
    return this.metrics.get(terminalId);
  }

  getAllMetrics(): ITerminalMetrics[] {
    return Array.from(this.metrics.values());
  }

  private async getCPUUsage(terminal: ITerminalSession): Promise<number> {
    // This is a simplified implementation
    // In production, you'd want to track actual process CPU usage
    try {
      const { stdout } = await execFileAsync('ps', [
        'aux'
      ]);
      
      // Parse and find processes for this terminal
      // This is simplified - real implementation would be more sophisticated
      return 0;
    } catch {
      return 0;
    }
  }

  private async getMemoryUsage(terminal: ITerminalSession): Promise<number> {
    // Simplified - would track actual process memory
    return process.memoryUsage().heapUsed;
  }

  private async getDiskUsage(directory: string): Promise<number> {
    try {
      const { stdout } = await execFileAsync('du', [
        '-sb',
        directory
      ]);
      
      const size = parseInt(stdout.split('\t')[0]);
      return size;
    } catch {
      return 0;
    }
  }
}
```

## Integration Tests

### 4.7 Terminal Integration Tests

```typescript
// src/terminal/__tests__/terminal-integration.spec.ts
import { TerminalPool } from '../terminal-pool';
import { createLogger } from '@/utils/logger';
import * as fs from 'fs/promises';
import * as path from 'path';

describe('Terminal Integration Tests', () => {
  let pool: TerminalPool;
  const testBaseDir = '/tmp/claude-test-terminals';

  beforeAll(async () => {
    if (!process.env.TERMINAL_INTEGRATION_TEST) {
      console.log('Skipping terminal integration tests. Set TERMINAL_INTEGRATION_TEST=true to run.');
      return;
    }
    
    // Clean up any previous test directories
    await fs.rm(testBaseDir, { recursive: true, force: true });
  });

  beforeEach(async () => {
    const logger = createLogger({ level: 'debug' });
    pool = new TerminalPool(logger, {
      maxTerminals: 5,
      baseWorkDir: testBaseDir
    });
  });

  afterEach(async () => {
    await pool.shutdown();
  });

  afterAll(async () => {
    // Clean up test directories
    await fs.rm(testBaseDir, { recursive: true, force: true });
  });

  it('should execute real commands in isolated terminals', async () => {
    // Allocate terminals for two agents
    const terminal1 = await pool.allocate('agent-1');
    const terminal2 = await pool.allocate('agent-2');

    // Create files in each terminal's directory
    const result1 = await terminal1.execute('echo "Agent 1 file" > test1.txt');
    const result2 = await terminal2.execute('echo "Agent 2 file" > test2.txt');

    expect(result1.exitCode).toBe(0);
    expect(result2.exitCode).toBe(0);

    // Verify isolation - each agent only sees their own file
    const ls1 = await terminal1.execute('ls');
    const ls2 = await terminal2.execute('ls');

    expect(ls1.output).toContain('test1.txt');
    expect(ls1.output).not.toContain('test2.txt');
    
    expect(ls2.output).toContain('test2.txt');
    expect(ls2.output).not.toContain('test1.txt');

    // Verify working directories are different
    const pwd1 = await terminal1.execute('pwd');
    const pwd2 = await terminal2.execute('pwd');

    expect(pwd1.output).toContain('agent-1');
    expect(pwd2.output).toContain('agent-2');
  });

  it('should maintain environment isolation', async () => {
    const terminal1 = await pool.allocate('agent-1');
    const terminal2 = await pool.allocate('agent-2');

    // Set environment variables
    await terminal1.execute('export TEST_VAR="Agent 1 Value"');
    await terminal2.execute('export TEST_VAR="Agent 2 Value"');

    // Verify isolation
    const env1 = await terminal1.execute('echo $TEST_VAR');
    const env2 = await terminal2.execute('echo $TEST_VAR');

    expect(env1.output).toContain('Agent 1 Value');
    expect(env2.output).toContain('Agent 2 Value');

    // Verify agent IDs are set correctly
    const id1 = await terminal1.execute('echo $CLAUDE_AGENT_ID');
    const id2 = await terminal2.execute('echo $CLAUDE_AGENT_ID');

    expect(id1.output).toContain('agent-1');
    expect(id2.output).toContain('agent-2');
  });

  it('should handle concurrent command execution', async () => {
    const terminal = await pool.allocate('test-agent');

    // Execute multiple commands concurrently
    const commands = [
      terminal.execute('sleep 0.1 && echo "Command 1"'),
      terminal.execute('sleep 0.2 && echo "Command 2"'),
      terminal.execute('sleep 0.3 && echo "Command 3"')
    ];

    const results = await Promise.all(commands);

    // All should succeed
    expect(results.every(r => r.exitCode === 0)).toBe(true);
    
    // Output should be in order (due to queueing)
    expect(results[0].output).toContain('Command 1');
    expect(results[1].output).toContain('Command 2');
    expect(results[2].output).toContain('Command 3');
  });

  it('should clean up working directories on release', async () => {
    const terminal = await pool.allocate('cleanup-test');
    const workingDir = terminal.workingDirectory;

    // Create some files
    await terminal.execute('touch file1.txt file2.txt');
    await terminal.execute('mkdir subdir');

    // Verify files exist
    const beforeStat = await fs.stat(workingDir);
    expect(beforeStat.isDirectory()).toBe(true);

    // Release terminal
    await pool.release('cleanup-test');

    // Verify directory is cleaned up
    await expect(fs.stat(workingDir)).rejects.toThrow();
  });
});
```

## Success Criteria
- ✅ 100% test coverage maintained
- ✅ Terminal isolation working
- ✅ Resource limits enforced
- ✅ Concurrent execution stable
- ✅ Cleanup procedures reliable
- ✅ Integration with CLI manager seamless

## Next Steps
- Proceed to Step 5: Repository Management
- Use terminal pool for all agent execution
- Monitor resource usage in production