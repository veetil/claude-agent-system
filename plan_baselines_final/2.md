# Step 2: Core Types and Interfaces

## Objective
Define all core types, interfaces, and contracts that will govern the multi-agent system. This establishes the system's vocabulary and ensures type safety throughout the implementation.

## Prerequisites
- Step 1 TDD infrastructure complete
- TypeScript 5+ configured
- 100% type coverage requirement

## Core Type Definitions

### 2.1 Agent Types

```typescript
// src/types/agent.types.ts

/**
 * Base agent configuration
 */
export interface IAgentConfig {
  id: string;
  type: AgentType;
  name?: string;
  description?: string;
  systemPrompt?: string;
  appendSystemPrompt?: string;
  maxTurns?: number;
  maxTokens?: number;
  temperature?: number;
  allowedTools?: string[];
  disallowedTools?: string[];
  memoryPath?: string;
  workingDirectory?: string;
  env?: Record<string, string>;
  metadata?: Record<string, any>;
}

/**
 * Agent types supported by the system
 */
export type AgentType = 
  | 'research'      // Information gathering and analysis
  | 'code'          // Code generation and modification
  | 'review'        // Code review and quality assessment
  | 'test'          // Test creation and execution
  | 'documentation' // Documentation generation
  | 'orchestrator'; // Task coordination

/**
 * Agent lifecycle states
 */
export type AgentState = 
  | 'idle'          // Created but not initialized
  | 'initializing'  // Setting up resources
  | 'ready'         // Ready to accept tasks
  | 'busy'          // Currently executing a task
  | 'error'         // In error state
  | 'terminated';   // Shut down

/**
 * Agent interface
 */
export interface IAgent {
  readonly id: string;
  readonly type: AgentType;
  readonly sessionId?: string;
  
  // Lifecycle methods
  initialize(): Promise<void>;
  execute(task: ITask): Promise<IAgentResult>;
  terminate(): Promise<void>;
  
  // State management
  getState(): AgentState;
  getMetrics(): IAgentMetrics;
  
  // Event emitter methods
  on(event: 'stateChange', listener: (change: IStateChange) => void): void;
  on(event: 'error', listener: (error: Error) => void): void;
  on(event: 'metrics', listener: (metrics: IAgentMetrics) => void): void;
}

/**
 * Agent execution result
 */
export interface IAgentResult {
  taskId: string;
  agentId: string;
  sessionId: string;
  status: 'completed' | 'failed' | 'partial';
  result?: any;
  error?: Error;
  artifacts?: IArtifact[];
  metrics: IExecutionMetrics;
  timestamp: Date;
}

/**
 * Agent performance metrics
 */
export interface IAgentMetrics {
  agentId: string;
  tasksCompleted: number;
  tasksFailed: number;
  totalCost: number;
  totalDuration: number;
  averageResponseTime: number;
  sessionContinuity: number;
  lastActivity: Date;
}

/**
 * State change event
 */
export interface IStateChange {
  previousState: AgentState;
  currentState: AgentState;
  reason?: string;
}
```

### 2.2 Task Types

```typescript
// src/types/task.types.ts

/**
 * Task definition
 */
export interface ITask {
  id: string;
  type: TaskType;
  priority: Priority;
  status: TaskStatus;
  description: string;
  createdAt: Date;
  updatedAt?: Date;
  deadline?: Date;
  dependencies?: string[];
  context?: ITaskContext;
  constraints?: ITaskConstraints;
  metadata?: Record<string, any>;
}

/**
 * Task types
 */
export type TaskType = 
  | 'research'
  | 'analysis'
  | 'implementation'
  | 'refactoring'
  | 'optimization'
  | 'code_review'
  | 'architecture_review'
  | 'unit_test'
  | 'integration_test'
  | 'test_planning'
  | 'documentation'
  | 'planning'
  | 'coordination'
  | 'delegation';

/**
 * Task priority levels
 */
export type Priority = 'low' | 'medium' | 'high' | 'urgent';

/**
 * Task lifecycle states
 */
export type TaskStatus = 
  | 'pending'
  | 'queued'
  | 'assigned'
  | 'in_progress'
  | 'completed'
  | 'failed'
  | 'cancelled';

/**
 * Task execution context
 */
export interface ITaskContext {
  projectPath?: string;
  files?: string[];
  searchPaths?: string[];
  testCommand?: string;
  lintCommand?: string;
  buildCommand?: string;
  requirements?: string[];
  examples?: IExample[];
  references?: string[];
  [key: string]: any;
}

/**
 * Task constraints
 */
export interface ITaskConstraints {
  maxDuration?: number;
  maxCost?: number;
  requiredTools?: string[];
  forbiddenTools?: string[];
  outputFormat?: string;
  qualityThreshold?: number;
}

/**
 * Task assignment
 */
export interface ITaskAssignment {
  task: ITask;
  agentId: string;
  assignedAt: Date;
  deadline?: Date;
  dependencies?: string[];
  context?: ITaskContext;
}

/**
 * Task result
 */
export interface ITaskResult {
  taskId: string;
  status: 'completed' | 'failed' | 'partial';
  result?: any;
  error?: Error;
  artifacts?: IArtifact[];
  metrics: IExecutionMetrics;
  completedAt: Date;
}
```

### 2.3 CLI and Process Types

```typescript
// src/types/cli.types.ts

/**
 * Claude SDK response format
 */
export interface IClaudeSDKResponse {
  type: 'result';
  subtype: 'success' | 'error_max_turns' | 'error';
  cost_usd: number;
  duration_ms: number;
  duration_api_ms: number;
  is_error: boolean;
  num_turns: number;
  result?: string;
  session_id: string;
  error?: {
    message: string;
    code?: string;
  };
  tokens_used?: number;
}

/**
 * Session configuration
 */
export interface ISessionConfig {
  prompt: string;
  systemPrompt?: string;
  appendSystemPrompt?: string;
  outputFormat: 'json' | 'stream-json';
  maxTurns?: number;
  maxTokens?: number;
  temperature?: number;
  workingDirectory?: string;
  env?: Record<string, string>;
  allowedTools?: string[];
  disallowedTools?: string[];
  skipPermissions?: boolean;
  metadata?: Record<string, any>;
}

/**
 * Execution configuration
 */
export interface IExecutionConfig extends ISessionConfig {
  sessionId: string;
  resume?: boolean;
  continue?: boolean;
}

/**
 * Stream message format
 */
export interface IStreamMessage {
  type: 'system' | 'assistant' | 'user' | 'result';
  subtype?: string;
  session_id: string;
  content?: string;
  timestamp?: string;
  [key: string]: any;
}

/**
 * Process options
 */
export interface IProcessOptions {
  maxConcurrentProcesses?: number;
  processTimeout?: number;
  memoryLimit?: number;
  cpuLimit?: number;
  retryAttempts?: number;
  retryDelay?: number;
}

/**
 * Session information
 */
export interface ISessionInfo {
  sessionId: string;
  agentId: string;
  createdAt: Date;
  lastUsed: Date;
  config: ISessionConfig;
  metadata?: Record<string, any>;
}
```

### 2.4 Terminal and Workspace Types

```typescript
// src/types/terminal.types.ts

/**
 * Terminal session interface
 */
export interface ITerminalSession {
  id: string;
  agentId: string;
  workingDirectory: string;
  env: Record<string, string>;
  createdAt: Date;
  lastUsed: Date;
  
  execute(command: string): Promise<ICommandResult>;
  getOutput(): string[];
  clear(): void;
  destroy(): Promise<void>;
}

/**
 * Command execution result
 */
export interface ICommandResult {
  command: string;
  output: string;
  error: string;
  exitCode: number;
  duration: number;
  timestamp: Date;
}

/**
 * Terminal pool configuration
 */
export interface ITerminalPoolConfig {
  maxTerminals: number;
  maxIdleTime: number;
  baseWorkDir?: string;
  resourceLimits?: IResourceLimits;
}

/**
 * Resource limits
 */
export interface IResourceLimits {
  maxMemory?: number;
  maxCpu?: number;
  maxDisk?: number;
  maxProcesses?: number;
  maxFileHandles?: number;
}

/**
 * Terminal metrics
 */
export interface ITerminalMetrics {
  terminalId: string;
  agentId: string;
  cpuUsage: number;
  memoryUsage: number;
  diskUsage: number;
  commandCount: number;
  uptime: number;
}
```

### 2.5 Repository Management Types

```typescript
// src/types/repository.types.ts

/**
 * Worktree information
 */
export interface IWorktree {
  id: string;
  agentId: string;
  taskId: string;
  path: string;
  branch: string;
  baseBranch: string;
  createdAt: Date;
  lastSync?: Date;
}

/**
 * File lock information
 */
export interface IFileLock {
  file: string;
  agentId: string;
  taskId: string;
  acquiredAt: Date;
  expiresAt: Date;
}

/**
 * Lock result
 */
export interface ILockResult {
  success: boolean;
  locks?: IFileLock[];
  conflicts?: ILockConflict[];
}

/**
 * Lock conflict
 */
export interface ILockConflict {
  file: string;
  currentHolder: string;
  requestedBy: string;
  conflictType: 'locked' | 'stale' | 'permission';
}

/**
 * File change
 */
export interface IFileChange {
  file: string;
  type: 'create' | 'modify' | 'delete' | 'rename';
  content?: string;
  oldPath?: string;
  agentId: string;
  timestamp: Date;
}

/**
 * Conflict types
 */
export interface IConflict {
  type: 'file' | 'semantic' | 'merge' | 'build';
  severity: 'low' | 'medium' | 'high' | 'critical';
  files: string[];
  description: string;
  agents: string[];
  suggestions?: IConflictSuggestion[];
}

/**
 * Conflict suggestion
 */
export interface IConflictSuggestion {
  type: 'wait' | 'alternative' | 'collaborate' | 'escalate';
  description: string;
  estimatedDelay?: number;
  alternativeFiles?: string[];
  collaborators?: string[];
}

/**
 * Merge result
 */
export interface IMergeResult {
  success: boolean;
  branch?: string;
  conflicts?: IConflict[];
  mergedFiles?: string[];
  error?: string;
}
```

### 2.6 Message Queue Types

```typescript
// src/types/messaging.types.ts

/**
 * Message structure
 */
export interface IMessage<T = any> {
  id: string;
  type: MessageType;
  source: string;
  target?: string;
  timestamp: Date;
  correlationId?: string;
  priority: Priority;
  ttl?: number;
  payload: T;
  metadata?: Record<string, any>;
}

/**
 * Message types
 */
export enum MessageType {
  // Task messages
  TASK_ASSIGNMENT = 'task.assignment',
  TASK_ACCEPTED = 'task.accepted',
  TASK_REJECTED = 'task.rejected',
  TASK_PROGRESS = 'task.progress',
  TASK_COMPLETED = 'task.completed',
  TASK_FAILED = 'task.failed',
  
  // Agent messages
  AGENT_READY = 'agent.ready',
  AGENT_BUSY = 'agent.busy',
  AGENT_ERROR = 'agent.error',
  AGENT_HEARTBEAT = 'agent.heartbeat',
  AGENT_METRICS = 'agent.metrics',
  
  // Collaboration messages
  HELP_REQUEST = 'collab.help_request',
  HELP_OFFER = 'collab.help_offer',
  KNOWLEDGE_SHARE = 'collab.knowledge_share',
  CONFLICT_DETECTED = 'collab.conflict_detected',
  
  // System messages
  SYSTEM_SHUTDOWN = 'system.shutdown',
  SYSTEM_PAUSE = 'system.pause',
  SYSTEM_RESUME = 'system.resume',
  SYSTEM_HEALTH = 'system.health'
}

/**
 * Message handler
 */
export type MessageHandler<T = any> = (message: IMessage<T>) => Promise<void> | void;

/**
 * Subscription
 */
export interface ISubscription {
  id: string;
  pattern: string | RegExp;
  unsubscribe(): void;
}

/**
 * Queue statistics
 */
export interface IQueueStats {
  messagesPublished: number;
  messagesDelivered: number;
  messagesFailed: number;
  activeSubscriptions: number;
  queueDepth: number;
  deadLetterCount: number;
}
```

### 2.7 Common Types

```typescript
// src/types/common.types.ts

/**
 * Logger interface
 */
export interface ILogger {
  debug(message: string, meta?: any): void;
  info(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  error(message: string, error?: Error | any): void;
  child(meta: any): ILogger;
}

/**
 * Execution metrics
 */
export interface IExecutionMetrics {
  duration_ms: number;
  cost_usd: number;
  turns_used: number;
  tokens_used?: number;
  memory_used?: number;
  cpu_time?: number;
}

/**
 * Artifact produced by task execution
 */
export interface IArtifact {
  type: 'file' | 'code' | 'report' | 'test' | 'documentation';
  name: string;
  path?: string;
  content?: string;
  metadata?: Record<string, any>;
}

/**
 * Example for task context
 */
export interface IExample {
  input: string;
  output: string;
  description?: string;
}

/**
 * System health status
 */
export interface IHealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  components: {
    [component: string]: {
      status: 'ok' | 'warning' | 'error';
      message?: string;
      lastCheck: Date;
    };
  };
  metrics?: {
    uptime: number;
    memoryUsage: number;
    cpuUsage: number;
    activeAgents: number;
    queueDepth: number;
  };
}

/**
 * Error types
 */
export class AgentError extends Error {
  constructor(
    message: string,
    public code: string,
    public agentId?: string,
    public taskId?: string
  ) {
    super(message);
    this.name = 'AgentError';
  }
}

export class TaskError extends Error {
  constructor(
    message: string,
    public code: string,
    public taskId: string,
    public agentId?: string
  ) {
    super(message);
    this.name = 'TaskError';
  }
}

export class CLIError extends Error {
  constructor(
    message: string,
    public code: string,
    public sessionId?: string,
    public exitCode?: number
  ) {
    super(message);
    this.name = 'CLIError';
  }
}
```

### 2.8 Configuration Types

```typescript
// src/types/config.types.ts

/**
 * System configuration
 */
export interface ISystemConfig {
  orchestrator: IOrchestratorConfig;
  agents: IAgentPoolConfig;
  messaging: IMessagingConfig;
  repository: IRepositoryConfig;
  monitoring: IMonitoringConfig;
}

/**
 * Orchestrator configuration
 */
export interface IOrchestratorConfig {
  maxConcurrentTasks: number;
  taskQueueSize: number;
  schedulingStrategy: 'fifo' | 'priority' | 'smart';
  conflictResolution: 'automatic' | 'manual' | 'hybrid';
}

/**
 * Agent pool configuration
 */
export interface IAgentPoolConfig {
  maxAgents: number;
  agentTypes: {
    [type in AgentType]?: {
      min: number;
      max: number;
      autoScale: boolean;
    };
  };
  defaultTimeout: number;
  healthCheckInterval: number;
}

/**
 * Messaging configuration
 */
export interface IMessagingConfig {
  maxQueueSize: number;
  messageRetention: number;
  deadLetterRetries: number;
  deliveryTimeout: number;
}

/**
 * Repository configuration
 */
export interface IRepositoryConfig {
  basePath: string;
  worktreeBasePath: string;
  maxWorktrees: number;
  lockTimeout: number;
  conflictDetection: boolean;
}

/**
 * Monitoring configuration
 */
export interface IMonitoringConfig {
  metricsInterval: number;
  logLevel: 'debug' | 'info' | 'warn' | 'error';
  enableTracing: boolean;
  enableProfiling: boolean;
}
```

## Type Guards and Utilities

### 2.9 Type Guards

```typescript
// src/types/guards.ts

export function isClaudeSDKResponse(value: any): value is IClaudeSDKResponse {
  return (
    value?.type === 'result' &&
    ['success', 'error_max_turns', 'error'].includes(value?.subtype) &&
    typeof value?.session_id === 'string' &&
    typeof value?.cost_usd === 'number'
  );
}

export function isValidTask(value: any): value is ITask {
  return (
    typeof value?.id === 'string' &&
    typeof value?.type === 'string' &&
    typeof value?.priority === 'string' &&
    typeof value?.status === 'string' &&
    typeof value?.description === 'string' &&
    value?.createdAt instanceof Date
  );
}

export function isAgentMessage(message: IMessage): message is IMessage<IAgentMetrics> {
  return message.type === MessageType.AGENT_METRICS;
}

export function isTaskMessage(message: IMessage): message is IMessage<ITaskResult> {
  return [
    MessageType.TASK_COMPLETED,
    MessageType.TASK_FAILED
  ].includes(message.type);
}
```

### 2.10 Type Utilities

```typescript
// src/types/utils.ts

/**
 * Make all properties optional recursively
 */
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Make specific properties required
 */
export type RequireFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

/**
 * Exclude null and undefined from type
 */
export type NonNullable<T> = T extends null | undefined ? never : T;

/**
 * Extract promise type
 */
export type PromiseType<T extends Promise<any>> = T extends Promise<infer U> ? U : never;

/**
 * Create discriminated union helper
 */
export type DiscriminateUnion<T, K extends keyof T, V extends T[K]> = 
  T extends Record<K, V> ? T : never;
```

## Testing Types

### 2.11 Type Tests

```typescript
// src/types/__tests__/types.spec.ts
import { expectType, expectNotType, expectAssignable } from 'tsd';

// Test ITask type
expectType<ITask>({
  id: 'task-1',
  type: 'research',
  priority: 'high',
  status: 'pending',
  description: 'Test task',
  createdAt: new Date()
});

// Test that invalid types are caught
expectNotType<ITask>({
  id: 123, // Should be string
  type: 'research',
  priority: 'high',
  status: 'pending',
  description: 'Test task',
  createdAt: new Date()
});

// Test type assignments
declare const task: ITask;
expectAssignable<{ id: string }>(task);
```

## Documentation

### 2.12 Type Documentation

```typescript
/**
 * @example
 * const config: IAgentConfig = {
 *   id: 'agent-1',
 *   type: 'research',
 *   systemPrompt: 'You are a research agent',
 *   maxTurns: 10,
 *   allowedTools: ['Read', 'Search']
 * };
 */
export interface IAgentConfig {
  // ... interface definition
}
```

## Success Criteria
- ✅ All core types defined
- ✅ Type guards implemented
- ✅ Type utilities available
- ✅ 100% type coverage
- ✅ Type tests passing
- ✅ Documentation complete

## Next Steps
With types defined:
1. Use these types throughout the system
2. Ensure strict TypeScript mode
3. No use of `any` without justification
4. All functions properly typed
5. Proceed to Step 3: CLI Process Manager