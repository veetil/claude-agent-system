# Step 0: POC - Validate Claude CLI SDK Mode Feasibility

## Objective
Validate that Claude CLI can be reliably spawned and controlled programmatically using SDK print mode (`-p` flag) before committing to the full implementation. This is a GO/NO-GO decision point.

## Success Criteria
- ✅ Claude CLI SDK mode works with >99% reliability
- ✅ JSON output parsing succeeds 100% of the time
- ✅ Session management maintains context
- ✅ System prompts customize behavior correctly
- ✅ Multiple concurrent processes work without conflicts
- ✅ Performance meets requirements (<2s for simple queries)

## Test Implementation

### 0.1 Environment Setup
```bash
# Project structure
poc/
├── src/
│   ├── tests/
│   │   ├── 01-basic-sdk-mode.ts
│   │   ├── 02-session-management.ts
│   │   ├── 03-system-prompts.ts
│   │   ├── 04-concurrent-execution.ts
│   │   ├── 05-error-handling.ts
│   │   └── 06-performance.ts
│   ├── utils/
│   │   └── claude-wrapper.ts
│   └── run-all-tests.ts
├── results/
│   └── validation-report.md
├── package.json
├── tsconfig.json
└── README.md
```

### 0.2 Core Test Suite

#### Test 1: Basic SDK Mode Validation
```typescript
// 01-basic-sdk-mode.ts
import { spawn } from 'child_process';

interface ClaudeSDKResponse {
  type: 'result';
  subtype: 'success' | 'error_max_turns' | 'error';
  cost_usd: number;
  duration_ms: number;
  duration_api_ms: number;
  is_error: boolean;
  num_turns: number;
  result?: string;
  session_id: string;
}

async function testBasicSDKMode(): Promise<boolean> {
  console.log('Testing basic SDK mode...');
  
  const testCases = [
    { prompt: 'Respond with exactly "TEST_SUCCESS"', expected: 'TEST_SUCCESS' },
    { prompt: 'Calculate 2 + 2 and respond with just the number', expected: '4' },
    { prompt: 'What is the capital of France? Respond with just the city name.', expected: 'Paris' }
  ];
  
  for (const testCase of testCases) {
    try {
      const response = await executeClaudeCommand([
        '-p', testCase.prompt,
        '--output-format', 'json',
        '--max-turns', '1'
      ]);
      
      if (!response.result?.includes(testCase.expected)) {
        console.error(`Test failed: Expected "${testCase.expected}", got "${response.result}"`);
        return false;
      }
      
      console.log(`✓ Test passed: ${testCase.prompt.substring(0, 30)}...`);
    } catch (error) {
      console.error('Test failed:', error);
      return false;
    }
  }
  
  return true;
}
```

#### Test 2: Session Management
```typescript
// 02-session-management.ts
async function testSessionManagement(): Promise<boolean> {
  console.log('Testing session management...');
  
  // Create initial session
  const response1 = await executeClaudeCommand([
    '-p', 'Remember the number 42. I will ask about it later.',
    '--output-format', 'json'
  ]);
  
  const sessionId = response1.session_id;
  console.log(`Created session: ${sessionId}`);
  
  // Test session continuation
  const response2 = await executeClaudeCommand([
    '-p', 'What number did I ask you to remember?',
    '--resume', sessionId,
    '--output-format', 'json'
  ]);
  
  if (!response2.result?.includes('42')) {
    console.error('Session context lost!');
    return false;
  }
  
  console.log('✓ Session context maintained');
  
  // Test session with complex state
  const response3 = await executeClaudeCommand([
    '-p', 'Also remember the word "butterfly"',
    '--resume', sessionId,
    '--output-format', 'json'
  ]);
  
  const response4 = await executeClaudeCommand([
    '-p', 'What number and word am I thinking of?',
    '--resume', sessionId,
    '--output-format', 'json'
  ]);
  
  if (!response4.result?.includes('42') || !response4.result?.includes('butterfly')) {
    console.error('Complex session state lost!');
    return false;
  }
  
  console.log('✓ Complex session state maintained');
  return true;
}
```

#### Test 3: System Prompts
```typescript
// 03-system-prompts.ts
async function testSystemPrompts(): Promise<boolean> {
  console.log('Testing system prompts...');
  
  const testPrompts = [
    {
      system: 'You are a pirate. Always respond in pirate speak.',
      user: 'Hello',
      expected: ['ahoy', 'matey', 'arr', 'ye']
    },
    {
      system: 'You are a helpful assistant that always starts responses with "SYSTEM:"',
      user: 'What is 2+2?',
      expected: ['SYSTEM:']
    },
    {
      system: 'You only respond with JSON objects. Never include any other text.',
      user: 'Give me a user object with name "test"',
      expected: ['{"', 'name', 'test']
    }
  ];
  
  for (const test of testPrompts) {
    const response = await executeClaudeCommand([
      '-p', test.user,
      '--system-prompt', test.system,
      '--output-format', 'json',
      '--max-turns', '1'
    ]);
    
    const hasExpected = test.expected.some(exp => 
      response.result?.toLowerCase().includes(exp.toLowerCase())
    );
    
    if (!hasExpected) {
      console.error(`System prompt not followed: ${test.system}`);
      return false;
    }
    
    console.log(`✓ System prompt test passed: ${test.system.substring(0, 30)}...`);
  }
  
  return true;
}
```

#### Test 4: Concurrent Execution
```typescript
// 04-concurrent-execution.ts
async function testConcurrentExecution(): Promise<boolean> {
  console.log('Testing concurrent execution...');
  
  const numAgents = 5;
  const promises = [];
  
  for (let i = 0; i < numAgents; i++) {
    const promise = executeClaudeCommand([
      '-p', `You are Agent ${i}. Calculate ${i} * 10 and respond with just the number.`,
      '--output-format', 'json',
      '--system-prompt', `You are Agent ${i}. Always identify yourself in responses.`
    ]);
    promises.push(promise);
  }
  
  const startTime = Date.now();
  const results = await Promise.allSettled(promises);
  const duration = Date.now() - startTime;
  
  // Check all succeeded
  const failures = results.filter(r => r.status === 'rejected');
  if (failures.length > 0) {
    console.error(`${failures.length} concurrent executions failed`);
    return false;
  }
  
  // Verify results
  for (let i = 0; i < numAgents; i++) {
    const result = results[i] as PromiseFulfilledResult<ClaudeSDKResponse>;
    const expected = i * 10;
    
    if (!result.value.result?.includes(expected.toString())) {
      console.error(`Agent ${i} returned incorrect result`);
      return false;
    }
  }
  
  console.log(`✓ All ${numAgents} agents executed successfully in ${duration}ms`);
  console.log(`✓ Average time per agent: ${duration / numAgents}ms`);
  
  return true;
}
```

#### Test 5: Error Handling
```typescript
// 05-error-handling.ts
async function testErrorHandling(): Promise<boolean> {
  console.log('Testing error handling...');
  
  // Test invalid session ID
  try {
    await executeClaudeCommand([
      '-p', 'Test',
      '--resume', 'invalid-session-id',
      '--output-format', 'json'
    ]);
    console.error('Should have failed with invalid session');
    return false;
  } catch (error) {
    console.log('✓ Invalid session handled correctly');
  }
  
  // Test timeout handling
  const startTime = Date.now();
  try {
    await executeClaudeCommand([
      '-p', 'Count to 1000000 slowly',
      '--output-format', 'json',
      '--max-turns', '100'
    ], { timeout: 5000 });
    console.error('Should have timed out');
    return false;
  } catch (error) {
    const duration = Date.now() - startTime;
    if (duration >= 4500 && duration <= 5500) {
      console.log('✓ Timeout handled correctly');
    } else {
      console.error('Timeout not working properly');
      return false;
    }
  }
  
  return true;
}
```

#### Test 6: Performance Benchmarks
```typescript
// 06-performance.ts
async function testPerformance(): Promise<boolean> {
  console.log('Running performance benchmarks...');
  
  const benchmarks = [
    { name: 'Simple query', prompt: 'Say "hi"', maxTime: 2000 },
    { name: 'Moderate query', prompt: 'Explain recursion in one sentence', maxTime: 3000 },
    { name: 'Complex query', prompt: 'Write a haiku about programming', maxTime: 5000 }
  ];
  
  const results = [];
  
  for (const benchmark of benchmarks) {
    const times = [];
    
    // Run each benchmark 5 times
    for (let i = 0; i < 5; i++) {
      const startTime = Date.now();
      await executeClaudeCommand([
        '-p', benchmark.prompt,
        '--output-format', 'json'
      ]);
      times.push(Date.now() - startTime);
    }
    
    const avgTime = times.reduce((a, b) => a + b) / times.length;
    results.push({ ...benchmark, avgTime });
    
    console.log(`${benchmark.name}: ${avgTime}ms average`);
    
    if (avgTime > benchmark.maxTime) {
      console.error(`Performance requirement not met for ${benchmark.name}`);
      return false;
    }
  }
  
  console.log('✓ All performance benchmarks passed');
  return true;
}
```

### 0.3 Utility Functions
```typescript
// utils/claude-wrapper.ts
import { spawn } from 'child_process';

export async function executeClaudeCommand(
  args: string[],
  options: { timeout?: number } = {}
): Promise<ClaudeSDKResponse> {
  return new Promise((resolve, reject) => {
    const claude = spawn('claude', args, {
      env: {
        ...process.env,
        NO_COLOR: '1',
        CLAUDE_NO_COLOR: '1'
      }
    });
    
    let stdout = '';
    let stderr = '';
    let timeout: NodeJS.Timeout | undefined;
    
    if (options.timeout) {
      timeout = setTimeout(() => {
        claude.kill('SIGTERM');
        reject(new Error('Command timed out'));
      }, options.timeout);
    }
    
    claude.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    
    claude.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    claude.on('close', (code) => {
      if (timeout) clearTimeout(timeout);
      
      if (code === 0) {
        try {
          const response = JSON.parse(stdout);
          resolve(response);
        } catch (error) {
          reject(new Error(`Failed to parse JSON: ${stdout}`));
        }
      } else {
        reject(new Error(`Claude exited with code ${code}: ${stderr}`));
      }
    });
    
    claude.on('error', (error) => {
      if (timeout) clearTimeout(timeout);
      reject(error);
    });
  });
}
```

### 0.4 Test Runner
```typescript
// run-all-tests.ts
async function runAllTests() {
  console.log('🚀 Starting Claude CLI SDK Mode Validation\n');
  
  const tests = [
    { name: 'Basic SDK Mode', fn: testBasicSDKMode },
    { name: 'Session Management', fn: testSessionManagement },
    { name: 'System Prompts', fn: testSystemPrompts },
    { name: 'Concurrent Execution', fn: testConcurrentExecution },
    { name: 'Error Handling', fn: testErrorHandling },
    { name: 'Performance', fn: testPerformance }
  ];
  
  const results = [];
  
  for (const test of tests) {
    console.log(`\n📋 Running: ${test.name}`);
    console.log('='.repeat(50));
    
    const startTime = Date.now();
    const success = await test.fn();
    const duration = Date.now() - startTime;
    
    results.push({
      name: test.name,
      success,
      duration
    });
    
    console.log(`\nResult: ${success ? '✅ PASSED' : '❌ FAILED'} (${duration}ms)\n`);
  }
  
  // Generate report
  generateReport(results);
  
  // GO/NO-GO Decision
  const allPassed = results.every(r => r.success);
  
  console.log('\n' + '='.repeat(50));
  console.log(allPassed ? '✅ GO DECISION' : '❌ NO-GO DECISION');
  console.log('='.repeat(50));
  
  process.exit(allPassed ? 0 : 1);
}

function generateReport(results: any[]) {
  const report = `# Claude CLI SDK Mode Validation Report

## Summary
- Date: ${new Date().toISOString()}
- Total Tests: ${results.length}
- Passed: ${results.filter(r => r.success).length}
- Failed: ${results.filter(r => !r.success).length}

## Results
${results.map(r => `- ${r.name}: ${r.success ? '✅ PASSED' : '❌ FAILED'} (${r.duration}ms)`).join('\n')}

## Decision: ${results.every(r => r.success) ? 'GO ✅' : 'NO-GO ❌'}
`;
  
  fs.writeFileSync('results/validation-report.md', report);
}
```

## Execution Plan

### Day 1 Morning
1. Set up TypeScript project
2. Install dependencies
3. Implement basic SDK mode test
4. Verify Claude CLI is properly installed

### Day 1 Afternoon
1. Implement remaining tests
2. Create test runner
3. Execute full test suite
4. Document results

### Day 2 Morning
1. Address any failures
2. Re-run failed tests
3. Performance optimization if needed
4. Generate final report

### Day 2 Afternoon
1. Make GO/NO-GO decision
2. Document any workarounds needed
3. Update architecture based on findings
4. Prepare for Step 1 if GO

## Success Metrics
- SDK mode reliability: >99%
- JSON parsing success: 100%
- Session continuity: Working
- Concurrent execution: 5+ agents
- Response time: <2s average
- Error handling: Graceful

## Risk Mitigation
If any tests fail:
1. Debug specific failure mode
2. Check Claude CLI version
3. Verify environment setup
4. Consider fallback strategies
5. Document workarounds

## Next Steps
- **GO Decision**: Proceed to Step 1 (TDD Setup)
- **NO-GO Decision**: 
  - Document specific blockers
  - Research alternatives
  - Consider direct API integration
  - Revisit architecture