# Step 6: Message Queue Implementation

## Objective
Implement a robust message queue system for inter-agent communication, task coordination, and event propagation. This enables agents to collaborate, share knowledge, and coordinate their activities.

## Prerequisites
- Step 5 Repository Management complete
- Understanding of pub/sub patterns
- Event-driven architecture knowledge
- Message delivery guarantees

## Test-First Implementation

### 6.1 Message Queue Tests

```typescript
// src/messaging/__tests__/message-queue.spec.ts
import { MessageQueue } from '../message-queue';
import { MessageType, IMessage } from '@/types';
import { MockFactory } from '@test/mocks/MockFactory';
import { TestHelpers } from '@test/utils/TestHelpers';

describe('MessageQueue', () => {
  let queue: MessageQueue;
  let mockLogger: jest.Mocked<ILogger>;

  beforeEach(() => {
    mockLogger = MockFactory.createMockLogger();
    queue = new MessageQueue(mockLogger, {
      maxQueueSize: 1000,
      messageRetention: 300000, // 5 minutes
      deadLetterRetries: 3,
      deliveryTimeout: 30000
    });
  });

  afterEach(async () => {
    await queue.shutdown();
  });

  describe('publishing', () => {
    it('should publish messages to subscribers', async () => {
      // Arrange
      const receivedMessages: IMessage[] = [];
      
      queue.subscribe(MessageType.TASK_COMPLETED, async (message) => {
        receivedMessages.push(message);
      });

      const message: IMessage<{ result: string }> = {
        id: 'msg-1',
        type: MessageType.TASK_COMPLETED,
        source: 'agent-1',
        timestamp: new Date(),
        priority: 'medium',
        payload: { result: 'Success' }
      };

      // Act
      await queue.publish(message);
      await TestHelpers.waitFor(() => receivedMessages.length === 1);

      // Assert
      expect(receivedMessages[0]).toEqual(message);
    });

    it('should support multiple subscribers', async () => {
      // Arrange
      const subscriber1Messages: IMessage[] = [];
      const subscriber2Messages: IMessage[] = [];
      
      queue.subscribe(MessageType.TASK_COMPLETED, async (msg) => {
        subscriber1Messages.push(msg);
      });
      
      queue.subscribe(MessageType.TASK_COMPLETED, async (msg) => {
        subscriber2Messages.push(msg);
      });

      // Act
      await queue.publish({
        id: 'msg-1',
        type: MessageType.TASK_COMPLETED,
        source: 'agent-1',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => 
        subscriber1Messages.length === 1 && subscriber2Messages.length === 1
      );

      // Assert
      expect(subscriber1Messages).toHaveLength(1);
      expect(subscriber2Messages).toHaveLength(1);
    });

    it('should respect message priority', async () => {
      // Arrange
      const receivedMessages: IMessage[] = [];
      let processingDelay = 100;
      
      queue.subscribe(MessageType.TASK_ASSIGNMENT, async (msg) => {
        await new Promise(resolve => setTimeout(resolve, processingDelay));
        receivedMessages.push(msg);
        processingDelay = 0; // Only delay first message
      });

      // Act - publish in reverse priority order
      await queue.publish({
        id: 'low',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'orchestrator',
        timestamp: new Date(),
        priority: 'low',
        payload: { priority: 'low' }
      });

      await queue.publish({
        id: 'urgent',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'orchestrator',
        timestamp: new Date(),
        priority: 'urgent',
        payload: { priority: 'urgent' }
      });

      await queue.publish({
        id: 'high',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'orchestrator',
        timestamp: new Date(),
        priority: 'high',
        payload: { priority: 'high' }
      });

      await TestHelpers.waitFor(() => receivedMessages.length === 3);

      // Assert - should process in priority order
      expect(receivedMessages[1].id).toBe('urgent');
      expect(receivedMessages[2].id).toBe('high');
    });

    it('should enforce queue size limits', async () => {
      // Arrange
      const smallQueue = new MessageQueue(mockLogger, {
        maxQueueSize: 5,
        messageRetention: 300000,
        deadLetterRetries: 3,
        deliveryTimeout: 30000
      });

      // Block processing
      let blockProcessing = true;
      smallQueue.subscribe(MessageType.TASK_ASSIGNMENT, async () => {
        while (blockProcessing) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      });

      // Act - fill queue
      for (let i = 0; i < 5; i++) {
        await smallQueue.publish({
          id: `msg-${i}`,
          type: MessageType.TASK_ASSIGNMENT,
          source: 'test',
          timestamp: new Date(),
          priority: 'medium',
          payload: {}
        });
      }

      // Try to exceed limit
      await expect(smallQueue.publish({
        id: 'overflow',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      })).rejects.toThrow('Queue is full');

      blockProcessing = false;
      await smallQueue.shutdown();
    });
  });

  describe('subscribing', () => {
    it('should support pattern-based subscriptions', async () => {
      // Arrange
      const taskMessages: IMessage[] = [];
      const agentMessages: IMessage[] = [];
      
      // Subscribe to all task messages
      queue.subscribePattern(/^task\./, async (msg) => {
        taskMessages.push(msg);
      });
      
      // Subscribe to all agent messages
      queue.subscribePattern(/^agent\./, async (msg) => {
        agentMessages.push(msg);
      });

      // Act
      await queue.publish({
        id: '1',
        type: MessageType.TASK_COMPLETED,
        source: 'agent-1',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await queue.publish({
        id: '2',
        type: MessageType.AGENT_READY,
        source: 'agent-2',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => 
        taskMessages.length === 1 && agentMessages.length === 1
      );

      // Assert
      expect(taskMessages[0].type).toBe(MessageType.TASK_COMPLETED);
      expect(agentMessages[0].type).toBe(MessageType.AGENT_READY);
    });

    it('should allow unsubscribing', async () => {
      // Arrange
      const messages: IMessage[] = [];
      
      const subscription = queue.subscribe(MessageType.TASK_COMPLETED, async (msg) => {
        messages.push(msg);
      });

      // Send first message
      await queue.publish({
        id: '1',
        type: MessageType.TASK_COMPLETED,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => messages.length === 1);

      // Act - unsubscribe
      subscription.unsubscribe();

      // Send second message
      await queue.publish({
        id: '2',
        type: MessageType.TASK_COMPLETED,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await new Promise(resolve => setTimeout(resolve, 100));

      // Assert - should only receive first message
      expect(messages).toHaveLength(1);
    });
  });

  describe('targeted messaging', () => {
    it('should deliver targeted messages', async () => {
      // Arrange
      const agent1Messages: IMessage[] = [];
      const agent2Messages: IMessage[] = [];
      
      queue.subscribeTarget('agent-1', async (msg) => {
        agent1Messages.push(msg);
      });
      
      queue.subscribeTarget('agent-2', async (msg) => {
        agent2Messages.push(msg);
      });

      // Act
      await queue.publish({
        id: '1',
        type: MessageType.HELP_REQUEST,
        source: 'orchestrator',
        target: 'agent-1',
        timestamp: new Date(),
        priority: 'high',
        payload: { task: 'help-needed' }
      });

      await TestHelpers.waitFor(() => agent1Messages.length === 1);

      // Assert
      expect(agent1Messages).toHaveLength(1);
      expect(agent2Messages).toHaveLength(0);
    });
  });

  describe('error handling', () => {
    it('should retry failed deliveries', async () => {
      // Arrange
      let attempts = 0;
      
      queue.subscribe(MessageType.TASK_ASSIGNMENT, async () => {
        attempts++;
        if (attempts < 3) {
          throw new Error('Processing failed');
        }
      });

      // Act
      await queue.publish({
        id: 'retry-test',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => attempts >= 3);

      // Assert
      expect(attempts).toBe(3);
      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Message delivery failed, retrying',
        expect.any(Object)
      );
    });

    it('should send to dead letter queue after max retries', async () => {
      // Arrange
      const deadLetters: IMessage[] = [];
      
      queue.subscribeDeadLetter(async (msg) => {
        deadLetters.push(msg);
      });

      queue.subscribe(MessageType.TASK_ASSIGNMENT, async () => {
        throw new Error('Always fails');
      });

      // Act
      await queue.publish({
        id: 'dead-letter-test',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => deadLetters.length === 1);

      // Assert
      expect(deadLetters[0].id).toBe('dead-letter-test');
      expect(mockLogger.error).toHaveBeenCalledWith(
        'Message sent to dead letter queue',
        expect.any(Object)
      );
    });

    it('should timeout long-running handlers', async () => {
      // Arrange
      const fastQueue = new MessageQueue(mockLogger, {
        maxQueueSize: 100,
        messageRetention: 300000,
        deadLetterRetries: 1,
        deliveryTimeout: 100 // 100ms timeout
      });

      const deadLetters: IMessage[] = [];
      fastQueue.subscribeDeadLetter(async (msg) => {
        deadLetters.push(msg);
      });

      fastQueue.subscribe(MessageType.TASK_ASSIGNMENT, async () => {
        await new Promise(resolve => setTimeout(resolve, 200)); // Exceeds timeout
      });

      // Act
      await fastQueue.publish({
        id: 'timeout-test',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => deadLetters.length === 1);

      // Assert
      expect(deadLetters[0].id).toBe('timeout-test');
      
      await fastQueue.shutdown();
    });
  });

  describe('message retention', () => {
    it('should expire old messages', async () => {
      jest.useFakeTimers();

      // Arrange
      const messages: IMessage[] = [];
      
      // Create queue with short retention
      const shortRetentionQueue = new MessageQueue(mockLogger, {
        maxQueueSize: 100,
        messageRetention: 1000, // 1 second
        deadLetterRetries: 3,
        deliveryTimeout: 30000
      });

      // Subscribe but block processing
      let blockProcessing = true;
      shortRetentionQueue.subscribe(MessageType.TASK_ASSIGNMENT, async (msg) => {
        if (!blockProcessing) {
          messages.push(msg);
        }
      });

      // Act - publish message
      await shortRetentionQueue.publish({
        id: 'old-message',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      // Advance time past retention
      jest.advanceTimersByTime(2000);

      // Unblock processing
      blockProcessing = false;

      // Wait a bit
      await TestHelpers.waitFor(() => messages.length === 0, 500);

      // Assert - message should have expired
      expect(messages).toHaveLength(0);
      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Message expired',
        expect.objectContaining({ messageId: 'old-message' })
      );

      await shortRetentionQueue.shutdown();
      jest.useRealTimers();
    });
  });

  describe('request-reply pattern', () => {
    it('should support request-reply correlation', async () => {
      // Arrange
      const replyHandler = jest.fn();
      
      // Subscribe to replies
      queue.subscribe(MessageType.TASK_COMPLETED, async (msg) => {
        if (msg.correlationId) {
          replyHandler(msg);
        }
      });

      // Act - send request with correlation ID
      const correlationId = 'req-123';
      await queue.publish({
        id: 'request',
        type: MessageType.TASK_ASSIGNMENT,
        source: 'orchestrator',
        target: 'agent-1',
        timestamp: new Date(),
        priority: 'high',
        correlationId,
        payload: { task: 'do-something' }
      });

      // Simulate agent reply
      await queue.publish({
        id: 'reply',
        type: MessageType.TASK_COMPLETED,
        source: 'agent-1',
        target: 'orchestrator',
        timestamp: new Date(),
        priority: 'high',
        correlationId,
        payload: { result: 'done' }
      });

      await TestHelpers.waitFor(() => replyHandler.mock.calls.length === 1);

      // Assert
      expect(replyHandler).toHaveBeenCalledWith(
        expect.objectContaining({
          correlationId,
          payload: { result: 'done' }
        })
      );
    });
  });

  describe('statistics', () => {
    it('should track queue statistics', async () => {
      // Arrange
      const handler = jest.fn();
      queue.subscribe(MessageType.TASK_COMPLETED, handler);

      // Act
      await queue.publish({
        id: '1',
        type: MessageType.TASK_COMPLETED,
        source: 'test',
        timestamp: new Date(),
        priority: 'medium',
        payload: {}
      });

      await TestHelpers.waitFor(() => handler.mock.calls.length === 1);

      const stats = queue.getStats();

      // Assert
      expect(stats).toMatchObject({
        messagesPublished: 1,
        messagesDelivered: 1,
        messagesFailed: 0,
        activeSubscriptions: 1,
        queueDepth: 0,
        deadLetterCount: 0
      });
    });
  });
});
```

### 6.2 Message Broker Tests

```typescript
// src/messaging/__tests__/message-broker.spec.ts
import { MessageBroker } from '../message-broker';
import { MessageQueue } from '../message-queue';
import { MockFactory } from '@test/mocks/MockFactory';
import { MessageType } from '@/types';

describe('MessageBroker', () => {
  let broker: MessageBroker;
  let mockLogger: jest.Mocked<ILogger>;
  let mockQueue: jest.Mocked<MessageQueue>;

  beforeEach(() => {
    mockLogger = MockFactory.createMockLogger();
    mockQueue = MockFactory.createMockMessageQueue();
    broker = new MessageBroker(mockLogger, mockQueue);
  });

  describe('agent registration', () => {
    it('should register agents and route messages', async () => {
      // Arrange
      const agent1Handler = jest.fn();
      const agent2Handler = jest.fn();

      // Act
      broker.registerAgent('agent-1', {
        messageTypes: [MessageType.TASK_ASSIGNMENT],
        handler: agent1Handler
      });

      broker.registerAgent('agent-2', {
        messageTypes: [MessageType.TASK_ASSIGNMENT, MessageType.HELP_REQUEST],
        handler: agent2Handler
      });

      // Simulate task assignment
      await broker.sendTaskAssignment('agent-1', {
        id: 'task-123',
        type: 'research',
        priority: 'high',
        status: 'pending',
        description: 'Research task',
        createdAt: new Date()
      });

      // Assert
      expect(mockQueue.publish).toHaveBeenCalledWith(
        expect.objectContaining({
          type: MessageType.TASK_ASSIGNMENT,
          target: 'agent-1',
          payload: expect.objectContaining({
            task: expect.objectContaining({ id: 'task-123' })
          })
        })
      );
    });

    it('should handle agent capabilities', () => {
      // Arrange
      broker.registerAgent('research-agent', {
        messageTypes: [MessageType.TASK_ASSIGNMENT],
        capabilities: ['research', 'analysis'],
        handler: jest.fn()
      });

      broker.registerAgent('code-agent', {
        messageTypes: [MessageType.TASK_ASSIGNMENT],
        capabilities: ['implementation', 'refactoring'],
        handler: jest.fn()
      });

      // Act
      const researchAgents = broker.findAgentsWithCapability('research');
      const codeAgents = broker.findAgentsWithCapability('implementation');

      // Assert
      expect(researchAgents).toContain('research-agent');
      expect(codeAgents).toContain('code-agent');
    });
  });

  describe('task coordination', () => {
    it('should coordinate task delegation', async () => {
      // Arrange
      const coordinatorHandler = jest.fn();
      const workerHandler = jest.fn();

      broker.registerAgent('coordinator', {
        messageTypes: [MessageType.TASK_COMPLETED],
        handler: coordinatorHandler
      });

      broker.registerAgent('worker', {
        messageTypes: [MessageType.TASK_ASSIGNMENT],
        handler: workerHandler
      });

      // Act - simulate task flow
      await broker.sendTaskAssignment('worker', {
        id: 'task-456',
        type: 'implementation',
        priority: 'medium',
        status: 'pending',
        description: 'Implement feature',
        createdAt: new Date()
      });

      await broker.sendTaskCompleted('worker', 'coordinator', {
        taskId: 'task-456',
        status: 'completed',
        result: 'Feature implemented',
        metrics: {
          duration_ms: 5000,
          cost_usd: 0.01,
          turns_used: 3
        },
        completedAt: new Date()
      });

      // Assert
      expect(mockQueue.publish).toHaveBeenCalledTimes(2);
      expect(mockQueue.publish).toHaveBeenCalledWith(
        expect.objectContaining({
          type: MessageType.TASK_COMPLETED,
          source: 'worker',
          target: 'coordinator'
        })
      );
    });
  });

  describe('collaboration patterns', () => {
    it('should facilitate help requests', async () => {
      // Arrange
      broker.registerAgent('requester', {
        messageTypes: [MessageType.HELP_OFFER],
        handler: jest.fn()
      });

      broker.registerAgent('helper-1', {
        messageTypes: [MessageType.HELP_REQUEST],
        capabilities: ['debugging', 'optimization'],
        handler: jest.fn()
      });

      broker.registerAgent('helper-2', {
        messageTypes: [MessageType.HELP_REQUEST],
        capabilities: ['testing', 'documentation'],
        handler: jest.fn()
      });

      // Act
      await broker.broadcastHelpRequest('requester', {
        type: 'debugging',
        description: 'Need help debugging async issue',
        context: { file: 'src/async.ts', line: 42 }
      });

      // Assert
      expect(mockQueue.publish).toHaveBeenCalledWith(
        expect.objectContaining({
          type: MessageType.HELP_REQUEST,
          source: 'requester',
          priority: 'high'
        })
      );
    });

    it('should share knowledge between agents', async () => {
      // Arrange
      const learnerHandler = jest.fn();
      
      broker.registerAgent('expert', {
        messageTypes: [],
        handler: jest.fn()
      });

      broker.registerAgent('learner', {
        messageTypes: [MessageType.KNOWLEDGE_SHARE],
        handler: learnerHandler
      });

      // Act
      await broker.shareKnowledge('expert', {
        topic: 'optimization-patterns',
        content: 'Use memoization for expensive computations',
        tags: ['performance', 'best-practices']
      });

      // Assert
      expect(mockQueue.publish).toHaveBeenCalledWith(
        expect.objectContaining({
          type: MessageType.KNOWLEDGE_SHARE,
          source: 'expert',
          payload: expect.objectContaining({
            topic: 'optimization-patterns'
          })
        })
      );
    });
  });

  describe('system coordination', () => {
    it('should handle system-wide events', async () => {
      // Arrange
      const agents = ['agent-1', 'agent-2', 'agent-3'];
      
      agents.forEach(id => {
        broker.registerAgent(id, {
          messageTypes: [MessageType.SYSTEM_PAUSE, MessageType.SYSTEM_RESUME],
          handler: jest.fn()
        });
      });

      // Act
      await broker.broadcastSystemEvent(MessageType.SYSTEM_PAUSE, {
        reason: 'Maintenance',
        estimatedDuration: 300000
      });

      // Assert
      expect(mockQueue.publish).toHaveBeenCalledWith(
        expect.objectContaining({
          type: MessageType.SYSTEM_PAUSE,
          source: 'system',
          priority: 'urgent'
        })
      );
    });
  });
});
```

### 6.3 Message Queue Implementation

```typescript
// src/messaging/message-queue.ts
import { EventEmitter } from 'events';
import { 
  ILogger, 
  IMessage, 
  MessageType, 
  MessageHandler,
  ISubscription,
  IQueueStats,
  Priority
} from '@/types';
import { v4 as uuidv4 } from 'uuid';

interface QueueItem {
  message: IMessage;
  attempts: number;
  addedAt: Date;
}

interface Subscriber {
  id: string;
  pattern?: string | RegExp;
  target?: string;
  handler: MessageHandler;
}

export class MessageQueue extends EventEmitter {
  private queue: Map<Priority, QueueItem[]> = new Map([
    ['urgent', []],
    ['high', []],
    ['medium', []],
    ['low', []]
  ]);
  
  private subscribers: Map<MessageType | string, Subscriber[]> = new Map();
  private patternSubscribers: Subscriber[] = [];
  private targetSubscribers: Map<string, Subscriber[]> = new Map();
  private deadLetterSubscribers: MessageHandler[] = [];
  
  private processing = false;
  private shuttingDown = false;
  private stats = {
    messagesPublished: 0,
    messagesDelivered: 0,
    messagesFailed: 0,
    messagesExpired: 0
  };

  constructor(
    private logger: ILogger,
    private config: {
      maxQueueSize: number;
      messageRetention: number;
      deadLetterRetries: number;
      deliveryTimeout: number;
    }
  ) {
    super();
    this.startProcessing();
    this.startCleanup();
  }

  async publish(message: IMessage): Promise<void> {
    if (this.shuttingDown) {
      throw new Error('Queue is shutting down');
    }

    // Check queue size
    const totalSize = Array.from(this.queue.values())
      .reduce((sum, items) => sum + items.length, 0);
    
    if (totalSize >= this.config.maxQueueSize) {
      throw new Error('Queue is full');
    }

    // Add to appropriate priority queue
    const priorityQueue = this.queue.get(message.priority)!;
    priorityQueue.push({
      message,
      attempts: 0,
      addedAt: new Date()
    });

    this.stats.messagesPublished++;
    
    this.logger.debug('Message published', {
      messageId: message.id,
      type: message.type,
      priority: message.priority
    });

    // Emit for immediate processing
    this.emit('message');
  }

  subscribe(
    messageType: MessageType,
    handler: MessageHandler
  ): ISubscription {
    const subscriber: Subscriber = {
      id: uuidv4(),
      handler
    };

    if (!this.subscribers.has(messageType)) {
      this.subscribers.set(messageType, []);
    }
    
    this.subscribers.get(messageType)!.push(subscriber);

    this.logger.debug('Subscribed to message type', {
      subscriberId: subscriber.id,
      messageType
    });

    return {
      id: subscriber.id,
      pattern: messageType,
      unsubscribe: () => this.unsubscribe(messageType, subscriber.id)
    };
  }

  subscribePattern(
    pattern: string | RegExp,
    handler: MessageHandler
  ): ISubscription {
    const subscriber: Subscriber = {
      id: uuidv4(),
      pattern,
      handler
    };

    this.patternSubscribers.push(subscriber);

    this.logger.debug('Subscribed to pattern', {
      subscriberId: subscriber.id,
      pattern: pattern.toString()
    });

    return {
      id: subscriber.id,
      pattern: pattern.toString(),
      unsubscribe: () => this.unsubscribePattern(subscriber.id)
    };
  }

  subscribeTarget(
    target: string,
    handler: MessageHandler
  ): ISubscription {
    const subscriber: Subscriber = {
      id: uuidv4(),
      target,
      handler
    };

    if (!this.targetSubscribers.has(target)) {
      this.targetSubscribers.set(target, []);
    }
    
    this.targetSubscribers.get(target)!.push(subscriber);

    this.logger.debug('Subscribed to target', {
      subscriberId: subscriber.id,
      target
    });

    return {
      id: subscriber.id,
      pattern: `target:${target}`,
      unsubscribe: () => this.unsubscribeTarget(target, subscriber.id)
    };
  }

  subscribeDeadLetter(handler: MessageHandler): void {
    this.deadLetterSubscribers.push(handler);
  }

  getStats(): IQueueStats {
    const queueDepth = Array.from(this.queue.values())
      .reduce((sum, items) => sum + items.length, 0);

    return {
      messagesPublished: this.stats.messagesPublished,
      messagesDelivered: this.stats.messagesDelivered,
      messagesFailed: this.stats.messagesFailed,
      activeSubscriptions: this.subscribers.size + 
        this.patternSubscribers.length + 
        this.targetSubscribers.size,
      queueDepth,
      deadLetterCount: this.stats.messagesFailed
    };
  }

  async shutdown(): Promise<void> {
    this.shuttingDown = true;
    
    this.logger.info('Shutting down message queue');
    
    // Stop processing
    this.removeAllListeners();
    
    // Clear queues
    this.queue.clear();
    this.subscribers.clear();
    this.patternSubscribers = [];
    this.targetSubscribers.clear();
    
    this.logger.info('Message queue shutdown complete');
  }

  private async startProcessing(): Promise<void> {
    this.on('message', async () => {
      if (!this.processing && !this.shuttingDown) {
        await this.processQueue();
      }
    });
  }

  private async processQueue(): Promise<void> {
    this.processing = true;

    try {
      // Process in priority order
      for (const priority of ['urgent', 'high', 'medium', 'low'] as Priority[]) {
        const items = this.queue.get(priority)!;
        
        while (items.length > 0 && !this.shuttingDown) {
          const item = items.shift()!;
          
          // Check if expired
          if (this.isExpired(item)) {
            this.stats.messagesExpired++;
            this.logger.warn('Message expired', {
              messageId: item.message.id,
              age: Date.now() - item.addedAt.getTime()
            });
            continue;
          }

          await this.deliverMessage(item);
        }
      }
    } finally {
      this.processing = false;
    }
  }

  private async deliverMessage(item: QueueItem): Promise<void> {
    const { message } = item;
    const handlers = this.getHandlers(message);

    if (handlers.length === 0) {
      this.logger.debug('No handlers for message', {
        messageId: message.id,
        type: message.type
      });
      return;
    }

    // Deliver to all handlers
    const deliveryPromises = handlers.map(handler =>
      this.deliverToHandler(message, handler, item)
    );

    await Promise.all(deliveryPromises);
  }

  private async deliverToHandler(
    message: IMessage,
    handler: MessageHandler,
    item: QueueItem
  ): Promise<void> {
    try {
      // Apply timeout
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Delivery timeout')), 
          this.config.deliveryTimeout);
      });

      await Promise.race([
        handler(message),
        timeoutPromise
      ]);

      this.stats.messagesDelivered++;
      
      this.logger.debug('Message delivered', {
        messageId: message.id,
        attempts: item.attempts + 1
      });
    } catch (error) {
      item.attempts++;
      
      if (item.attempts < this.config.deadLetterRetries) {
        // Retry
        this.logger.warn('Message delivery failed, retrying', {
          messageId: message.id,
          attempts: item.attempts,
          error: error.message
        });
        
        // Re-queue with same priority
        this.queue.get(message.priority)!.push(item);
        this.emit('message');
      } else {
        // Send to dead letter
        this.stats.messagesFailed++;
        
        this.logger.error('Message sent to dead letter queue', {
          messageId: message.id,
          attempts: item.attempts,
          error: error.message
        });
        
        await this.sendToDeadLetter(message);
      }
    }
  }

  private getHandlers(message: IMessage): MessageHandler[] {
    const handlers: MessageHandler[] = [];

    // Type subscribers
    const typeSubscribers = this.subscribers.get(message.type) || [];
    handlers.push(...typeSubscribers.map(s => s.handler));

    // Pattern subscribers
    for (const subscriber of this.patternSubscribers) {
      const pattern = subscriber.pattern!;
      const matches = typeof pattern === 'string'
        ? message.type.startsWith(pattern)
        : pattern.test(message.type);
      
      if (matches) {
        handlers.push(subscriber.handler);
      }
    }

    // Target subscribers
    if (message.target) {
      const targetSubscribers = this.targetSubscribers.get(message.target) || [];
      handlers.push(...targetSubscribers.map(s => s.handler));
    }

    return handlers;
  }

  private async sendToDeadLetter(message: IMessage): Promise<void> {
    for (const handler of this.deadLetterSubscribers) {
      try {
        await handler(message);
      } catch (error) {
        this.logger.error('Dead letter handler failed', {
          messageId: message.id,
          error
        });
      }
    }
  }

  private isExpired(item: QueueItem): boolean {
    const age = Date.now() - item.addedAt.getTime();
    return age > this.config.messageRetention;
  }

  private startCleanup(): void {
    setInterval(() => {
      if (!this.shuttingDown) {
        // Clean expired messages
        for (const items of this.queue.values()) {
          const beforeCount = items.length;
          const nonExpired = items.filter(item => !this.isExpired(item));
          
          if (nonExpired.length < beforeCount) {
            items.length = 0;
            items.push(...nonExpired);
            
            this.stats.messagesExpired += beforeCount - nonExpired.length;
          }
        }
      }
    }, 60000); // Every minute
  }

  private unsubscribe(messageType: MessageType, subscriberId: string): void {
    const subscribers = this.subscribers.get(messageType);
    if (subscribers) {
      const index = subscribers.findIndex(s => s.id === subscriberId);
      if (index !== -1) {
        subscribers.splice(index, 1);
      }
    }
  }

  private unsubscribePattern(subscriberId: string): void {
    const index = this.patternSubscribers.findIndex(s => s.id === subscriberId);
    if (index !== -1) {
      this.patternSubscribers.splice(index, 1);
    }
  }

  private unsubscribeTarget(target: string, subscriberId: string): void {
    const subscribers = this.targetSubscribers.get(target);
    if (subscribers) {
      const index = subscribers.findIndex(s => s.id === subscriberId);
      if (index !== -1) {
        subscribers.splice(index, 1);
      }
    }
  }
}
```

### 6.4 Message Broker Implementation

```typescript
// src/messaging/message-broker.ts
import { 
  ILogger,
  IMessage,
  MessageType,
  ITask,
  ITaskResult,
  MessageHandler
} from '@/types';
import { MessageQueue } from './message-queue';
import { v4 as uuidv4 } from 'uuid';

interface AgentRegistration {
  id: string;
  messageTypes: MessageType[];
  capabilities?: string[];
  handler: MessageHandler;
}

export class MessageBroker {
  private agents = new Map<string, AgentRegistration>();
  private capabilityIndex = new Map<string, Set<string>>();

  constructor(
    private logger: ILogger,
    private queue: MessageQueue
  ) {
    this.setupSystemHandlers();
  }

  registerAgent(
    agentId: string,
    config: {
      messageTypes: MessageType[];
      capabilities?: string[];
      handler: MessageHandler;
    }
  ): void {
    const registration: AgentRegistration = {
      id: agentId,
      ...config
    };

    this.agents.set(agentId, registration);

    // Index capabilities
    if (config.capabilities) {
      for (const capability of config.capabilities) {
        if (!this.capabilityIndex.has(capability)) {
          this.capabilityIndex.set(capability, new Set());
        }
        this.capabilityIndex.get(capability)!.add(agentId);
      }
    }

    // Subscribe to message types
    for (const messageType of config.messageTypes) {
      this.queue.subscribe(messageType, async (message) => {
        if (this.shouldHandleMessage(agentId, message)) {
          await config.handler(message);
        }
      });
    }

    // Subscribe to targeted messages
    this.queue.subscribeTarget(agentId, config.handler);

    this.logger.info('Agent registered', {
      agentId,
      capabilities: config.capabilities,
      messageTypes: config.messageTypes
    });
  }

  unregisterAgent(agentId: string): void {
    const registration = this.agents.get(agentId);
    if (!registration) return;

    // Remove from capability index
    if (registration.capabilities) {
      for (const capability of registration.capabilities) {
        const agents = this.capabilityIndex.get(capability);
        if (agents) {
          agents.delete(agentId);
          if (agents.size === 0) {
            this.capabilityIndex.delete(capability);
          }
        }
      }
    }

    this.agents.delete(agentId);

    this.logger.info('Agent unregistered', { agentId });
  }

  async sendTaskAssignment(
    targetAgent: string,
    task: ITask
  ): Promise<void> {
    const message: IMessage<{ task: ITask }> = {
      id: uuidv4(),
      type: MessageType.TASK_ASSIGNMENT,
      source: 'orchestrator',
      target: targetAgent,
      timestamp: new Date(),
      priority: task.priority,
      payload: { task }
    };

    await this.queue.publish(message);
  }

  async sendTaskCompleted(
    sourceAgent: string,
    targetAgent: string,
    result: ITaskResult
  ): Promise<void> {
    const message: IMessage<ITaskResult> = {
      id: uuidv4(),
      type: MessageType.TASK_COMPLETED,
      source: sourceAgent,
      target: targetAgent,
      timestamp: new Date(),
      priority: 'medium',
      payload: result
    };

    await this.queue.publish(message);
  }

  async broadcastHelpRequest(
    sourceAgent: string,
    request: {
      type: string;
      description: string;
      context?: any;
    }
  ): Promise<void> {
    const message: IMessage = {
      id: uuidv4(),
      type: MessageType.HELP_REQUEST,
      source: sourceAgent,
      timestamp: new Date(),
      priority: 'high',
      payload: request
    };

    await this.queue.publish(message);
  }

  async shareKnowledge(
    sourceAgent: string,
    knowledge: {
      topic: string;
      content: string;
      tags?: string[];
    }
  ): Promise<void> {
    const message: IMessage = {
      id: uuidv4(),
      type: MessageType.KNOWLEDGE_SHARE,
      source: sourceAgent,
      timestamp: new Date(),
      priority: 'low',
      payload: knowledge
    };

    await this.queue.publish(message);
  }

  async broadcastSystemEvent(
    eventType: MessageType,
    payload: any
  ): Promise<void> {
    const message: IMessage = {
      id: uuidv4(),
      type: eventType,
      source: 'system',
      timestamp: new Date(),
      priority: 'urgent',
      payload
    };

    await this.queue.publish(message);
  }

  findAgentsWithCapability(capability: string): string[] {
    const agents = this.capabilityIndex.get(capability);
    return agents ? Array.from(agents) : [];
  }

  getAgentInfo(agentId: string): AgentRegistration | undefined {
    return this.agents.get(agentId);
  }

  getAllAgents(): string[] {
    return Array.from(this.agents.keys());
  }

  private shouldHandleMessage(
    agentId: string,
    message: IMessage
  ): boolean {
    // Skip if specifically targeted to another agent
    if (message.target && message.target !== agentId) {
      return false;
    }

    // Skip if from self (prevent loops)
    if (message.source === agentId) {
      return false;
    }

    return true;
  }

  private setupSystemHandlers(): void {
    // Monitor agent health
    this.queue.subscribe(MessageType.AGENT_HEARTBEAT, async (message) => {
      this.logger.debug('Agent heartbeat received', {
        agentId: message.source,
        timestamp: message.timestamp
      });
    });

    // Handle agent errors
    this.queue.subscribe(MessageType.AGENT_ERROR, async (message) => {
      this.logger.error('Agent error reported', {
        agentId: message.source,
        error: message.payload
      });
    });

    // Track metrics
    this.queue.subscribe(MessageType.AGENT_METRICS, async (message) => {
      this.logger.info('Agent metrics received', {
        agentId: message.source,
        metrics: message.payload
      });
    });
  }
}
```

### 6.5 Collaboration Manager

```typescript
// src/messaging/collaboration-manager.ts
import { ILogger, MessageType, IMessage } from '@/types';
import { MessageBroker } from './message-broker';
import { MessageQueue } from './message-queue';

interface CollaborationSession {
  id: string;
  participants: string[];
  topic: string;
  startedAt: Date;
  messages: IMessage[];
}

export class CollaborationManager {
  private sessions = new Map<string, CollaborationSession>();
  private agentSessions = new Map<string, Set<string>>();

  constructor(
    private logger: ILogger,
    private broker: MessageBroker,
    private queue: MessageQueue
  ) {
    this.setupHandlers();
  }

  async startCollaboration(
    initiator: string,
    participants: string[],
    topic: string
  ): Promise<string> {
    const sessionId = `collab_${Date.now()}`;
    
    const session: CollaborationSession = {
      id: sessionId,
      participants: [initiator, ...participants],
      topic,
      startedAt: new Date(),
      messages: []
    };

    this.sessions.set(sessionId, session);

    // Track sessions by agent
    for (const agent of session.participants) {
      if (!this.agentSessions.has(agent)) {
        this.agentSessions.set(agent, new Set());
      }
      this.agentSessions.get(agent)!.add(sessionId);
    }

    // Notify participants
    for (const participant of participants) {
      await this.queue.publish({
        id: `${sessionId}_invite`,
        type: MessageType.HELP_OFFER,
        source: initiator,
        target: participant,
        timestamp: new Date(),
        priority: 'high',
        payload: {
          sessionId,
          topic,
          initiator
        }
      });
    }

    this.logger.info('Collaboration session started', {
      sessionId,
      initiator,
      participants,
      topic
    });

    return sessionId;
  }

  async sendCollaborationMessage(
    sessionId: string,
    sender: string,
    content: any
  ): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    if (!session.participants.includes(sender)) {
      throw new Error('Sender not in session');
    }

    const message: IMessage = {
      id: `${sessionId}_msg_${Date.now()}`,
      type: MessageType.KNOWLEDGE_SHARE,
      source: sender,
      timestamp: new Date(),
      priority: 'medium',
      payload: {
        sessionId,
        content
      }
    };

    session.messages.push(message);

    // Broadcast to other participants
    for (const participant of session.participants) {
      if (participant !== sender) {
        await this.queue.publish({
          ...message,
          target: participant
        });
      }
    }
  }

  async endCollaboration(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    // Clean up tracking
    for (const agent of session.participants) {
      const sessions = this.agentSessions.get(agent);
      if (sessions) {
        sessions.delete(sessionId);
        if (sessions.size === 0) {
          this.agentSessions.delete(agent);
        }
      }
    }

    this.sessions.delete(sessionId);

    this.logger.info('Collaboration session ended', {
      sessionId,
      duration: Date.now() - session.startedAt.getTime(),
      messageCount: session.messages.length
    });
  }

  getAgentSessions(agentId: string): CollaborationSession[] {
    const sessionIds = this.agentSessions.get(agentId);
    if (!sessionIds) return [];

    return Array.from(sessionIds)
      .map(id => this.sessions.get(id))
      .filter((session): session is CollaborationSession => session !== undefined);
  }

  private setupHandlers(): void {
    // Handle collaboration requests
    this.queue.subscribe(MessageType.HELP_REQUEST, async (message) => {
      const request = message.payload;
      const helpers = this.broker.findAgentsWithCapability(request.type);

      if (helpers.length > 0) {
        await this.startCollaboration(
          message.source,
          helpers.slice(0, 2), // Limit to 2 helpers
          request.description
        );
      }
    });

    // Handle conflict notifications
    this.queue.subscribe(MessageType.CONFLICT_DETECTED, async (message) => {
      const conflict = message.payload;
      
      // Start collaboration between conflicting agents
      if (conflict.agents && conflict.agents.length > 1) {
        await this.startCollaboration(
          'system',
          conflict.agents,
          `Resolve conflict in ${conflict.files.join(', ')}`
        );
      }
    });
  }
}
```

### 6.6 Integration Tests

```typescript
// src/messaging/__tests__/messaging-integration.spec.ts
import { MessageQueue } from '../message-queue';
import { MessageBroker } from '../message-broker';
import { CollaborationManager } from '../collaboration-manager';
import { createLogger } from '@/utils/logger';
import { MessageType } from '@/types';

describe('Messaging System Integration', () => {
  let queue: MessageQueue;
  let broker: MessageBroker;
  let collaborationManager: CollaborationManager;
  let logger: ILogger;

  beforeEach(() => {
    logger = createLogger({ level: 'debug' });
    
    queue = new MessageQueue(logger, {
      maxQueueSize: 1000,
      messageRetention: 300000,
      deadLetterRetries: 3,
      deliveryTimeout: 30000
    });

    broker = new MessageBroker(logger, queue);
    collaborationManager = new CollaborationManager(logger, broker, queue);
  });

  afterEach(async () => {
    await queue.shutdown();
  });

  it('should coordinate task execution between agents', async () => {
    // Setup agents
    const orchestratorTasks: any[] = [];
    const workerResults: any[] = [];

    broker.registerAgent('orchestrator', {
      messageTypes: [MessageType.TASK_COMPLETED],
      handler: async (msg) => {
        orchestratorTasks.push(msg.payload);
      }
    });

    broker.registerAgent('worker-1', {
      messageTypes: [MessageType.TASK_ASSIGNMENT],
      capabilities: ['research', 'analysis'],
      handler: async (msg) => {
        // Simulate work
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Send completion
        await broker.sendTaskCompleted('worker-1', 'orchestrator', {
          taskId: msg.payload.task.id,
          status: 'completed',
          result: 'Research complete',
          metrics: {
            duration_ms: 100,
            cost_usd: 0.01,
            turns_used: 1
          },
          completedAt: new Date()
        });
      }
    });

    // Send task
    await broker.sendTaskAssignment('worker-1', {
      id: 'task-123',
      type: 'research',
      priority: 'high',
      status: 'pending',
      description: 'Research topic X',
      createdAt: new Date()
    });

    // Wait for completion
    await TestHelpers.waitFor(() => orchestratorTasks.length === 1);

    expect(orchestratorTasks[0]).toMatchObject({
      taskId: 'task-123',
      status: 'completed',
      result: 'Research complete'
    });
  });

  it('should facilitate agent collaboration', async () => {
    const expertMessages: any[] = [];
    const learnerMessages: any[] = [];

    broker.registerAgent('expert', {
      messageTypes: [MessageType.HELP_REQUEST],
      capabilities: ['debugging'],
      handler: async (msg) => {
        if (msg.payload.type === 'debugging') {
          await queue.publish({
            id: 'help-response',
            type: MessageType.HELP_OFFER,
            source: 'expert',
            target: msg.source,
            timestamp: new Date(),
            priority: 'high',
            payload: {
              suggestion: 'Check async timing'
            }
          });
        }
      }
    });

    broker.registerAgent('learner', {
      messageTypes: [MessageType.HELP_OFFER],
      handler: async (msg) => {
        learnerMessages.push(msg.payload);
      }
    });

    // Request help
    await broker.broadcastHelpRequest('learner', {
      type: 'debugging',
      description: 'Async function not working',
      context: { file: 'async.ts' }
    });

    // Wait for response
    await TestHelpers.waitFor(() => learnerMessages.length === 1);

    expect(learnerMessages[0]).toMatchObject({
      suggestion: 'Check async timing'
    });
  });

  it('should handle system-wide events', async () => {
    const agentStates: Record<string, string[]> = {
      'agent-1': [],
      'agent-2': [],
      'agent-3': []
    };

    // Register agents
    for (const agentId of Object.keys(agentStates)) {
      broker.registerAgent(agentId, {
        messageTypes: [MessageType.SYSTEM_PAUSE, MessageType.SYSTEM_RESUME],
        handler: async (msg) => {
          agentStates[agentId].push(msg.type);
        }
      });
    }

    // Send system pause
    await broker.broadcastSystemEvent(MessageType.SYSTEM_PAUSE, {
      reason: 'Maintenance'
    });

    await TestHelpers.waitFor(() => 
      Object.values(agentStates).every(states => states.length === 1)
    );

    // Send system resume
    await broker.broadcastSystemEvent(MessageType.SYSTEM_RESUME, {});

    await TestHelpers.waitFor(() => 
      Object.values(agentStates).every(states => states.length === 2)
    );

    // Verify all agents received both events
    for (const states of Object.values(agentStates)) {
      expect(states).toEqual([
        MessageType.SYSTEM_PAUSE,
        MessageType.SYSTEM_RESUME
      ]);
    }
  });
});
```

## Success Criteria
- ✅ 100% test coverage maintained
- ✅ Message queue with priority handling
- ✅ Reliable message delivery
- ✅ Dead letter queue for failures
- ✅ Pattern and target subscriptions
- ✅ Collaboration facilitation
- ✅ System event coordination

## Next Steps
- Proceed to Step 7: Base Agent Implementation
- Integrate messaging with agent communication
- Monitor message throughput and latency