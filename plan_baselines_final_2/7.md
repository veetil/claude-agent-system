# Step 7: Documentation, Examples, and Packaging

## Overview
Finalize the Claude Multi-Agent System with comprehensive documentation, practical examples, packaging for distribution, and integration tests to ensure production readiness.

## Objectives
1. Create comprehensive user and developer documentation
2. Build practical examples demonstrating key use cases
3. Set up packaging and distribution (PyPI)
4. Implement end-to-end integration tests
5. Create quick start guide and tutorials

## Implementation Tasks

### 1. Project README
```markdown
# README.md

# Claude Multi-Agent System

A powerful orchestration framework for managing multiple Claude AI agents with built-in session management, workspace isolation, and flexible workflow patterns.

## Features

- ðŸ¤– **Multi-Agent Orchestration** - Manage multiple specialized Claude agents
- ðŸ’¾ **Session Persistence** - Maintain conversation context across interactions
- ðŸ“ **Workspace Isolation** - Each agent has its own isolated workspace
- ðŸ”„ **Workflow Patterns** - Sequential, parallel, pipeline, and hierarchical execution
- ðŸ› ï¸ **CLI & API** - Both command-line and programmatic interfaces
- ðŸ“Š **Rich Output** - Beautiful terminal output with progress indicators
- ðŸ”§ **Configurable** - YAML/JSON configuration with environment overrides
- ðŸš€ **Production Ready** - Comprehensive error handling and logging

## Quick Start

### Installation

```bash
# Install from PyPI
pip install claude-multi-agent

# Or install from source
git clone https://github.com/yourusername/claude-multi-agent
cd claude-multi-agent
pip install -e .
```

### Prerequisites

- Claude CLI installed: `npm install -g @anthropic-ai/claude-code`
- Python 3.8+
- Valid Anthropic API key set in environment

### Basic Usage

```bash
# Create an agent
claude-agents agent create researcher "You are a research assistant"

# Ask the agent
claude-agents agent ask researcher "What are the benefits of async programming?"

# Run a workflow
claude-agents workflow template research "Latest AI developments"

# Start interactive mode
claude-agents interactive
```

### Python API

```python
import asyncio
from claude_multi_agent import Orchestrator, AgentConfig

async def main():
    # Initialize orchestrator
    orchestrator = Orchestrator()
    
    # Create agents
    await orchestrator.create_agent(
        "researcher",
        "You are a research specialist"
    )
    
    # Run workflow
    result = await orchestrator.send_task(
        "researcher",
        "Explain quantum computing"
    )
    
    print(result)

asyncio.run(main())
```

## Documentation

- [User Guide](docs/user-guide.md)
- [API Reference](docs/api-reference.md)
- [Configuration Guide](docs/configuration.md)
- [Workflow Patterns](docs/workflows.md)
- [Examples](examples/)

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

## License

MIT License - see [LICENSE](LICENSE) for details.
```

### 2. User Guide
```markdown
# docs/user-guide.md

# Claude Multi-Agent System User Guide

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Basic Concepts](#basic-concepts)
4. [Creating Agents](#creating-agents)
5. [Workflows](#workflows)
6. [Configuration](#configuration)
7. [Best Practices](#best-practices)
8. [Troubleshooting](#troubleshooting)

## Introduction

The Claude Multi-Agent System enables you to orchestrate multiple Claude AI agents, each with specialized roles and capabilities. This guide will walk you through everything you need to know.

## Installation

### System Requirements

- Python 3.8 or higher
- macOS, Linux, or Windows with WSL2
- Node.js 16+ (for Claude CLI)
- 4GB+ RAM recommended

### Install Claude CLI

First, install the Claude CLI globally:

```bash
npm install -g @anthropic-ai/claude-code
```

Verify installation:

```bash
claude --version
```

### Install Multi-Agent System

```bash
pip install claude-multi-agent
```

### Set API Key

```bash
export ANTHROPIC_API_KEY="your-api-key-here"
```

## Basic Concepts

### Agents

An agent is an instance of Claude with:
- Unique ID
- System prompt defining its role
- Isolated workspace
- Persistent session history

### Sessions

Sessions maintain conversation context:
- Each interaction creates a new session ID
- Sessions are chained for continuity
- Full history preserved in `.claude/projects/`

### Workflows

Workflows coordinate multiple agents:
- **Sequential**: One agent after another
- **Parallel**: Multiple agents simultaneously
- **Pipeline**: Data transformation chain
- **Hierarchical**: Manager delegating to workers

## Creating Agents

### Via CLI

```bash
# Basic agent
claude-agents agent create helper "You are a helpful assistant"

# Specialized agent with tools
claude-agents agent create developer \
  "You are a Python developer" \
  --tools read_file write_file \
  --max-turns 3
```

### Via Python API

```python
from claude_multi_agent import Orchestrator

orchestrator = Orchestrator()

# Create agent
agent = await orchestrator.create_agent(
    agent_id="analyst",
    system_prompt="You are a data analyst",
    allowed_tools=["read_file", "execute_command"],
    max_turns=2
)
```

### Agent Templates

```python
from claude_multi_agent import AgentFactory

# Pre-configured agents
researcher = AgentFactory.create_researcher()
developer = AgentFactory.create_developer()
analyst = AgentFactory.create_analyst()
```

## Workflows

### Sequential Workflow

Process task through agents in order:

```bash
claude-agents workflow run agent1 agent2 agent3 \
  "Analyze this data" \
  --pattern sequential
```

### Parallel Workflow

Get perspectives from multiple agents:

```bash
claude-agents workflow run expert1 expert2 expert3 \
  "Evaluate this proposal" \
  --pattern parallel
```

### Pipeline Workflow

Transform data through stages:

```python
stages = [
    {"agent": "preprocessor"},
    {"agent": "analyzer"},
    {"agent": "reporter"}
]

result = await orchestrator.pipeline(stages, raw_data)
```

### Workflow Templates

Use pre-built workflows:

```bash
# Research workflow
claude-agents workflow template research \
  "Impact of climate change on agriculture"

# Code review workflow
claude-agents workflow template code-review \
  "$(cat main.py)"

# Brainstorming workflow
claude-agents workflow template brainstorm \
  "New features for task management app"
```

## Configuration

### Configuration File

Create `claude-agents.yaml`:

```yaml
orchestrator:
  base_dir: ./workspaces
  max_agents: 10
  session_persistence: true

agent_defaults:
  max_turns: 2
  timeout: 300
  retry_attempts: 3

logging:
  level: INFO
  file: ./claude-agents.log

agents:
  - id: researcher
    system_prompt: "You are a research specialist"
    allowed_tools: ["web_search"]
    
  - id: writer
    system_prompt: "You are a technical writer"
    max_turns: 3
```

### Environment Variables

```bash
export CLAUDE_AGENTS_BASE_DIR=/var/claude-agents
export CLAUDE_AGENTS_MAX_AGENTS=20
export CLAUDE_AGENTS_LOG_LEVEL=DEBUG
```

### Priority Order

1. Command line arguments
2. Environment variables
3. Configuration file
4. Default values

## Best Practices

### Agent Design

1. **Single Responsibility**: Each agent should have one clear role
2. **Clear Prompts**: Be specific about agent capabilities
3. **Tool Selection**: Only grant necessary tools
4. **Session Management**: Let agents maintain context naturally

### Workflow Design

1. **Start Simple**: Test with sequential before complex patterns
2. **Error Handling**: Plan for agent failures
3. **Data Flow**: Consider how information passes between agents
4. **Validation**: Add verification steps in workflows

### Performance

1. **Concurrent Limits**: Don't exceed API rate limits
2. **Workspace Cleanup**: Regularly clean old workspaces
3. **Session Pruning**: Archive old sessions periodically
4. **Resource Monitoring**: Track memory and disk usage

## Troubleshooting

### Common Issues

#### "No conversation found with session ID"

**Cause**: Session doesn't exist or wrong working directory
**Solution**: Ensure agent runs from consistent directory

#### "Rate limit exceeded"

**Cause**: Too many API calls
**Solution**: Reduce concurrent agents or add delays

#### "Shell not found"

**Cause**: Shell path incorrect
**Solution**: Verify `$SHELL` environment variable

### Debug Mode

Enable detailed logging:

```bash
claude-agents --log-level DEBUG agent ask researcher "test"
```

### Session Inspection

Check session files:

```bash
ls ~/.claude/projects/*/
cat ~/.claude/projects/agent_researcher/*.jsonl | jq
```

## Advanced Topics

See [Advanced Guide](advanced-guide.md) for:
- Custom workflow patterns
- Plugin development
- Distributed deployment
- Performance optimization
```

### 3. API Reference
```markdown
# docs/api-reference.md

# API Reference

## Core Classes

### Orchestrator

Main orchestration class for managing agents and workflows.

```python
class Orchestrator:
    def __init__(
        self,
        base_dir: Optional[Path] = None,
        max_agents: int = 10
    )
```

#### Methods

##### create_agent

Create and register a new agent.

```python
async def create_agent(
    self,
    agent_id: str,
    system_prompt: str,
    allowed_tools: Optional[List[str]] = None,
    max_turns: int = 1
) -> Agent
```

**Parameters:**
- `agent_id`: Unique identifier for the agent
- `system_prompt`: System prompt defining agent's role
- `allowed_tools`: List of allowed tool names
- `max_turns`: Maximum conversation turns

**Returns:** Created Agent instance

##### send_task

Send a task to a specific agent.

```python
async def send_task(
    self,
    agent_id: str,
    task: Union[str, TaskInput]
) -> str
```

##### sequential

Execute task sequentially through agents.

```python
async def sequential(
    self,
    agents: List[str],
    task: str,
    transform_fn: Optional[Callable[[str], str]] = None
) -> WorkflowResult
```

### Agent

Individual Claude agent with session management.

```python
class Agent:
    def __init__(
        self,
        config: AgentConfig,
        workspace_manager: Optional[WorkspaceManager] = None,
        shell_executor: Optional[ShellExecutor] = None
    )
```

#### Methods

##### ask

Send prompt to agent and get response.

```python
async def ask(
    self,
    prompt: str,
    max_retries: int = 3,
    include_system_prompt: Optional[bool] = None
) -> str
```

##### get_metrics

Get agent performance metrics.

```python
def get_metrics(self) -> Dict[str, Any]
```

**Returns:**
```python
{
    "agent_id": str,
    "status": str,
    "total_interactions": int,
    "total_tokens": int,
    "uptime_seconds": float,
    "current_session": Optional[str],
    "session_count": int
}
```

### AgentFactory

Factory for creating pre-configured agents.

```python
class AgentFactory:
    @staticmethod
    def create_researcher() -> Agent
    
    @staticmethod
    def create_developer() -> Agent
    
    @staticmethod
    def create_analyst() -> Agent
```

## Data Types

### AgentConfig

```python
@dataclass
class AgentConfig:
    id: str
    system_prompt: str
    working_dir: Path
    allowed_tools: Optional[List[str]] = None
    max_turns: int = 1
```

### TaskInput

```python
@dataclass
class TaskInput:
    prompt: str
    text_input: Optional[str] = None
    folders: Optional[List[FolderMapping]] = None
    repos: Optional[List[GitHubRepo]] = None
    files: Optional[List[FileMapping]] = None
```

### WorkflowResult

```python
@dataclass
class WorkflowResult:
    pattern: WorkflowPattern
    agents: List[str]
    results: Dict[str, Any]
    metadata: Dict[str, Any]
    success: bool
    errors: List[str]
```

## Workflow Templates

### ResearchWorkflow

Research workflow with three stages.

```python
workflow = ResearchWorkflow(orchestrator)
await workflow.setup()
result = await workflow.execute("Research topic")
```

### CodeReviewWorkflow

Parallel code review with aggregation.

```python
workflow = CodeReviewWorkflow(orchestrator)
await workflow.setup()
result = await workflow.execute(code_string)
```

## Exceptions

### ClaudeAgentError

Base exception for all agent errors.

```python
class ClaudeAgentError(Exception):
    pass
```

### Specific Exceptions

- `ClaudeExecutionError`: CLI execution failed
- `JSONParseError`: Response parsing failed
- `SessionNotFoundError`: Session ID invalid
- `WorkspaceError`: Workspace operation failed

## Configuration

### SystemConfig Schema

```python
class SystemConfig:
    orchestrator: OrchestratorConfig
    agent_defaults: AgentDefaults
    logging: LoggingConfig
    agents: List[Dict[str, Any]]
    workflows: List[Dict[str, Any]]
```

See [Configuration Guide](configuration.md) for details.
```

### 4. Practical Examples
```python
# examples/research_assistant.py
"""
Research Assistant Example

Demonstrates a research workflow that:
1. Researches a topic
2. Analyzes findings
3. Writes a report
"""

import asyncio
from claude_multi_agent import Orchestrator

async def research_topic(topic: str):
    # Initialize system
    orchestrator = Orchestrator()
    
    # Create specialized agents
    print("Creating research team...")
    
    await orchestrator.create_agent(
        "researcher",
        """You are a research specialist. Your role is to:
        - Find comprehensive information on topics
        - Identify key sources and references
        - Extract important facts and figures
        - Note controversies or debates"""
    )
    
    await orchestrator.create_agent(
        "analyst",
        """You are an analytical expert. Your role is to:
        - Analyze research findings for patterns
        - Identify key insights and implications
        - Evaluate quality of sources
        - Synthesize multiple viewpoints"""
    )
    
    await orchestrator.create_agent(
        "writer",
        """You are a technical writer. Your role is to:
        - Create clear, well-structured reports
        - Use appropriate headings and formatting
        - Include executive summary
        - Cite sources properly"""
    )
    
    # Execute research workflow
    print(f"\nResearching: {topic}")
    print("-" * 50)
    
    # Stage 1: Research
    print("\nðŸ“š Research Phase...")
    research_prompt = f"""
    Research the following topic comprehensively:
    {topic}
    
    Include:
    - Current state and trends
    - Key players and technologies
    - Recent developments
    - Future outlook
    - Credible sources
    """
    
    research_results = await orchestrator.send_task("researcher", research_prompt)
    print("âœ“ Research complete")
    
    # Stage 2: Analysis
    print("\nðŸ” Analysis Phase...")
    analysis_prompt = f"""
    Analyze these research findings:
    
    {research_results}
    
    Provide:
    - Key insights and patterns
    - Critical evaluation
    - Implications and significance
    - Areas needing more research
    """
    
    analysis_results = await orchestrator.send_task("analyst", analysis_prompt)
    print("âœ“ Analysis complete")
    
    # Stage 3: Report Writing
    print("\nðŸ“ Writing Phase...")
    writing_prompt = f"""
    Create a comprehensive report based on:
    
    Research Findings:
    {research_results}
    
    Analysis:
    {analysis_results}
    
    Structure the report with:
    - Executive Summary
    - Introduction
    - Main Findings (with subsections)
    - Analysis and Implications
    - Conclusion
    - References
    """
    
    final_report = await orchestrator.send_task("writer", writing_prompt)
    print("âœ“ Report complete")
    
    # Save report
    with open(f"research_report_{topic.replace(' ', '_')}.md", 'w') as f:
        f.write(final_report)
    
    print(f"\nâœ… Research complete! Report saved to research_report_{topic.replace(' ', '_')}.md")
    
    # Cleanup
    await orchestrator.cleanup_all()
    
    return final_report

if __name__ == "__main__":
    topic = input("Enter research topic: ")
    asyncio.run(research_topic(topic))
```

```python
# examples/code_review_team.py
"""
Code Review Team Example

Demonstrates parallel code review with multiple specialized reviewers.
"""

import asyncio
from pathlib import Path
from claude_multi_agent import Orchestrator

async def review_code(file_path: str):
    # Load code
    code = Path(file_path).read_text()
    
    # Initialize system
    orchestrator = Orchestrator()
    
    # Create review team
    print("Assembling code review team...")
    
    reviewers = [
        ("security_reviewer", """You are a security expert. Review code for:
         - SQL injection vulnerabilities
         - XSS vulnerabilities  
         - Authentication/authorization issues
         - Data exposure risks
         - Cryptographic weaknesses"""),
         
        ("performance_reviewer", """You are a performance expert. Review code for:
         - Algorithm efficiency
         - Memory usage patterns
         - Database query optimization
         - Caching opportunities
         - Scalability concerns"""),
         
        ("quality_reviewer", """You are a code quality expert. Review for:
         - Code organization and structure
         - Naming conventions
         - Documentation completeness
         - Test coverage
         - SOLID principles adherence"""),
         
        ("accessibility_reviewer", """You are an accessibility expert. Review for:
         - WCAG compliance
         - Keyboard navigation
         - Screen reader compatibility
         - Color contrast issues
         - Alternative text for media""")
    ]
    
    for reviewer_id, prompt in reviewers:
        await orchestrator.create_agent(reviewer_id, prompt)
    
    # Create lead reviewer
    await orchestrator.create_agent(
        "lead_reviewer",
        """You are a lead developer. Synthesize all review feedback into:
        - Priority issues that must be fixed
        - Recommended improvements
        - Positive aspects to maintain
        - Overall code quality assessment"""
    )
    
    # Parallel review
    print(f"\nðŸ” Reviewing: {file_path}")
    print("-" * 50)
    
    review_prompt = f"""
    Review this code thoroughly according to your expertise:
    
    File: {file_path}
    
    ```python
    {code}
    ```
    
    Provide specific, actionable feedback with line numbers where applicable.
    """
    
    # Get all reviews in parallel
    print("\nâš¡ Running parallel reviews...")
    review_results = await orchestrator.parallel(
        [r[0] for r in reviewers],
        review_prompt
    )
    
    if not review_results.success:
        print("âŒ Some reviews failed:", review_results.errors)
        return
    
    print("âœ“ All reviews complete")
    
    # Synthesize results
    print("\nðŸ“‹ Synthesizing feedback...")
    
    synthesis_prompt = f"""
    Synthesize these code reviews into a final assessment:
    
    Security Review:
    {review_results.results['security_reviewer']}
    
    Performance Review:
    {review_results.results['performance_reviewer']}
    
    Code Quality Review:
    {review_results.results['quality_reviewer']}
    
    Accessibility Review:
    {review_results.results['accessibility_reviewer']}
    
    Create a prioritized action plan with:
    1. Critical issues (must fix)
    2. Important improvements (should fix)
    3. Nice to have enhancements
    4. Positive aspects to preserve
    """
    
    final_assessment = await orchestrator.send_task(
        "lead_reviewer",
        synthesis_prompt
    )
    
    # Save results
    output_file = f"code_review_{Path(file_path).stem}.md"
    with open(output_file, 'w') as f:
        f.write(f"# Code Review: {file_path}\n\n")
        f.write(final_assessment)
        f.write("\n\n## Individual Reviews\n\n")
        
        for reviewer_id, _ in reviewers:
            f.write(f"### {reviewer_id.replace('_', ' ').title()}\n\n")
            f.write(review_results.results[reviewer_id])
            f.write("\n\n")
    
    print(f"\nâœ… Review complete! Results saved to {output_file}")
    
    # Cleanup
    await orchestrator.cleanup_all()
    
    return final_assessment

if __name__ == "__main__":
    file_path = input("Enter Python file path to review: ")
    asyncio.run(review_code(file_path))
```

### 5. Setup and Packaging
```python
# setup.py
from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

setup(
    name="claude-multi-agent",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="Multi-agent orchestration system for Claude AI",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/claude-multi-agent",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ],
    python_requires=">=3.8",
    install_requires=[
        "asyncio>=3.4.3",
        "click>=8.0.0",
        "rich>=10.0.0",
        "pydantic>=2.0.0",
        "pyyaml>=6.0",
        "prompt-toolkit>=3.0.0",
        "python-dotenv>=1.0.0",
    ],
    extras_require={
        "dev": [
            "pytest>=7.0.0",
            "pytest-asyncio>=0.21.0",
            "pytest-cov>=4.0.0",
            "black>=23.0.0",
            "isort>=5.12.0",
            "flake8>=6.0.0",
            "mypy>=1.0.0",
            "pre-commit>=3.0.0",
        ],
    },
    entry_points={
        "console_scripts": [
            "claude-agents=claude_multi_agent.cli.app:main",
        ],
    },
    include_package_data=True,
    package_data={
        "claude_multi_agent": ["templates/*.yaml", "templates/*.json"],
    },
)
```

```toml
# pyproject.toml
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools_scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "claude-multi-agent"
dynamic = ["version"]
description = "Multi-agent orchestration system for Claude AI"
readme = "README.md"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "your.email@example.com"},
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
]
dependencies = [
    "asyncio>=3.4.3",
    "click>=8.0.0",
    "rich>=10.0.0",
    "pydantic>=2.0.0",
    "pyyaml>=6.0",
    "prompt-toolkit>=3.0.0",
    "python-dotenv>=1.0.0",
]
requires-python = ">=3.8"

[project.urls]
"Homepage" = "https://github.com/yourusername/claude-multi-agent"
"Bug Tracker" = "https://github.com/yourusername/claude-multi-agent/issues"
"Documentation" = "https://claude-multi-agent.readthedocs.io"

[project.scripts]
claude-agents = "claude_multi_agent.cli.app:main"

[tool.setuptools.packages.find]
where = ["src"]

[tool.black]
line-length = 88
target-version = ['py38']

[tool.isort]
profile = "black"
line_length = 88

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
asyncio_mode = "auto"

[tool.coverage.run]
source = ["src"]
omit = ["*/tests/*", "*/test_*"]

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true
```

### 6. End-to-End Tests
```python
# tests/e2e/test_full_system.py
import pytest
import asyncio
import tempfile
from pathlib import Path

from claude_multi_agent import Orchestrator, AgentFactory
from claude_multi_agent.orchestrator.templates import ResearchWorkflow

@pytest.mark.e2e
class TestFullSystem:
    
    @pytest.mark.asyncio
    async def test_complete_research_workflow(self, tmp_path):
        """Test complete research workflow end-to-end"""
        # Initialize system
        orchestrator = Orchestrator(base_dir=tmp_path)
        
        # Setup research workflow
        workflow = ResearchWorkflow(orchestrator)
        await workflow.setup()
        
        # Execute workflow
        result = await workflow.execute("Benefits of test-driven development")
        
        # Verify results
        assert result.success
        assert len(result.agents) == 3
        assert "researcher" in result.agents
        assert "analyst" in result.agents
        assert "writer" in result.agents
        
        # Check final output
        final_output = result.metadata.get("final_output", "")
        assert len(final_output) > 100
        assert "test" in final_output.lower()
        
        # Verify session persistence
        researcher = await orchestrator.get_agent("researcher")
        history = researcher.get_session_history()
        assert len(history) > 0
        
        # Cleanup
        await orchestrator.cleanup_all()
        
    @pytest.mark.asyncio
    async def test_error_recovery(self, tmp_path):
        """Test system recovery from errors"""
        orchestrator = Orchestrator(base_dir=tmp_path)
        
        # Create agent
        await orchestrator.create_agent(
            "test_agent",
            "You are a test agent"
        )
        
        # Simulate error by asking with very long prompt
        very_long_prompt = "x" * 100000  # Exceeds limits
        
        try:
            await orchestrator.send_task("test_agent", very_long_prompt)
        except Exception as e:
            # Should handle gracefully
            assert "test_agent" in orchestrator.agents
            agent = await orchestrator.get_agent("test_agent")
            assert agent.status.value == "idle"  # Reset after error
            
        # Agent should still work
        response = await orchestrator.send_task("test_agent", "Hello")
        assert response
        
        await orchestrator.cleanup_all()
        
    @pytest.mark.asyncio
    async def test_concurrent_workflows(self, tmp_path):
        """Test multiple workflows running concurrently"""
        orchestrator = Orchestrator(base_dir=tmp_path)
        
        # Create agents
        for i in range(6):
            await orchestrator.create_agent(
                f"agent_{i}",
                f"You are agent {i}"
            )
            
        # Define concurrent workflows
        async def workflow1():
            return await orchestrator.sequential(
                ["agent_0", "agent_1"],
                "Task 1"
            )
            
        async def workflow2():
            return await orchestrator.parallel(
                ["agent_2", "agent_3"],
                "Task 2"
            )
            
        async def workflow3():
            return await orchestrator.sequential(
                ["agent_4", "agent_5"],
                "Task 3"
            )
            
        # Run concurrently
        results = await asyncio.gather(
            workflow1(),
            workflow2(),
            workflow3()
        )
        
        # Verify all succeeded
        assert all(r.success for r in results)
        assert len(results) == 3
        
        await orchestrator.cleanup_all()
```

### 7. Quick Start Tutorial
```markdown
# docs/quickstart.md

# Quick Start Tutorial

This tutorial will get you up and running with Claude Multi-Agent System in 10 minutes.

## 1. Installation (2 minutes)

```bash
# Install Claude CLI
npm install -g @anthropic-ai/claude-code

# Install Multi-Agent System
pip install claude-multi-agent

# Set your API key
export ANTHROPIC_API_KEY="sk-ant-..."
```

## 2. Your First Agent (3 minutes)

Create a simple helper agent:

```bash
# Start interactive mode
claude-agents interactive

# In the interactive prompt:
> create helper "You are a helpful assistant"
> use helper
> ask "What is the capital of France?"
```

## 3. Your First Workflow (5 minutes)

Create a file `story_workflow.py`:

```python
import asyncio
from claude_multi_agent import Orchestrator

async def create_story():
    orchestrator = Orchestrator()
    
    # Create storytelling team
    await orchestrator.create_agent(
        "plot_designer",
        "You create interesting plot outlines"
    )
    
    await orchestrator.create_agent(
        "writer",
        "You write engaging stories from plots"
    )
    
    await orchestrator.create_agent(
        "editor",
        "You polish and improve stories"
    )
    
    # Create story
    plot = await orchestrator.send_task(
        "plot_designer",
        "Create a plot for a sci-fi story"
    )
    
    story = await orchestrator.send_task(
        "writer",
        f"Write a short story based on: {plot}"
    )
    
    final = await orchestrator.send_task(
        "editor",
        f"Polish this story: {story}"
    )
    
    print(final)
    await orchestrator.cleanup_all()

asyncio.run(create_story())
```

Run it:

```bash
python story_workflow.py
```

## Next Steps

1. Read the [User Guide](user-guide.md)
2. Explore [Example Scripts](../examples/)
3. Learn about [Workflow Patterns](workflows.md)
4. Join our [Community Discord](https://discord.gg/...)

Happy orchestrating! ðŸŽ­
```

## Success Criteria
- [ ] Comprehensive README with clear installation steps
- [ ] User guide covering all major features
- [ ] Complete API reference documentation
- [ ] Practical examples for common use cases
- [ ] Proper packaging configuration
- [ ] End-to-end tests validating full system
- [ ] Quick start gets users running in <10 minutes
- [ ] All documentation is clear and accurate

## Final Checklist
- [ ] All tests passing (unit, integration, e2e)
- [ ] Documentation complete and reviewed
- [ ] Examples run without errors
- [ ] Package installs cleanly
- [ ] CLI help is comprehensive
- [ ] Error messages are helpful
- [ ] Performance meets targets
- [ ] Security best practices followed

## Conclusion

The Claude Multi-Agent System is now complete with:

1. **Robust Core**: Shell execution, session management, workspace isolation
2. **Flexible Orchestration**: Multiple workflow patterns and templates
3. **User-Friendly Interface**: CLI and Python API with rich output
4. **Comprehensive Documentation**: From quick start to API reference
5. **Production Ready**: Error handling, logging, configuration, and testing

The system successfully addresses the core requirement of spawning and orchestrating multiple Claude agents while maintaining conversation context through proper session management.