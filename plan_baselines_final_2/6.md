# Step 6: CLI Interface and Configuration System

## Overview
Implement a comprehensive CLI interface for the multi-agent system, along with a flexible configuration system supporting JSON/YAML files and environment variables.

## Objectives
1. Build intuitive CLI with multiple commands
2. Implement configuration loading from files and environment
3. Create interactive and batch modes
4. Add monitoring and status commands
5. Provide comprehensive help and examples

## Implementation Tasks

### 1. CLI Application Structure
```python
# src/cli/app.py
import click
import asyncio
import json
import yaml
from pathlib import Path
from typing import Optional, List
import sys
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.syntax import Syntax

from src.cli.commands import agent_commands, workflow_commands, system_commands
from src.config.loader import ConfigLoader
from src.orchestrator.core import Orchestrator
from src.utils.logging import setup_logging

console = Console()

class CLIContext:
    """Shared context for CLI commands"""
    def __init__(self):
        self.orchestrator: Optional[Orchestrator] = None
        self.config: dict = {}
        self.interactive_mode: bool = False

@click.group()
@click.option('--config', '-c', type=click.Path(exists=True), 
              help='Configuration file (JSON/YAML)')
@click.option('--log-level', '-l', 
              type=click.Choice(['DEBUG', 'INFO', 'WARNING', 'ERROR']),
              default='INFO', help='Logging level')
@click.option('--base-dir', '-d', type=click.Path(),
              help='Base directory for agent workspaces')
@click.pass_context
def cli(ctx, config, log_level, base_dir):
    """Claude Multi-Agent System - Orchestrate multiple Claude agents"""
    # Setup logging
    setup_logging(level=log_level)
    
    # Initialize context
    ctx.obj = CLIContext()
    
    # Load configuration
    config_loader = ConfigLoader()
    
    if config:
        ctx.obj.config = config_loader.load_file(config)
    else:
        ctx.obj.config = config_loader.load_defaults()
        
    # Apply CLI overrides
    if base_dir:
        ctx.obj.config['orchestrator']['base_dir'] = base_dir
        
    # Initialize orchestrator
    orch_config = ctx.obj.config.get('orchestrator', {})
    ctx.obj.orchestrator = Orchestrator(
        base_dir=Path(orch_config.get('base_dir', '/tmp/claude-agents')),
        max_agents=orch_config.get('max_agents', 10)
    )
    
    console.print(f"[green]Claude Multi-Agent System initialized[/green]")

# Register command groups
cli.add_command(agent_commands.agent)
cli.add_command(workflow_commands.workflow)
cli.add_command(system_commands.system)

@cli.command()
@click.pass_context
def interactive(ctx):
    """Start interactive mode"""
    from src.cli.interactive import InteractiveMode
    
    console.print("[bold blue]Entering interactive mode...[/bold blue]")
    console.print("Type 'help' for available commands, 'exit' to quit.\n")
    
    interactive = InteractiveMode(ctx.obj.orchestrator)
    asyncio.run(interactive.run())

@cli.command()
@click.pass_context
def status(ctx):
    """Show system status"""
    orchestrator = ctx.obj.orchestrator
    
    # Create status table
    table = Table(title="System Status")
    table.add_column("Property", style="cyan")
    table.add_column("Value", style="green")
    
    # System info
    table.add_row("Base Directory", str(orchestrator.base_dir))
    table.add_row("Max Agents", str(orchestrator.agent_pool.max_agents))
    table.add_row("Active Agents", str(len(orchestrator.agents)))
    
    console.print(table)
    
    # Agent details
    if orchestrator.agents:
        agent_table = Table(title="Active Agents")
        agent_table.add_column("ID", style="cyan")
        agent_table.add_column("Status", style="yellow")
        agent_table.add_column("Interactions", style="green")
        agent_table.add_column("Session", style="magenta")
        
        for agent_id, agent in orchestrator.agents.items():
            metrics = agent.get_metrics()
            agent_table.add_row(
                agent_id,
                metrics['status'],
                str(metrics['total_interactions']),
                metrics['current_session'] or "None"
            )
            
        console.print(agent_table)

def main():
    """Main entry point"""
    try:
        cli()
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### 2. Agent Commands
```python
# src/cli/commands/agent_commands.py
import click
import asyncio
from rich.console import Console
from rich.progress import Progress

console = Console()

@click.group()
def agent():
    """Manage individual agents"""
    pass

@agent.command()
@click.argument('agent_id')
@click.option('--system-prompt', '-s', required=True, 
              help='System prompt for the agent')
@click.option('--tools', '-t', multiple=True,
              help='Allowed tools for the agent')
@click.option('--max-turns', '-m', default=1, type=int,
              help='Maximum conversation turns')
@click.pass_context
def create(ctx, agent_id, system_prompt, tools, max_turns):
    """Create a new agent"""
    orchestrator = ctx.obj.orchestrator
    
    async def _create():
        with Progress() as progress:
            task = progress.add_task(f"Creating agent {agent_id}...", total=1)
            
            agent = await orchestrator.create_agent(
                agent_id,
                system_prompt,
                allowed_tools=list(tools),
                max_turns=max_turns
            )
            
            progress.update(task, completed=1)
            
        console.print(f"[green]✓ Agent '{agent_id}' created successfully[/green]")
        return agent
        
    asyncio.run(_create())

@agent.command()
@click.argument('agent_id')
@click.argument('prompt')
@click.option('--timeout', '-t', default=300, help='Timeout in seconds')
@click.option('--output', '-o', type=click.Path(), 
              help='Save response to file')
@click.pass_context
def ask(ctx, agent_id, prompt, timeout, output):
    """Send a prompt to an agent"""
    orchestrator = ctx.obj.orchestrator
    
    async def _ask():
        agent = await orchestrator.get_agent(agent_id)
        if not agent:
            console.print(f"[red]Agent '{agent_id}' not found[/red]")
            return
            
        with console.status(f"Agent {agent_id} is thinking..."):
            response = await agent.ask(prompt)
            
        console.print(f"\n[bold]Response:[/bold]")
        console.print(response)
        
        if output:
            Path(output).write_text(response)
            console.print(f"\n[green]Response saved to {output}[/green]")
            
        return response
        
    asyncio.run(_ask())

@agent.command()
@click.pass_context
def list(ctx):
    """List all agents"""
    orchestrator = ctx.obj.orchestrator
    
    if not orchestrator.agents:
        console.print("[yellow]No agents created yet[/yellow]")
        return
        
    from rich.table import Table
    
    table = Table(title="Agents")
    table.add_column("ID", style="cyan")
    table.add_column("System Prompt", style="green", max_width=50)
    table.add_column("Status", style="yellow")
    table.add_column("Interactions", style="magenta")
    
    for agent_id, agent in orchestrator.agents.items():
        metrics = agent.get_metrics()
        prompt_preview = agent.system_prompt[:47] + "..." if len(agent.system_prompt) > 50 else agent.system_prompt
        
        table.add_row(
            agent_id,
            prompt_preview,
            metrics['status'],
            str(metrics['total_interactions'])
        )
        
    console.print(table)

@agent.command()
@click.argument('agent_id')
@click.pass_context
def remove(ctx, agent_id):
    """Remove an agent"""
    orchestrator = ctx.obj.orchestrator
    
    async def _remove():
        await orchestrator.remove_agent(agent_id)
        console.print(f"[green]✓ Agent '{agent_id}' removed[/green]")
        
    asyncio.run(_remove())

@agent.command()
@click.argument('agent_id')
@click.pass_context
def history(ctx, agent_id):
    """Show agent conversation history"""
    orchestrator = ctx.obj.orchestrator
    
    async def _history():
        agent = await orchestrator.get_agent(agent_id)
        if not agent:
            console.print(f"[red]Agent '{agent_id}' not found[/red]")
            return
            
        history = agent.get_session_history()
        
        if not history:
            console.print("[yellow]No conversation history[/yellow]")
            return
            
        for i, entry in enumerate(history):
            console.print(f"\n[bold cyan]Interaction {i+1}:[/bold cyan]")
            console.print(f"[dim]Session: {entry['session_id']}[/dim]")
            console.print(f"[dim]Time: {entry['timestamp']}[/dim]")
            console.print(f"\n[bold]User:[/bold] {entry['prompt']}")
            console.print(f"\n[bold]Agent:[/bold] {entry['response']}")
            console.print("-" * 80)
            
    asyncio.run(_history())
```

### 3. Workflow Commands
```python
# src/cli/commands/workflow_commands.py
import click
import asyncio
import json
from pathlib import Path
from rich.console import Console
from rich.syntax import Syntax

from src.orchestrator.templates import (
    ResearchWorkflow, 
    CodeReviewWorkflow,
    BrainstormingWorkflow
)

console = Console()

@click.group()
def workflow():
    """Execute multi-agent workflows"""
    pass

@workflow.command()
@click.argument('agents', nargs=-1, required=True)
@click.argument('task')
@click.option('--pattern', '-p', 
              type=click.Choice(['sequential', 'parallel', 'pipeline']),
              default='sequential', help='Workflow pattern')
@click.pass_context
def run(ctx, agents, task, pattern):
    """Run a custom workflow"""
    orchestrator = ctx.obj.orchestrator
    
    async def _run():
        # Verify all agents exist
        for agent_id in agents:
            if agent_id not in orchestrator.agents:
                console.print(f"[red]Agent '{agent_id}' not found[/red]")
                return
                
        with console.status(f"Running {pattern} workflow..."):
            if pattern == 'sequential':
                result = await orchestrator.sequential(list(agents), task)
            elif pattern == 'parallel':
                result = await orchestrator.parallel(list(agents), task)
            elif pattern == 'pipeline':
                # Simple pipeline without transforms
                stages = [{"agent": a} for a in agents]
                result = await orchestrator.pipeline(stages, task)
                
        # Display results
        console.print(f"\n[bold]Workflow Results:[/bold]")
        console.print(f"Pattern: {result.pattern.value}")
        console.print(f"Success: {'✓' if result.success else '✗'}")
        
        if result.errors:
            console.print("\n[red]Errors:[/red]")
            for error in result.errors:
                console.print(f"  - {error}")
                
        console.print("\n[bold]Agent Results:[/bold]")
        for agent_id, response in result.results.items():
            console.print(f"\n[cyan]{agent_id}:[/cyan]")
            if response:
                console.print(response[:500] + "..." if len(str(response)) > 500 else response)
                
    asyncio.run(_run())

@workflow.command()
@click.argument('template', 
                type=click.Choice(['research', 'code-review', 'brainstorm']))
@click.argument('input_text')
@click.option('--output', '-o', type=click.Path(),
              help='Save results to file')
@click.pass_context
def template(ctx, template, input_text, output):
    """Run a workflow template"""
    orchestrator = ctx.obj.orchestrator
    
    async def _template():
        # Select template
        if template == 'research':
            workflow = ResearchWorkflow(orchestrator)
        elif template == 'code-review':
            workflow = CodeReviewWorkflow(orchestrator)
        elif template == 'brainstorm':
            workflow = BrainstormingWorkflow(orchestrator)
            
        # Setup and execute
        console.print(f"[cyan]Setting up {template} workflow...[/cyan]")
        await workflow.setup()
        
        with console.status(f"Executing {template} workflow..."):
            result = await workflow.execute(input_text)
            
        # Display results
        console.print(f"\n[bold green]Workflow completed![/bold green]")
        
        if 'final_output' in result.metadata:
            console.print("\n[bold]Final Output:[/bold]")
            console.print(result.metadata['final_output'])
        elif 'synthesized_plan' in result.metadata:
            console.print("\n[bold]Synthesized Plan:[/bold]")
            console.print(result.metadata['synthesized_plan'])
            
        # Save if requested
        if output:
            output_data = {
                "template": template,
                "input": input_text,
                "results": result.results,
                "metadata": result.metadata,
                "success": result.success
            }
            
            Path(output).write_text(json.dumps(output_data, indent=2))
            console.print(f"\n[green]Results saved to {output}[/green]")
            
    asyncio.run(_template())

@workflow.command()
@click.argument('workflow_file', type=click.Path(exists=True))
@click.pass_context
def load(ctx, workflow_file):
    """Load and execute workflow from file"""
    orchestrator = ctx.obj.orchestrator
    
    # Load workflow definition
    workflow_path = Path(workflow_file)
    
    if workflow_path.suffix == '.json':
        workflow_def = json.loads(workflow_path.read_text())
    elif workflow_path.suffix in ['.yaml', '.yml']:
        import yaml
        workflow_def = yaml.safe_load(workflow_path.read_text())
    else:
        console.print("[red]Workflow file must be JSON or YAML[/red]")
        return
        
    async def _load():
        # Create agents if needed
        for agent_def in workflow_def.get('agents', []):
            if agent_def['id'] not in orchestrator.agents:
                await orchestrator.create_agent(
                    agent_def['id'],
                    agent_def['system_prompt']
                )
                
        # Execute workflow
        pattern = workflow_def['pattern']
        task = workflow_def['task']
        
        with console.status(f"Executing workflow from {workflow_file}..."):
            if pattern == 'sequential':
                result = await orchestrator.sequential(
                    workflow_def['agent_order'],
                    task
                )
            elif pattern == 'parallel':
                result = await orchestrator.parallel(
                    workflow_def['agent_order'],
                    task
                )
            # Add more patterns as needed
            
        console.print(f"\n[bold green]Workflow completed![/bold green]")
        console.print(f"Success: {result.success}")
        
    asyncio.run(_load())
```

### 4. Configuration System
```python
# src/config/loader.py
import os
import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
import logging
from pydantic import BaseModel, ValidationError

logger = logging.getLogger(__name__)

class OrchestratorConfig(BaseModel):
    base_dir: str = "/tmp/claude-agents"
    max_agents: int = 10
    session_persistence: bool = True
    cleanup_interval_minutes: int = 60

class AgentDefaults(BaseModel):
    max_turns: int = 1
    timeout: int = 300
    retry_attempts: int = 3

class LoggingConfig(BaseModel):
    level: str = "INFO"
    file: Optional[str] = None
    format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

class SystemConfig(BaseModel):
    orchestrator: OrchestratorConfig = OrchestratorConfig()
    agent_defaults: AgentDefaults = AgentDefaults()
    logging: LoggingConfig = LoggingConfig()
    agents: List[Dict[str, Any]] = []
    workflows: List[Dict[str, Any]] = []

class ConfigLoader:
    """Load configuration from various sources"""
    
    def __init__(self):
        self.config_search_paths = [
            Path.cwd() / "claude-agents.yaml",
            Path.cwd() / "claude-agents.json",
            Path.home() / ".claude-agents" / "config.yaml",
            Path.home() / ".claude-agents" / "config.json",
            Path("/etc/claude-agents/config.yaml"),
            Path("/etc/claude-agents/config.json")
        ]
        
    def load_defaults(self) -> Dict[str, Any]:
        """Load default configuration"""
        return SystemConfig().dict()
        
    def load_file(self, path: str) -> Dict[str, Any]:
        """Load configuration from file"""
        file_path = Path(path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Configuration file not found: {path}")
            
        if file_path.suffix == '.json':
            with open(file_path) as f:
                data = json.load(f)
        elif file_path.suffix in ['.yaml', '.yml']:
            with open(file_path) as f:
                data = yaml.safe_load(f)
        else:
            raise ValueError(f"Unsupported config format: {file_path.suffix}")
            
        # Validate configuration
        try:
            config = SystemConfig(**data)
            return config.dict()
        except ValidationError as e:
            raise ValueError(f"Invalid configuration: {e}")
            
    def load_env(self) -> Dict[str, Any]:
        """Load configuration from environment variables"""
        config = {}
        
        # Orchestrator settings
        if base_dir := os.getenv("CLAUDE_AGENTS_BASE_DIR"):
            config.setdefault('orchestrator', {})['base_dir'] = base_dir
            
        if max_agents := os.getenv("CLAUDE_AGENTS_MAX_AGENTS"):
            config.setdefault('orchestrator', {})['max_agents'] = int(max_agents)
            
        # Logging settings
        if log_level := os.getenv("CLAUDE_AGENTS_LOG_LEVEL"):
            config.setdefault('logging', {})['level'] = log_level
            
        if log_file := os.getenv("CLAUDE_AGENTS_LOG_FILE"):
            config.setdefault('logging', {})['file'] = log_file
            
        return config
        
    def find_config_file(self) -> Optional[Path]:
        """Find configuration file in standard locations"""
        for path in self.config_search_paths:
            if path.exists():
                logger.info(f"Found configuration file: {path}")
                return path
        return None
        
    def load(self) -> Dict[str, Any]:
        """Load configuration from all sources with precedence"""
        # Start with defaults
        config = self.load_defaults()
        
        # Load from file if found
        if config_file := self.find_config_file():
            file_config = self.load_file(str(config_file))
            config = self._deep_merge(config, file_config)
            
        # Override with environment variables
        env_config = self.load_env()
        config = self._deep_merge(config, env_config)
        
        return config
        
    def _deep_merge(self, base: Dict, update: Dict) -> Dict:
        """Deep merge two dictionaries"""
        result = base.copy()
        
        for key, value in update.items():
            if key in result and isinstance(result[key], dict) and isinstance(value, dict):
                result[key] = self._deep_merge(result[key], value)
            else:
                result[key] = value
                
        return result

# Example configuration file (claude-agents.yaml)
"""
orchestrator:
  base_dir: /var/claude-agents
  max_agents: 20
  session_persistence: true
  cleanup_interval_minutes: 30

agent_defaults:
  max_turns: 3
  timeout: 600
  retry_attempts: 3

logging:
  level: INFO
  file: /var/log/claude-agents.log

agents:
  - id: researcher
    system_prompt: "You are a research specialist."
    allowed_tools: ["web_search", "read_file"]
    
  - id: developer
    system_prompt: "You are a software developer."
    allowed_tools: ["read_file", "write_file", "execute_command"]
    max_turns: 5
    
workflows:
  - name: code_analysis
    pattern: pipeline
    agents:
      - id: code_reader
        system_prompt: "Read and understand code"
      - id: analyzer
        system_prompt: "Analyze code for issues"
      - id: reporter
        system_prompt: "Generate analysis report"
"""
```

### 5. Interactive Mode
```python
# src/cli/interactive.py
import asyncio
import shlex
from typing import Optional, List
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.history import FileHistory
from rich.console import Console

console = Console()

class InteractiveMode:
    """Interactive CLI mode"""
    
    def __init__(self, orchestrator):
        self.orchestrator = orchestrator
        self.session = PromptSession(
            history=FileHistory('.claude-agents-history'),
            completer=self._build_completer()
        )
        self.current_agent: Optional[str] = None
        
    def _build_completer(self) -> WordCompleter:
        """Build command completer"""
        commands = [
            'agent', 'create', 'list', 'use', 'ask',
            'workflow', 'run', 'status', 'help', 'exit'
        ]
        return WordCompleter(commands, ignore_case=True)
        
    async def run(self):
        """Run interactive loop"""
        while True:
            try:
                # Build prompt
                prompt = f"[{self.current_agent or 'no-agent'}]> "
                
                # Get input
                line = await self.session.prompt_async(prompt)
                
                if not line.strip():
                    continue
                    
                # Parse command
                parts = shlex.split(line)
                command = parts[0].lower()
                args = parts[1:] if len(parts) > 1 else []
                
                # Execute command
                await self.execute_command(command, args)
                
            except KeyboardInterrupt:
                continue
            except EOFError:
                break
                
        console.print("\n[yellow]Goodbye![/yellow]")
        
    async def execute_command(self, command: str, args: List[str]):
        """Execute interactive command"""
        if command == 'exit':
            raise EOFError
            
        elif command == 'help':
            self.show_help()
            
        elif command == 'create':
            if len(args) < 2:
                console.print("[red]Usage: create <agent_id> <system_prompt>[/red]")
                return
            agent_id = args[0]
            system_prompt = ' '.join(args[1:])
            
            agent = await self.orchestrator.create_agent(agent_id, system_prompt)
            console.print(f"[green]Created agent '{agent_id}'[/green]")
            
        elif command == 'list':
            self.list_agents()
            
        elif command == 'use':
            if not args:
                console.print("[red]Usage: use <agent_id>[/red]")
                return
            self.current_agent = args[0]
            console.print(f"[cyan]Now using agent '{self.current_agent}'[/cyan]")
            
        elif command == 'ask':
            if not self.current_agent:
                console.print("[red]No agent selected. Use 'use <agent_id>' first[/red]")
                return
                
            if not args:
                console.print("[red]Usage: ask <prompt>[/red]")
                return
                
            prompt = ' '.join(args)
            response = await self.orchestrator.send_task(self.current_agent, prompt)
            console.print(f"\n[bold]Response:[/bold]\n{response}\n")
            
        elif command == 'status':
            self.show_status()
            
        else:
            console.print(f"[red]Unknown command: {command}[/red]")
            
    def show_help(self):
        """Show help information"""
        help_text = """
Available Commands:
  create <id> <prompt>  - Create a new agent
  list                  - List all agents
  use <agent_id>        - Select an agent
  ask <prompt>          - Send prompt to current agent
  status                - Show system status
  help                  - Show this help
  exit                  - Exit interactive mode
        """
        console.print(help_text)
        
    def list_agents(self):
        """List all agents"""
        if not self.orchestrator.agents:
            console.print("[yellow]No agents created[/yellow]")
            return
            
        console.print("\n[bold]Available Agents:[/bold]")
        for agent_id in self.orchestrator.agents:
            marker = "→" if agent_id == self.current_agent else " "
            console.print(f"{marker} {agent_id}")
            
    def show_status(self):
        """Show system status"""
        console.print(f"\nActive agents: {len(self.orchestrator.agents)}")
        console.print(f"Current agent: {self.current_agent or 'None'}")
```

### 6. Example Configuration Files
```yaml
# examples/configs/basic-config.yaml
orchestrator:
  base_dir: ./workspaces
  max_agents: 5

agent_defaults:
  max_turns: 2
  timeout: 300

agents:
  - id: helper
    system_prompt: "You are a helpful assistant"
    
  - id: coder
    system_prompt: "You are a Python expert"
    allowed_tools: ["read_file", "write_file"]
```

```json
# examples/configs/workflow-config.json
{
  "pattern": "sequential",
  "task": "Create a Python web scraper",
  "agents": [
    {
      "id": "designer",
      "system_prompt": "You design software architecture"
    },
    {
      "id": "developer",
      "system_prompt": "You implement Python code"
    },
    {
      "id": "tester",
      "system_prompt": "You write tests"
    }
  ],
  "agent_order": ["designer", "developer", "tester"]
}
```

### 7. Shell Completion
```bash
# scripts/install-completion.sh
#!/bin/bash

# Generate completion script
_CLAUDE_AGENTS_COMPLETE=bash_source claude-agents > claude-agents-complete.bash

# Install for bash
if [ -d ~/.bash_completion.d ]; then
    cp claude-agents-complete.bash ~/.bash_completion.d/
    echo "Bash completion installed"
fi

# Install for zsh
if [ -d ~/.zsh/completion ]; then
    cp claude-agents-complete.bash ~/.zsh/completion/_claude-agents
    echo "Zsh completion installed"
fi

echo "Please restart your shell or source the completion file"
```

## Success Criteria
- [ ] CLI provides intuitive interface for all operations
- [ ] Configuration system supports files and environment
- [ ] Interactive mode enables easy experimentation
- [ ] Rich output formatting enhances user experience
- [ ] Help system is comprehensive
- [ ] Shell completion works
- [ ] Error messages are helpful
- [ ] Examples demonstrate all features

## Next Steps
With the CLI complete, Step 7 will finalize the system with comprehensive documentation, examples, and packaging for distribution.