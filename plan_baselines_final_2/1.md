# Step 1: Shell Executor and Claude CLI Integration

## Overview
Implement the critical Shell Executor module that properly invokes Claude CLI through an interactive shell and handles response parsing. This is the foundation for all agent interactions.

## Objectives
1. Implement robust Claude CLI invocation via interactive shell
2. Create comprehensive JSON parsing with error handling
3. Build retry logic and error recovery
4. Test all edge cases thoroughly
5. Document shell compatibility

## Implementation Tasks

### 1. Complete Shell Executor Implementation
```python
# src/shell/executor.py
import os
import subprocess
import json
import shlex
import asyncio
from typing import Dict, Optional, Tuple, List
from pathlib import Path
import logging
from src.core.exceptions import (
    ClaudeExecutionError, 
    JSONParseError,
    SessionNotFoundError
)

logger = logging.getLogger(__name__)

class ShellExecutor:
    """Executes Claude CLI commands via interactive shell"""
    
    def __init__(self, shell: Optional[str] = None):
        self.shell = shell or os.environ.get("SHELL", "/bin/bash")
        self._validate_shell()
        
    def _validate_shell(self):
        """Ensure shell is available and executable"""
        if not Path(self.shell).exists():
            raise ClaudeExecutionError(f"Shell not found: {self.shell}")
            
    def _build_claude_command(
        self, 
        prompt: str, 
        session_id: Optional[str] = None,
        output_format: str = "json"
    ) -> List[str]:
        """Build Claude CLI command arguments"""
        args = ["claude", "-p", prompt, "--output-format", output_format]
        
        if session_id:
            args.extend(["-r", session_id])
            
        return args
    
    def _sanitize_output(self, output: str) -> str:
        """Remove shell artifacts and find JSON content"""
        lines = output.strip().split('\n')
        
        # Find first line that starts with '{'
        json_start_idx = None
        for i, line in enumerate(lines):
            if line.strip().startswith('{'):
                json_start_idx = i
                break
                
        if json_start_idx is None:
            raise JSONParseError("No JSON found in output")
            
        # Extract JSON lines
        json_lines = []
        brace_count = 0
        for line in lines[json_start_idx:]:
            json_lines.append(line)
            brace_count += line.count('{') - line.count('}')
            if brace_count == 0:
                break
                
        return '\n'.join(json_lines)
    
    def execute_claude(
        self, 
        prompt: str, 
        session_id: Optional[str] = None,
        working_dir: Optional[Path] = None,
        timeout: int = 300
    ) -> Dict:
        """Execute Claude CLI command and return parsed response"""
        # Build command
        args = self._build_claude_command(prompt, session_id)
        shell_cmd = " ".join(shlex.quote(arg) for arg in args)
        
        # Set working directory
        cwd = str(working_dir) if working_dir else os.getcwd()
        
        logger.debug(f"Executing: {shell_cmd} in {cwd}")
        
        try:
            # Execute via interactive shell
            proc = subprocess.run(
                [self.shell, "-ic", shell_cmd],
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if proc.returncode != 0:
                self._handle_error(proc.stderr, session_id)
                
            # Parse response
            clean_output = self._sanitize_output(proc.stdout)
            response = json.loads(clean_output)
            
            logger.debug(f"Response: {response}")
            return response
            
        except subprocess.TimeoutExpired:
            raise ClaudeExecutionError(f"Command timed out after {timeout}s")
        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}")
            logger.error(f"Raw output: {proc.stdout}")
            raise JSONParseError(f"Failed to parse response: {e}")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            raise ClaudeExecutionError(f"Command execution failed: {e}")
    
    def _handle_error(self, stderr: str, session_id: Optional[str]):
        """Parse and handle specific errors"""
        if "No conversation found with session ID" in stderr:
            raise SessionNotFoundError(f"Session not found: {session_id}")
        elif "rate limit" in stderr.lower():
            raise ClaudeExecutionError("Rate limit exceeded")
        else:
            raise ClaudeExecutionError(f"Claude CLI error: {stderr}")
    
    async def execute_claude_async(
        self, 
        prompt: str, 
        session_id: Optional[str] = None,
        working_dir: Optional[Path] = None,
        timeout: int = 300
    ) -> Dict:
        """Async version of execute_claude"""
        return await asyncio.to_thread(
            self.execute_claude,
            prompt,
            session_id,
            working_dir,
            timeout
        )
```

### 2. Custom Exceptions
```python
# src/core/exceptions.py
class ClaudeAgentError(Exception):
    """Base exception for Claude Agent system"""
    pass

class ClaudeExecutionError(ClaudeAgentError):
    """Error executing Claude CLI"""
    pass

class JSONParseError(ClaudeAgentError):
    """Error parsing JSON response"""
    pass

class SessionNotFoundError(ClaudeAgentError):
    """Session ID not found"""
    pass

class RateLimitError(ClaudeAgentError):
    """Rate limit exceeded"""
    pass
```

### 3. Enhanced JSON Parser
```python
# src/utils/json_parser.py
import json
import re
from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class RobustJSONParser:
    """Handles various JSON parsing scenarios"""
    
    @staticmethod
    def parse_mixed_output(text: str) -> Dict[str, Any]:
        """Parse JSON from mixed shell/JSON output"""
        # Try direct parsing first
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            pass
            
        # Try to find JSON object
        json_match = re.search(r'\{[^{}]*\}', text, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group())
            except json.JSONDecodeError:
                pass
                
        # Try line by line
        for line in text.split('\n'):
            line = line.strip()
            if line.startswith('{') and line.endswith('}'):
                try:
                    return json.loads(line)
                except json.JSONDecodeError:
                    continue
                    
        raise ValueError("No valid JSON found in output")
    
    @staticmethod
    def extract_session_id(response: Dict) -> Optional[str]:
        """Safely extract session ID from response"""
        return response.get('session_id') or response.get('sessionId')
    
    @staticmethod
    def extract_result(response: Dict) -> str:
        """Extract result text from various response formats"""
        # Try different field names
        for field in ['result', 'message', 'response', 'output']:
            if field in response:
                return str(response[field])
        
        # If no standard field, return full response
        return json.dumps(response)
```

### 4. Retry Logic Decorator
```python
# src/utils/retry.py
import asyncio
import functools
import logging
from typing import TypeVar, Callable, Any
import random

logger = logging.getLogger(__name__)

T = TypeVar('T')

def retry_with_backoff(
    max_attempts: int = 3,
    initial_delay: float = 1.0,
    max_delay: float = 60.0,
    exponential_base: float = 2.0,
    jitter: bool = True
):
    """Decorator for retry with exponential backoff"""
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs) -> T:
            delay = initial_delay
            
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        logger.error(f"Failed after {max_attempts} attempts")
                        raise
                        
                    # Calculate next delay
                    if jitter:
                        delay = delay * (0.5 + random.random())
                    
                    logger.warning(
                        f"Attempt {attempt + 1} failed: {e}. "
                        f"Retrying in {delay:.1f}s..."
                    )
                    
                    await asyncio.sleep(delay)
                    delay = min(delay * exponential_base, max_delay)
                    
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs) -> T:
            delay = initial_delay
            
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        logger.error(f"Failed after {max_attempts} attempts")
                        raise
                        
                    # Calculate next delay
                    if jitter:
                        delay = delay * (0.5 + random.random())
                    
                    logger.warning(
                        f"Attempt {attempt + 1} failed: {e}. "
                        f"Retrying in {delay:.1f}s..."
                    )
                    
                    import time
                    time.sleep(delay)
                    delay = min(delay * exponential_base, max_delay)
        
        # Return appropriate wrapper based on function type
        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
            
    return decorator
```

### 5. Comprehensive Test Suite
```python
# tests/unit/test_shell_executor_complete.py
import pytest
from unittest.mock import Mock, patch, MagicMock
from pathlib import Path
import json

from src.shell.executor import ShellExecutor
from src.core.exceptions import (
    ClaudeExecutionError,
    JSONParseError,
    SessionNotFoundError
)

class TestShellExecutor:
    
    @pytest.fixture
    def executor(self):
        return ShellExecutor()
    
    @pytest.fixture
    def mock_subprocess(self):
        with patch('subprocess.run') as mock:
            yield mock
    
    def test_command_building(self, executor):
        # Test without session
        cmd = executor._build_claude_command("Hello")
        assert cmd == ["claude", "-p", "Hello", "--output-format", "json"]
        
        # Test with session
        cmd = executor._build_claude_command("Hello", "session-123")
        assert cmd == ["claude", "-p", "Hello", "--output-format", "json", "-r", "session-123"]
    
    def test_output_sanitization(self, executor):
        # Test with shell artifacts
        output = """
        Welcome to zsh!
        Loading environment...
        {"session_id": "123", "result": "Hello"}
        Done.
        """
        clean = executor._sanitize_output(output)
        data = json.loads(clean)
        assert data["session_id"] == "123"
        
    def test_successful_execution(self, executor, mock_subprocess):
        mock_subprocess.return_value = MagicMock(
            returncode=0,
            stdout='{"session_id": "123", "result": "Success"}',
            stderr=""
        )
        
        result = executor.execute_claude("Test prompt")
        assert result["session_id"] == "123"
        assert result["result"] == "Success"
        
    def test_session_not_found_error(self, executor, mock_subprocess):
        mock_subprocess.return_value = MagicMock(
            returncode=1,
            stdout="",
            stderr="No conversation found with session ID: abc123"
        )
        
        with pytest.raises(SessionNotFoundError):
            executor.execute_claude("Test", session_id="abc123")
            
    def test_json_parse_error(self, executor, mock_subprocess):
        mock_subprocess.return_value = MagicMock(
            returncode=0,
            stdout="Invalid JSON response",
            stderr=""
        )
        
        with pytest.raises(JSONParseError):
            executor.execute_claude("Test")
            
    @pytest.mark.asyncio
    async def test_async_execution(self, executor, mock_subprocess):
        mock_subprocess.return_value = MagicMock(
            returncode=0,
            stdout='{"session_id": "123", "result": "Async success"}',
            stderr=""
        )
        
        result = await executor.execute_claude_async("Test prompt")
        assert result["result"] == "Async success"
```

### 6. Integration Tests
```python
# tests/integration/test_shell_executor_integration.py
import pytest
import subprocess
from pathlib import Path
from src.shell.executor import ShellExecutor

@pytest.mark.integration
class TestShellExecutorIntegration:
    
    def test_real_claude_cli_execution(self):
        """Test with actual Claude CLI if available"""
        # Check if Claude is available
        result = subprocess.run(["which", "claude"], capture_output=True)
        if result.returncode != 0:
            pytest.skip("Claude CLI not available")
            
        executor = ShellExecutor()
        response = executor.execute_claude("Say 'test' and nothing else")
        
        assert "session_id" in response
        assert response.get("result") or response.get("message")
```

### 7. Shell Compatibility Documentation
```markdown
# docs/shell-compatibility.md

# Shell Compatibility Guide

## Supported Shells
- **bash** (4.0+): Fully supported
- **zsh** (5.0+): Fully supported  
- **fish** (3.0+): Requires compatibility mode
- **sh**: Basic support, may have limitations

## Shell Configuration Requirements

### Bash
```bash
# ~/.bashrc or ~/.bash_profile
alias claude='/path/to/claude'
export ANTHROPIC_API_KEY="your-key"
```

### Zsh
```zsh
# ~/.zshrc
alias claude='/path/to/claude'
export ANTHROPIC_API_KEY="your-key"
```

## Troubleshooting

### Command Not Found
If `claude` is not found, ensure:
1. Claude CLI is installed: `npm install -g @anthropic-ai/claude-code`
2. Shell configuration is loaded: `source ~/.zshrc`
3. Path is correct: `which claude`

### JSON Parsing Issues
Common causes:
1. Shell login messages - Add quiet flags to shell rc files
2. MOTD output - Disable in shell configuration
3. Unicode issues - Ensure UTF-8 locale
```

## Success Criteria
- [ ] Shell executor fully implemented with error handling
- [ ] JSON parsing handles all edge cases
- [ ] Retry logic implemented and tested
- [ ] Session management errors handled gracefully
- [ ] 100% unit test coverage
- [ ] Integration tests passing (if Claude CLI available)
- [ ] Shell compatibility documented

## Next Steps
With robust shell execution in place, Step 2 will implement the Session Tracker to manage conversation continuity.