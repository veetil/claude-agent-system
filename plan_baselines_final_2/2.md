# Step 2: Session Management and Tracking

## Overview
Implement the Session Tracker module that maintains conversation continuity by tracking session ID chains and managing session lifecycle. This is critical for multi-turn conversations.

## Objectives
1. Build robust session tracking with chain management
2. Implement session persistence and recovery
3. Create session validation and health checks
4. Handle session-related edge cases
5. Test session continuity thoroughly

## Implementation Tasks

### 1. Session Tracker Implementation
```python
# src/session/tracker.py
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Dict, Any
from dataclasses import dataclass, asdict
import asyncio
from src.core.exceptions import SessionNotFoundError

logger = logging.getLogger(__name__)

@dataclass
class SessionInfo:
    """Information about a single session"""
    session_id: str
    created_at: datetime
    interaction_count: int
    last_prompt: str
    last_response: str
    metadata: Dict[str, Any] = None
    
    def to_dict(self):
        data = asdict(self)
        data['created_at'] = self.created_at.isoformat()
        return data
    
    @classmethod
    def from_dict(cls, data: Dict):
        data['created_at'] = datetime.fromisoformat(data['created_at'])
        return cls(**data)

class SessionTracker:
    """Tracks Claude session IDs and maintains conversation continuity"""
    
    def __init__(self, agent_id: str, persistence_dir: Optional[Path] = None):
        self.agent_id = agent_id
        self.current_session_id: Optional[str] = None
        self.session_chain: List[SessionInfo] = []
        self.interaction_count = 0
        
        # Persistence
        self.persistence_dir = persistence_dir or Path.home() / ".claude-agent" / "sessions"
        self.persistence_file = self.persistence_dir / f"{agent_id}_sessions.json"
        self._ensure_persistence_dir()
        
        # Load existing sessions
        self._load_sessions()
        
    def _ensure_persistence_dir(self):
        """Create persistence directory if needed"""
        self.persistence_dir.mkdir(parents=True, exist_ok=True)
        
    def update_session(
        self, 
        new_session_id: str, 
        prompt: str, 
        response: str,
        metadata: Optional[Dict] = None
    ):
        """Update current session and add to chain"""
        self.interaction_count += 1
        
        session_info = SessionInfo(
            session_id=new_session_id,
            created_at=datetime.now(),
            interaction_count=self.interaction_count,
            last_prompt=prompt[:200],  # Truncate for storage
            last_response=response[:200],
            metadata=metadata
        )
        
        self.session_chain.append(session_info)
        self.current_session_id = new_session_id
        
        # Persist to disk
        self._save_sessions()
        
        logger.info(
            f"[{self.agent_id}] Session updated: {new_session_id} "
            f"(interaction #{self.interaction_count})"
        )
        
    def get_current_session(self) -> Optional[str]:
        """Get current session ID"""
        return self.current_session_id
        
    def get_session_chain(self) -> List[SessionInfo]:
        """Get full session history"""
        return self.session_chain.copy()
        
    def get_chain_summary(self) -> Dict[str, Any]:
        """Get summary of session chain"""
        if not self.session_chain:
            return {
                "agent_id": self.agent_id,
                "total_sessions": 0,
                "total_interactions": 0
            }
            
        return {
            "agent_id": self.agent_id,
            "total_sessions": len(self.session_chain),
            "total_interactions": self.interaction_count,
            "first_session": self.session_chain[0].session_id,
            "current_session": self.current_session_id,
            "session_ids": [s.session_id for s in self.session_chain]
        }
        
    def validate_session(self, session_id: str) -> bool:
        """Check if session ID exists in chain"""
        return any(s.session_id == session_id for s in self.session_chain)
        
    def reset(self):
        """Reset session tracking"""
        self.current_session_id = None
        self.session_chain = []
        self.interaction_count = 0
        self._save_sessions()
        logger.info(f"[{self.agent_id}] Session tracker reset")
        
    def _save_sessions(self):
        """Persist sessions to disk"""
        try:
            data = {
                "agent_id": self.agent_id,
                "current_session_id": self.current_session_id,
                "interaction_count": self.interaction_count,
                "sessions": [s.to_dict() for s in self.session_chain]
            }
            
            with open(self.persistence_file, 'w') as f:
                json.dump(data, f, indent=2)
                
        except Exception as e:
            logger.error(f"Failed to save sessions: {e}")
            
    def _load_sessions(self):
        """Load sessions from disk"""
        if not self.persistence_file.exists():
            return
            
        try:
            with open(self.persistence_file, 'r') as f:
                data = json.load(f)
                
            self.current_session_id = data.get("current_session_id")
            self.interaction_count = data.get("interaction_count", 0)
            
            self.session_chain = [
                SessionInfo.from_dict(s) 
                for s in data.get("sessions", [])
            ]
            
            logger.info(
                f"[{self.agent_id}] Loaded {len(self.session_chain)} sessions"
            )
            
        except Exception as e:
            logger.error(f"Failed to load sessions: {e}")
```

### 2. Session Manager for Multi-Agent Coordination
```python
# src/session/manager.py
import asyncio
from typing import Dict, Optional, List
from pathlib import Path
import logging
from datetime import datetime, timedelta

from src.session.tracker import SessionTracker, SessionInfo

logger = logging.getLogger(__name__)

class SessionManager:
    """Manages sessions across multiple agents"""
    
    def __init__(self, persistence_dir: Optional[Path] = None):
        self.trackers: Dict[str, SessionTracker] = {}
        self.persistence_dir = persistence_dir
        self._lock = asyncio.Lock()
        
    async def get_tracker(self, agent_id: str) -> SessionTracker:
        """Get or create session tracker for agent"""
        async with self._lock:
            if agent_id not in self.trackers:
                self.trackers[agent_id] = SessionTracker(
                    agent_id, 
                    self.persistence_dir
                )
            return self.trackers[agent_id]
            
    async def update_session(
        self,
        agent_id: str,
        session_id: str,
        prompt: str,
        response: str,
        metadata: Optional[Dict] = None
    ):
        """Update session for an agent"""
        tracker = await self.get_tracker(agent_id)
        tracker.update_session(session_id, prompt, response, metadata)
        
    async def get_current_session(self, agent_id: str) -> Optional[str]:
        """Get current session for an agent"""
        tracker = await self.get_tracker(agent_id)
        return tracker.get_current_session()
        
    async def get_all_sessions(self) -> Dict[str, List[SessionInfo]]:
        """Get all sessions across all agents"""
        result = {}
        async with self._lock:
            for agent_id, tracker in self.trackers.items():
                result[agent_id] = tracker.get_session_chain()
        return result
        
    async def cleanup_old_sessions(self, days: int = 7):
        """Remove sessions older than specified days"""
        cutoff = datetime.now() - timedelta(days=days)
        
        async with self._lock:
            for tracker in self.trackers.values():
                # Filter out old sessions
                tracker.session_chain = [
                    s for s in tracker.session_chain
                    if s.created_at > cutoff
                ]
                tracker._save_sessions()
                
        logger.info(f"Cleaned up sessions older than {days} days")
        
    async def export_sessions(self, output_path: Path):
        """Export all sessions to a file"""
        all_sessions = await self.get_all_sessions()
        
        export_data = {
            "export_date": datetime.now().isoformat(),
            "agents": {}
        }
        
        for agent_id, sessions in all_sessions.items():
            export_data["agents"][agent_id] = {
                "sessions": [s.to_dict() for s in sessions],
                "total_interactions": len(sessions)
            }
            
        with open(output_path, 'w') as f:
            json.dump(export_data, f, indent=2)
            
        logger.info(f"Exported sessions to {output_path}")
```

### 3. Session Validation and Health Checks
```python
# src/session/validator.py
import os
from pathlib import Path
from typing import Optional, Tuple, Dict
import json
import logging

logger = logging.getLogger(__name__)

class SessionValidator:
    """Validates Claude session files and health"""
    
    def __init__(self):
        self.claude_session_dir = Path.home() / ".claude" / "projects"
        
    def validate_session_file(
        self, 
        session_id: str, 
        working_dir: Path
    ) -> Tuple[bool, Optional[str]]:
        """Check if session file exists and is valid"""
        # Construct session file path
        project_path = str(working_dir).replace('/', '-')
        session_file = self.claude_session_dir / project_path / f"{session_id}.jsonl"
        
        if not session_file.exists():
            return False, f"Session file not found: {session_file}"
            
        # Check if file is readable and has content
        try:
            with open(session_file, 'r') as f:
                lines = f.readlines()
                if not lines:
                    return False, "Session file is empty"
                    
                # Validate JSONL format
                for i, line in enumerate(lines):
                    try:
                        json.loads(line.strip())
                    except json.JSONDecodeError:
                        return False, f"Invalid JSON at line {i+1}"
                        
            return True, None
            
        except Exception as e:
            return False, f"Error reading session file: {e}"
            
    def get_session_info(
        self, 
        session_id: str, 
        working_dir: Path
    ) -> Optional[Dict]:
        """Extract information from session file"""
        valid, error = self.validate_session_file(session_id, working_dir)
        if not valid:
            logger.error(f"Invalid session: {error}")
            return None
            
        project_path = str(working_dir).replace('/', '-')
        session_file = self.claude_session_dir / project_path / f"{session_id}.jsonl"
        
        info = {
            "session_id": session_id,
            "file_path": str(session_file),
            "size_bytes": session_file.stat().st_size,
            "message_count": 0,
            "first_timestamp": None,
            "last_timestamp": None
        }
        
        with open(session_file, 'r') as f:
            for line in f:
                data = json.loads(line.strip())
                info["message_count"] += 1
                
                if "timestamp" in data:
                    if not info["first_timestamp"]:
                        info["first_timestamp"] = data["timestamp"]
                    info["last_timestamp"] = data["timestamp"]
                    
        return info
```

### 4. Comprehensive Test Suite
```python
# tests/unit/test_session_tracker.py
import pytest
from datetime import datetime
from pathlib import Path
import tempfile
import json

from src.session.tracker import SessionTracker, SessionInfo

class TestSessionTracker:
    
    @pytest.fixture
    def temp_dir(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            yield Path(tmpdir)
            
    @pytest.fixture
    def tracker(self, temp_dir):
        return SessionTracker("test-agent", temp_dir)
        
    def test_initialization(self, tracker):
        assert tracker.agent_id == "test-agent"
        assert tracker.current_session_id is None
        assert len(tracker.session_chain) == 0
        assert tracker.interaction_count == 0
        
    def test_update_session(self, tracker):
        tracker.update_session(
            "session-123",
            "Hello Claude",
            "Hello! How can I help?",
            {"tokens": 10}
        )
        
        assert tracker.current_session_id == "session-123"
        assert len(tracker.session_chain) == 1
        assert tracker.interaction_count == 1
        
        session = tracker.session_chain[0]
        assert session.session_id == "session-123"
        assert session.last_prompt == "Hello Claude"
        assert session.metadata["tokens"] == 10
        
    def test_session_chain(self, tracker):
        # Create chain of sessions
        for i in range(5):
            tracker.update_session(
                f"session-{i}",
                f"Prompt {i}",
                f"Response {i}"
            )
            
        chain = tracker.get_session_chain()
        assert len(chain) == 5
        assert chain[0].session_id == "session-0"
        assert chain[4].session_id == "session-4"
        assert tracker.current_session_id == "session-4"
        
    def test_persistence(self, temp_dir):
        # Create and save sessions
        tracker1 = SessionTracker("persist-test", temp_dir)
        tracker1.update_session("session-1", "Test", "Response")
        tracker1.update_session("session-2", "Test2", "Response2")
        
        # Load in new tracker
        tracker2 = SessionTracker("persist-test", temp_dir)
        assert tracker2.current_session_id == "session-2"
        assert len(tracker2.session_chain) == 2
        assert tracker2.interaction_count == 2
        
    def test_session_validation(self, tracker):
        tracker.update_session("valid-session", "Test", "Response")
        
        assert tracker.validate_session("valid-session") == True
        assert tracker.validate_session("invalid-session") == False
        
    def test_reset(self, tracker):
        tracker.update_session("session-1", "Test", "Response")
        tracker.reset()
        
        assert tracker.current_session_id is None
        assert len(tracker.session_chain) == 0
        assert tracker.interaction_count == 0
        
    def test_chain_summary(self, tracker):
        # Empty summary
        summary = tracker.get_chain_summary()
        assert summary["total_sessions"] == 0
        
        # Add sessions
        tracker.update_session("s1", "P1", "R1")
        tracker.update_session("s2", "P2", "R2")
        
        summary = tracker.get_chain_summary()
        assert summary["agent_id"] == "test-agent"
        assert summary["total_sessions"] == 2
        assert summary["total_interactions"] == 2
        assert summary["current_session"] == "s2"
        assert summary["session_ids"] == ["s1", "s2"]
```

### 5. Integration Tests
```python
# tests/integration/test_session_continuity.py
import pytest
import asyncio
from pathlib import Path

from src.shell.executor import ShellExecutor
from src.session.tracker import SessionTracker
from src.session.validator import SessionValidator

@pytest.mark.integration
class TestSessionContinuity:
    
    @pytest.fixture
    def working_dir(self, tmp_path):
        return tmp_path / "test-agent"
        
    async def test_session_chain_with_claude(self, working_dir):
        """Test real session chaining with Claude CLI"""
        working_dir.mkdir(parents=True, exist_ok=True)
        
        executor = ShellExecutor()
        tracker = SessionTracker("continuity-test")
        
        # First interaction
        response1 = executor.execute_claude(
            "My name is Alice and I like Python",
            working_dir=working_dir
        )
        
        session_id_1 = response1.get("session_id")
        assert session_id_1 is not None
        
        tracker.update_session(
            session_id_1,
            "My name is Alice and I like Python",
            response1.get("result", "")
        )
        
        # Second interaction with resume
        response2 = executor.execute_claude(
            "What's my name?",
            session_id=session_id_1,
            working_dir=working_dir
        )
        
        session_id_2 = response2.get("session_id")
        assert session_id_2 != session_id_1  # New session ID
        
        result = response2.get("result", "").lower()
        assert "alice" in result  # Remembers name
        
        tracker.update_session(
            session_id_2,
            "What's my name?",
            response2.get("result", "")
        )
        
        # Verify chain
        chain = tracker.get_session_chain()
        assert len(chain) == 2
        assert chain[0].session_id == session_id_1
        assert chain[1].session_id == session_id_2
```

### 6. Session Monitoring Dashboard
```python
# src/session/monitor.py
from typing import Dict, List
import asyncio
from datetime import datetime
from src.session.manager import SessionManager

class SessionMonitor:
    """Monitor session health and statistics"""
    
    def __init__(self, session_manager: SessionManager):
        self.session_manager = session_manager
        
    async def get_statistics(self) -> Dict:
        """Get session statistics across all agents"""
        all_sessions = await self.session_manager.get_all_sessions()
        
        total_agents = len(all_sessions)
        total_sessions = sum(len(sessions) for sessions in all_sessions.values())
        
        stats = {
            "timestamp": datetime.now().isoformat(),
            "total_agents": total_agents,
            "total_sessions": total_sessions,
            "agents": {}
        }
        
        for agent_id, sessions in all_sessions.items():
            if sessions:
                stats["agents"][agent_id] = {
                    "session_count": len(sessions),
                    "current_session": sessions[-1].session_id,
                    "first_interaction": sessions[0].created_at.isoformat(),
                    "last_interaction": sessions[-1].created_at.isoformat()
                }
                
        return stats
        
    async def health_check(self) -> Dict[str, bool]:
        """Check health of session system"""
        checks = {
            "session_manager_active": True,
            "persistence_available": True,
            "sessions_valid": True
        }
        
        try:
            # Test getting all sessions
            await self.session_manager.get_all_sessions()
        except Exception as e:
            checks["session_manager_active"] = False
            
        # Check persistence directory
        if self.session_manager.persistence_dir:
            checks["persistence_available"] = (
                self.session_manager.persistence_dir.exists()
            )
            
        return checks
```

## Success Criteria
- [ ] Session tracker maintains accurate chain of session IDs
- [ ] Sessions persist across restarts
- [ ] Session validation detects invalid sessions
- [ ] Multi-agent session management works correctly
- [ ] Session continuity verified in integration tests
- [ ] Monitoring provides useful statistics
- [ ] 100% test coverage for critical paths

## Next Steps
With session management in place, Step 3 will implement the Workspace Manager for agent file system isolation and resource management.