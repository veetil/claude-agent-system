# Step 0: Project Setup and Foundation

## Overview
Initialize the project structure, development environment, and core dependencies for the Claude Multi-Agent System.

## Objectives
1. Create project structure following best practices
2. Set up development environment with all dependencies
3. Implement core utilities and types
4. Set up testing framework
5. Create initial documentation structure

## Implementation Tasks

### 1. Project Structure Creation
```bash
claude-multi-agent/
├── src/
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── types.py          # Type definitions
│   │   ├── exceptions.py     # Custom exceptions
│   │   └── constants.py      # System constants
│   ├── shell/
│   │   ├── __init__.py
│   │   └── executor.py       # Shell execution utilities
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── logging.py        # Logging configuration
│   │   └── json_parser.py    # JSON parsing utilities
│   └── config/
│       ├── __init__.py
│       └── settings.py       # Configuration management
├── tests/
│   ├── __init__.py
│   ├── unit/
│   ├── integration/
│   └── fixtures/
├── examples/
├── docs/
├── scripts/
│   └── setup.sh
├── requirements.txt
├── requirements-dev.txt
├── setup.py
├── pyproject.toml
├── README.md
├── LICENSE
└── .gitignore
```

### 2. Core Type Definitions
```python
# src/core/types.py
from typing import Dict, List, Optional, Union
from dataclasses import dataclass
from pathlib import Path
from enum import Enum

class AgentStatus(Enum):
    IDLE = "idle"
    BUSY = "busy"
    ERROR = "error"
    TERMINATED = "terminated"

@dataclass
class AgentConfig:
    id: str
    system_prompt: str
    working_dir: Path
    allowed_tools: List[str] = None
    max_turns: int = 1
    
@dataclass
class TaskInput:
    prompt: str
    text_input: Optional[str] = None
    folders: Optional[List['FolderMapping']] = None
    repos: Optional[List['GitHubRepo']] = None
    files: Optional[List['FileMapping']] = None

@dataclass
class AgentResponse:
    session_id: str
    result: str
    metadata: Optional[Dict] = None
    error: Optional[str] = None
```

### 3. Shell Executor Foundation
```python
# src/shell/executor.py
import os
import subprocess
import json
import shlex
from typing import Dict, Optional, Tuple
from pathlib import Path

class ShellExecutor:
    """Executes Claude CLI commands via interactive shell"""
    
    def __init__(self):
        self.shell = os.environ.get("SHELL", "/bin/bash")
        
    def execute_claude(
        self, 
        prompt: str, 
        session_id: Optional[str] = None,
        working_dir: Optional[Path] = None
    ) -> Dict:
        """Execute Claude CLI command and return parsed response"""
        # Implementation will be completed in later steps
        pass
```

### 4. Logging Configuration
```python
# src/utils/logging.py
import logging
import sys
from pathlib import Path

def setup_logging(level=logging.INFO, log_file=None):
    """Configure logging for the entire application"""
    format_str = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    
    handlers = [logging.StreamHandler(sys.stdout)]
    if log_file:
        handlers.append(logging.FileHandler(log_file))
    
    logging.basicConfig(
        level=level,
        format=format_str,
        handlers=handlers
    )
```

### 5. Test Framework Setup
```python
# tests/conftest.py
import pytest
import tempfile
from pathlib import Path

@pytest.fixture
def temp_workspace():
    """Provide temporary workspace for tests"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)

@pytest.fixture
def mock_claude_response():
    """Mock Claude CLI response"""
    return {
        "session_id": "test-session-123",
        "result": "Test response",
        "timestamp": "2024-01-01T00:00:00Z"
    }
```

### 6. Requirements Files
```txt
# requirements.txt
asyncio>=3.4.3
typing-extensions>=4.0.0
pydantic>=2.0.0
pytest>=7.0.0
pytest-asyncio>=0.21.0
pytest-cov>=4.0.0
PyYAML>=6.0
python-dotenv>=1.0.0

# requirements-dev.txt
-r requirements.txt
black>=23.0.0
isort>=5.12.0
flake8>=6.0.0
mypy>=1.0.0
pre-commit>=3.0.0
```

### 7. Initial Configuration
```python
# src/config/settings.py
import os
from pathlib import Path
from typing import Optional
from pydantic import BaseSettings

class Settings(BaseSettings):
    # Claude CLI settings
    claude_cli_path: str = "claude"
    default_shell: str = os.environ.get("SHELL", "/bin/bash")
    
    # Agent settings
    default_max_turns: int = 1
    agent_startup_timeout: int = 5
    session_resume_timeout: int = 3
    
    # System settings
    base_workspace_dir: Path = Path("/tmp/claude-agents")
    max_concurrent_agents: int = 10
    
    # Logging
    log_level: str = "INFO"
    log_file: Optional[Path] = None
    
    class Config:
        env_prefix = "CLAUDE_AGENT_"
        env_file = ".env"
```

## Test Suite

### Unit Tests
```python
# tests/unit/test_shell_executor.py
import pytest
from src.shell.executor import ShellExecutor

def test_shell_executor_init():
    executor = ShellExecutor()
    assert executor.shell in ["/bin/bash", "/bin/zsh", "/bin/sh"]

def test_command_building():
    # Test command construction logic
    pass
```

### Integration Test Placeholder
```python
# tests/integration/test_setup.py
import subprocess

def test_claude_cli_available():
    """Verify Claude CLI is installed and accessible"""
    result = subprocess.run(
        ["which", "claude"], 
        capture_output=True, 
        text=True
    )
    assert result.returncode == 0, "Claude CLI not found"
```

## Success Criteria
- [ ] Project structure created and organized
- [ ] All dependencies installed successfully
- [ ] Core types and utilities implemented
- [ ] Test framework operational
- [ ] Basic documentation structure in place
- [ ] Configuration system working
- [ ] Initial tests passing

## Next Steps
With the foundation in place, Step 1 will implement the core Shell Executor with proper Claude CLI invocation and JSON parsing.