# Step 4: Core Agent Implementation

## Overview
Implement the core Agent class that integrates shell execution, session tracking, and workspace management into a cohesive unit. This is the primary interface for interacting with Claude.

## Objectives
1. Build the Agent class with all integrated components
2. Implement conversation methods with session continuity
3. Add resource management and lifecycle hooks
4. Create agent configuration and initialization
5. Test agent functionality end-to-end

## Implementation Tasks

### 1. Core Agent Implementation
```python
# src/agent/core.py
import asyncio
import logging
from pathlib import Path
from typing import Optional, Dict, List, Any, Callable
from datetime import datetime
from contextlib import asynccontextmanager

from src.core.types import AgentConfig, TaskInput, AgentResponse, AgentStatus
from src.core.exceptions import AgentError, SessionNotFoundError
from src.shell.executor import ShellExecutor
from src.session.tracker import SessionTracker
from src.workspace.manager import WorkspaceManager
from src.utils.retry import retry_with_backoff

logger = logging.getLogger(__name__)

class Agent:
    """Core Claude agent with session management and workspace isolation"""
    
    def __init__(
        self,
        config: AgentConfig,
        workspace_manager: Optional[WorkspaceManager] = None,
        shell_executor: Optional[ShellExecutor] = None
    ):
        self.config = config
        self.id = config.id
        self.system_prompt = config.system_prompt
        self.status = AgentStatus.IDLE
        
        # Components
        self.workspace_manager = workspace_manager or WorkspaceManager()
        self.shell_executor = shell_executor or ShellExecutor()
        self.session_tracker = SessionTracker(self.id)
        
        # State
        self.workspace: Optional[Path] = None
        self.initialized = False
        self._lock = asyncio.Lock()
        
        # Metrics
        self.total_interactions = 0
        self.total_tokens = 0
        self.start_time = datetime.now()
        
        # Callbacks
        self._on_response_callbacks: List[Callable] = []
        
    async def initialize(self):
        """Initialize agent workspace and resources"""
        async with self._lock:
            if self.initialized:
                logger.warning(f"Agent {self.id} already initialized")
                return
                
            # Create workspace
            self.workspace = await self.workspace_manager.create_workspace(
                self.id,
                persistent=True
            )
            
            # Set working directory in config
            self.config.working_dir = self.workspace
            
            self.initialized = True
            logger.info(f"Agent {self.id} initialized at {self.workspace}")
            
    async def ask(
        self, 
        prompt: str,
        max_retries: int = 3,
        include_system_prompt: bool = None
    ) -> str:
        """Send prompt to Claude and get response"""
        if not self.initialized:
            await self.initialize()
            
        # Prepare full prompt
        full_prompt = self._prepare_prompt(prompt, include_system_prompt)
        
        # Get current session
        current_session = self.session_tracker.get_current_session()
        
        try:
            # Update status
            self.status = AgentStatus.BUSY
            
            # Execute with retry
            response = await self._execute_with_retry(
                full_prompt,
                current_session,
                max_retries
            )
            
            # Process response
            result = self._process_response(response, prompt)
            
            # Update metrics
            self.total_interactions += 1
            self._update_metrics(response)
            
            # Trigger callbacks
            await self._trigger_callbacks(prompt, result, response)
            
            return result
            
        except Exception as e:
            self.status = AgentStatus.ERROR
            logger.error(f"Agent {self.id} error: {e}")
            raise AgentError(f"Agent execution failed: {e}")
        finally:
            self.status = AgentStatus.IDLE
            
    def _prepare_prompt(
        self, 
        prompt: str, 
        include_system_prompt: Optional[bool]
    ) -> str:
        """Prepare prompt with optional system prompt"""
        # Determine if we should include system prompt
        if include_system_prompt is None:
            # Include on first interaction
            include_system_prompt = self.total_interactions == 0
            
        if include_system_prompt and self.system_prompt:
            return f"System: {self.system_prompt}\n\nUser: {prompt}"
        else:
            return prompt
            
    @retry_with_backoff(max_attempts=3)
    async def _execute_with_retry(
        self,
        prompt: str,
        session_id: Optional[str],
        max_retries: int
    ) -> Dict:
        """Execute Claude with retry logic"""
        response = await self.shell_executor.execute_claude_async(
            prompt=prompt,
            session_id=session_id,
            working_dir=self.workspace,
            timeout=300
        )
        return response
        
    def _process_response(
        self, 
        response: Dict, 
        original_prompt: str
    ) -> str:
        """Process Claude response and update session"""
        # Extract key fields
        session_id = response.get("session_id")
        result = response.get("result") or response.get("message", "")
        
        # Update session tracker
        if session_id:
            self.session_tracker.update_session(
                session_id,
                original_prompt,
                result,
                response.get("metadata")
            )
        else:
            logger.warning(f"No session ID in response for agent {self.id}")
            
        return result
        
    def _update_metrics(self, response: Dict):
        """Update agent metrics from response"""
        if "metadata" in response:
            metadata = response["metadata"]
            if "tokens_used" in metadata:
                self.total_tokens += metadata["tokens_used"]
                
    async def _trigger_callbacks(
        self, 
        prompt: str, 
        result: str, 
        response: Dict
    ):
        """Trigger registered callbacks"""
        for callback in self._on_response_callbacks:
            try:
                await callback(self, prompt, result, response)
            except Exception as e:
                logger.error(f"Callback error: {e}")
                
    def on_response(self, callback: Callable):
        """Register callback for responses"""
        self._on_response_callbacks.append(callback)
        
    async def reset_session(self):
        """Reset agent session"""
        async with self._lock:
            self.session_tracker.reset()
            self.total_interactions = 0
            logger.info(f"Agent {self.id} session reset")
            
    async def cleanup(self):
        """Clean up agent resources"""
        async with self._lock:
            self.status = AgentStatus.TERMINATED
            
            if self.workspace:
                await self.workspace_manager.cleanup_workspace(
                    self.workspace
                )
                
            logger.info(f"Agent {self.id} cleaned up")
            
    def get_metrics(self) -> Dict[str, Any]:
        """Get agent metrics"""
        uptime = (datetime.now() - self.start_time).total_seconds()
        
        return {
            "agent_id": self.id,
            "status": self.status.value,
            "total_interactions": self.total_interactions,
            "total_tokens": self.total_tokens,
            "uptime_seconds": uptime,
            "current_session": self.session_tracker.get_current_session(),
            "session_count": len(self.session_tracker.get_session_chain())
        }
        
    def get_session_history(self) -> List[Dict]:
        """Get conversation history"""
        return [
            {
                "session_id": s.session_id,
                "prompt": s.last_prompt,
                "response": s.last_response,
                "timestamp": s.created_at.isoformat()
            }
            for s in self.session_tracker.get_session_chain()
        ]
        
    @asynccontextmanager
    async def task_context(self, task: TaskInput):
        """Context manager for task execution"""
        # Import task resources
        if task.files:
            for file_mapping in task.files:
                await self.workspace_manager.import_file(
                    self.workspace,
                    file_mapping
                )
                
        if task.folders:
            for folder_mapping in task.folders:
                await self.workspace_manager.import_folder(
                    self.workspace,
                    folder_mapping
                )
                
        if task.repos:
            for repo in task.repos:
                await self.workspace_manager.clone_repository(
                    self.workspace,
                    repo
                )
                
        try:
            yield self
        finally:
            # Cleanup task-specific resources if needed
            pass
```

### 2. Agent Factory and Builder
```python
# src/agent/factory.py
from typing import Optional, Dict, List
from pathlib import Path

from src.agent.core import Agent
from src.core.types import AgentConfig
from src.workspace.manager import WorkspaceManager
from src.shell.executor import ShellExecutor

class AgentBuilder:
    """Builder pattern for creating agents"""
    
    def __init__(self):
        self.id: Optional[str] = None
        self.system_prompt: Optional[str] = None
        self.working_dir: Optional[Path] = None
        self.allowed_tools: List[str] = []
        self.max_turns: int = 1
        self.workspace_manager: Optional[WorkspaceManager] = None
        self.shell_executor: Optional[ShellExecutor] = None
        
    def with_id(self, agent_id: str) -> 'AgentBuilder':
        self.id = agent_id
        return self
        
    def with_system_prompt(self, prompt: str) -> 'AgentBuilder':
        self.system_prompt = prompt
        return self
        
    def with_working_dir(self, path: Path) -> 'AgentBuilder':
        self.working_dir = path
        return self
        
    def with_allowed_tools(self, tools: List[str]) -> 'AgentBuilder':
        self.allowed_tools = tools
        return self
        
    def with_max_turns(self, turns: int) -> 'AgentBuilder':
        self.max_turns = turns
        return self
        
    def with_workspace_manager(self, manager: WorkspaceManager) -> 'AgentBuilder':
        self.workspace_manager = manager
        return self
        
    def with_shell_executor(self, executor: ShellExecutor) -> 'AgentBuilder':
        self.shell_executor = executor
        return self
        
    def build(self) -> Agent:
        """Build the agent"""
        if not self.id:
            raise ValueError("Agent ID is required")
            
        config = AgentConfig(
            id=self.id,
            system_prompt=self.system_prompt or "",
            working_dir=self.working_dir or Path.cwd(),
            allowed_tools=self.allowed_tools,
            max_turns=self.max_turns
        )
        
        return Agent(
            config=config,
            workspace_manager=self.workspace_manager,
            shell_executor=self.shell_executor
        )

class AgentFactory:
    """Factory for creating preconfigured agents"""
    
    @staticmethod
    def create_researcher() -> Agent:
        """Create a research-focused agent"""
        return (
            AgentBuilder()
            .with_id("researcher")
            .with_system_prompt(
                "You are a research assistant. Focus on finding accurate, "
                "relevant information and presenting it clearly."
            )
            .with_allowed_tools(["web_search", "read_file"])
            .build()
        )
        
    @staticmethod
    def create_developer() -> Agent:
        """Create a development-focused agent"""
        return (
            AgentBuilder()
            .with_id("developer")
            .with_system_prompt(
                "You are a software developer. Write clean, efficient, "
                "well-documented code following best practices."
            )
            .with_allowed_tools(["read_file", "write_file", "execute_command"])
            .with_max_turns(3)
            .build()
        )
        
    @staticmethod
    def create_analyst() -> Agent:
        """Create an analysis-focused agent"""
        return (
            AgentBuilder()
            .with_id("analyst")
            .with_system_prompt(
                "You are a data analyst. Analyze information thoroughly, "
                "identify patterns, and provide actionable insights."
            )
            .with_allowed_tools(["read_file", "execute_command"])
            .build()
        )
```

### 3. Agent Pool for Resource Management
```python
# src/agent/pool.py
import asyncio
from typing import Dict, Optional, List
from collections import deque
import logging

from src.agent.core import Agent
from src.core.types import AgentConfig

logger = logging.getLogger(__name__)

class AgentPool:
    """Manages a pool of reusable agents"""
    
    def __init__(self, max_agents: int = 10):
        self.max_agents = max_agents
        self.active_agents: Dict[str, Agent] = {}
        self.idle_agents: deque[Agent] = deque()
        self._lock = asyncio.Lock()
        self._agent_counter = 0
        
    async def acquire(
        self, 
        config: Optional[AgentConfig] = None,
        agent_id: Optional[str] = None
    ) -> Agent:
        """Acquire an agent from the pool"""
        async with self._lock:
            # Try to get specific agent if requested
            if agent_id and agent_id in self.active_agents:
                return self.active_agents[agent_id]
                
            # Try to reuse idle agent
            if self.idle_agents and not config:
                agent = self.idle_agents.popleft()
                self.active_agents[agent.id] = agent
                logger.info(f"Reused agent {agent.id} from pool")
                return agent
                
            # Create new agent if under limit
            if len(self.active_agents) < self.max_agents:
                if not config:
                    # Create default config
                    self._agent_counter += 1
                    config = AgentConfig(
                        id=f"pool-agent-{self._agent_counter}",
                        system_prompt="",
                        working_dir=Path("/tmp")
                    )
                    
                agent = Agent(config)
                await agent.initialize()
                self.active_agents[agent.id] = agent
                logger.info(f"Created new agent {agent.id}")
                return agent
                
            # Wait for available agent
            logger.warning("Agent pool exhausted, waiting...")
            while not self.idle_agents:
                await asyncio.sleep(0.1)
                
            agent = self.idle_agents.popleft()
            self.active_agents[agent.id] = agent
            return agent
            
    async def release(self, agent: Agent, cleanup: bool = False):
        """Release agent back to pool"""
        async with self._lock:
            if agent.id not in self.active_agents:
                logger.warning(f"Agent {agent.id} not in active pool")
                return
                
            del self.active_agents[agent.id]
            
            if cleanup or len(self.idle_agents) >= self.max_agents // 2:
                # Clean up agent
                await agent.cleanup()
                logger.info(f"Cleaned up agent {agent.id}")
            else:
                # Reset and return to pool
                await agent.reset_session()
                self.idle_agents.append(agent)
                logger.info(f"Returned agent {agent.id} to pool")
                
    async def cleanup_all(self):
        """Clean up all agents in pool"""
        async with self._lock:
            all_agents = list(self.active_agents.values()) + list(self.idle_agents)
            
        for agent in all_agents:
            try:
                await agent.cleanup()
            except Exception as e:
                logger.error(f"Error cleaning up agent {agent.id}: {e}")
                
        async with self._lock:
            self.active_agents.clear()
            self.idle_agents.clear()
            
        logger.info("Cleaned up all agents in pool")
```

### 4. Comprehensive Test Suite
```python
# tests/unit/test_agent.py
import pytest
from unittest.mock import Mock, AsyncMock, patch
from pathlib import Path

from src.agent.core import Agent
from src.core.types import AgentConfig, AgentStatus
from src.core.exceptions import AgentError

class TestAgent:
    
    @pytest.fixture
    def agent_config(self):
        return AgentConfig(
            id="test-agent",
            system_prompt="You are a test agent",
            working_dir=Path("/tmp/test")
        )
        
    @pytest.fixture
    def mock_shell_executor(self):
        executor = Mock()
        executor.execute_claude_async = AsyncMock()
        return executor
        
    @pytest.fixture
    def mock_workspace_manager(self):
        manager = Mock()
        manager.create_workspace = AsyncMock(
            return_value=Path("/tmp/test-workspace")
        )
        manager.cleanup_workspace = AsyncMock()
        return manager
        
    @pytest.fixture
    async def agent(self, agent_config, mock_shell_executor, mock_workspace_manager):
        agent = Agent(
            config=agent_config,
            shell_executor=mock_shell_executor,
            workspace_manager=mock_workspace_manager
        )
        await agent.initialize()
        return agent
        
    @pytest.mark.asyncio
    async def test_initialization(self, agent_config, mock_workspace_manager):
        agent = Agent(
            config=agent_config,
            workspace_manager=mock_workspace_manager
        )
        
        assert not agent.initialized
        assert agent.status == AgentStatus.IDLE
        
        await agent.initialize()
        
        assert agent.initialized
        assert agent.workspace is not None
        mock_workspace_manager.create_workspace.assert_called_once()
        
    @pytest.mark.asyncio
    async def test_ask_simple(self, agent, mock_shell_executor):
        # Mock response
        mock_shell_executor.execute_claude_async.return_value = {
            "session_id": "session-123",
            "result": "Hello! I can help with that.",
            "metadata": {"tokens_used": 10}
        }
        
        response = await agent.ask("Hello")
        
        assert response == "Hello! I can help with that."
        assert agent.total_interactions == 1
        assert agent.total_tokens == 10
        assert agent.session_tracker.get_current_session() == "session-123"
        
    @pytest.mark.asyncio
    async def test_ask_with_system_prompt(self, agent, mock_shell_executor):
        mock_shell_executor.execute_claude_async.return_value = {
            "session_id": "session-123",
            "result": "Response"
        }
        
        # First ask should include system prompt
        await agent.ask("First question")
        
        call_args = mock_shell_executor.execute_claude_async.call_args
        prompt = call_args[1]["prompt"]
        assert "You are a test agent" in prompt
        assert "First question" in prompt
        
        # Second ask should not include system prompt
        await agent.ask("Second question")
        
        call_args = mock_shell_executor.execute_claude_async.call_args
        prompt = call_args[1]["prompt"]
        assert "You are a test agent" not in prompt
        assert "Second question" in prompt
        
    @pytest.mark.asyncio
    async def test_session_continuity(self, agent, mock_shell_executor):
        # First interaction
        mock_shell_executor.execute_claude_async.return_value = {
            "session_id": "session-1",
            "result": "First response"
        }
        await agent.ask("First")
        
        # Second interaction should use previous session
        mock_shell_executor.execute_claude_async.return_value = {
            "session_id": "session-2",
            "result": "Second response"
        }
        await agent.ask("Second")
        
        # Check session was passed
        second_call = mock_shell_executor.execute_claude_async.call_args_list[1]
        assert second_call[1]["session_id"] == "session-1"
        
        # Check session chain
        history = agent.get_session_history()
        assert len(history) == 2
        assert history[0]["session_id"] == "session-1"
        assert history[1]["session_id"] == "session-2"
        
    @pytest.mark.asyncio
    async def test_error_handling(self, agent, mock_shell_executor):
        mock_shell_executor.execute_claude_async.side_effect = Exception("Test error")
        
        with pytest.raises(AgentError):
            await agent.ask("This will fail")
            
        assert agent.status == AgentStatus.IDLE  # Status reset after error
        
    @pytest.mark.asyncio
    async def test_metrics(self, agent, mock_shell_executor):
        mock_shell_executor.execute_claude_async.return_value = {
            "session_id": "session-1",
            "result": "Response",
            "metadata": {"tokens_used": 25}
        }
        
        await agent.ask("Question 1")
        await agent.ask("Question 2")
        
        metrics = agent.get_metrics()
        
        assert metrics["agent_id"] == "test-agent"
        assert metrics["total_interactions"] == 2
        assert metrics["total_tokens"] == 50
        assert metrics["session_count"] == 2
        assert metrics["status"] == "idle"
        
    @pytest.mark.asyncio
    async def test_cleanup(self, agent, mock_workspace_manager):
        await agent.cleanup()
        
        assert agent.status == AgentStatus.TERMINATED
        mock_workspace_manager.cleanup_workspace.assert_called_once()
```

### 5. Integration Tests
```python
# tests/integration/test_agent_integration.py
import pytest
import asyncio
from pathlib import Path

from src.agent.core import Agent
from src.agent.factory import AgentFactory
from src.agent.pool import AgentPool
from src.core.types import AgentConfig, TaskInput, FileMapping

@pytest.mark.integration
class TestAgentIntegration:
    
    @pytest.mark.asyncio
    async def test_agent_conversation(self, tmp_path):
        """Test real conversation flow"""
        config = AgentConfig(
            id="conversation-test",
            system_prompt="You are a helpful assistant with perfect memory.",
            working_dir=tmp_path
        )
        
        agent = Agent(config)
        await agent.initialize()
        
        # Have a conversation
        response1 = await agent.ask("My favorite color is purple")
        assert response1
        
        response2 = await agent.ask("What's my favorite color?")
        assert "purple" in response2.lower()
        
        # Check metrics
        metrics = agent.get_metrics()
        assert metrics["total_interactions"] == 2
        assert metrics["session_count"] == 2
        
        await agent.cleanup()
        
    @pytest.mark.asyncio
    async def test_agent_factory(self):
        """Test factory-created agents"""
        researcher = AgentFactory.create_researcher()
        developer = AgentFactory.create_developer()
        
        assert researcher.id == "researcher"
        assert developer.id == "developer"
        assert "research" in researcher.system_prompt.lower()
        assert "developer" in developer.system_prompt.lower()
        
    @pytest.mark.asyncio
    async def test_agent_pool(self):
        """Test agent pool management"""
        pool = AgentPool(max_agents=3)
        
        # Acquire agents
        agents = []
        for i in range(3):
            agent = await pool.acquire()
            agents.append(agent)
            
        assert len(pool.active_agents) == 3
        assert len(pool.idle_agents) == 0
        
        # Release one back
        await pool.release(agents[0])
        
        assert len(pool.active_agents) == 2
        assert len(pool.idle_agents) == 1
        
        # Cleanup
        await pool.cleanup_all()
```

### 6. Example Usage
```python
# examples/agent_usage.py
import asyncio
from src.agent.factory import AgentFactory
from src.core.types import TaskInput, FileMapping

async def main():
    # Create a developer agent
    agent = AgentFactory.create_developer()
    await agent.initialize()
    
    # Simple conversation
    print("=== Simple Conversation ===")
    response = await agent.ask("Write a Python function to calculate fibonacci numbers")
    print(f"Response: {response[:200]}...")
    
    # Multi-turn conversation
    print("\n=== Multi-turn Conversation ===")
    response = await agent.ask("Now optimize it using memoization")
    print(f"Response: {response[:200]}...")
    
    # With task context
    print("\n=== Task with Resources ===")
    task = TaskInput(
        prompt="Analyze the code in main.py and suggest improvements",
        files=[
            FileMapping(
                name="main.py",
                src_path="/path/to/main.py",
                dest_path="code/main.py"
            )
        ]
    )
    
    async with agent.task_context(task) as agent_ctx:
        response = await agent_ctx.ask(task.prompt)
        print(f"Analysis: {response[:300]}...")
    
    # Get metrics
    print("\n=== Agent Metrics ===")
    metrics = agent.get_metrics()
    print(f"Total interactions: {metrics['total_interactions']}")
    print(f"Total tokens: {metrics['total_tokens']}")
    print(f"Session count: {metrics['session_count']}")
    
    # Cleanup
    await agent.cleanup()

if __name__ == "__main__":
    asyncio.run(main())
```

## Success Criteria
- [ ] Agent class integrates all components seamlessly
- [ ] Session continuity maintained across interactions
- [ ] System prompt included only on first interaction
- [ ] Metrics tracked accurately
- [ ] Resource lifecycle managed properly
- [ ] Factory creates specialized agents
- [ ] Pool manages agent resources efficiently
- [ ] All tests passing with good coverage

## Next Steps
With the core Agent implementation complete, Step 5 will build the Orchestrator for managing multiple agents and complex workflows.