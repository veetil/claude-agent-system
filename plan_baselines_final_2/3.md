# Step 3: Workspace Management and Resource Handling

## Overview
Implement the Workspace Manager that provides isolated working directories for each agent, handles file/folder mapping, repository cloning, and resource lifecycle management.

## Objectives
1. Create isolated workspace environments for agents
2. Implement secure file/folder mapping operations  
3. Build Git repository cloning functionality
4. Handle resource cleanup and lifecycle
5. Ensure workspace consistency for sessions

## Implementation Tasks

### 1. Workspace Manager Core
```python
# src/workspace/manager.py
import os
import shutil
import tempfile
import logging
from pathlib import Path
from typing import List, Optional, Dict, Set
import asyncio
import subprocess
from datetime import datetime
import hashlib

from src.core.types import FolderMapping, FileMapping, GitHubRepo
from src.core.exceptions import WorkspaceError

logger = logging.getLogger(__name__)

class WorkspaceManager:
    """Manages isolated workspaces for agents"""
    
    def __init__(self, base_dir: Optional[Path] = None):
        self.base_dir = base_dir or Path("/tmp/claude-agents")
        self.base_dir.mkdir(parents=True, exist_ok=True)
        self.active_workspaces: Set[Path] = set()
        self._lock = asyncio.Lock()
        
    async def create_workspace(
        self, 
        agent_id: str,
        persistent: bool = True
    ) -> Path:
        """Create isolated workspace for an agent"""
        async with self._lock:
            if persistent:
                # Consistent path for session persistence
                workspace = self.base_dir / f"agent_{agent_id}"
            else:
                # Temporary workspace
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                workspace = self.base_dir / f"agent_{agent_id}_{timestamp}"
                
            workspace.mkdir(parents=True, exist_ok=True)
            
            # Create standard subdirectories
            (workspace / "workspace").mkdir(exist_ok=True)
            (workspace / "imports").mkdir(exist_ok=True)
            (workspace / "repos").mkdir(exist_ok=True)
            (workspace / ".claude").mkdir(exist_ok=True)
            
            self.active_workspaces.add(workspace)
            
            logger.info(f"Created workspace for {agent_id}: {workspace}")
            return workspace
            
    async def import_file(
        self,
        workspace: Path,
        file_mapping: FileMapping
    ) -> Path:
        """Import a file into agent workspace"""
        src_path = Path(file_mapping.src_path)
        
        if not src_path.exists():
            raise WorkspaceError(f"Source file not found: {src_path}")
            
        # Validate destination path
        dest_path = self._validate_dest_path(
            workspace, 
            file_mapping.dest_path
        )
        
        # Create parent directories
        dest_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Copy file
        try:
            shutil.copy2(src_path, dest_path)
            logger.info(f"Imported file: {src_path} -> {dest_path}")
            return dest_path
        except Exception as e:
            raise WorkspaceError(f"Failed to import file: {e}")
            
    async def import_folder(
        self,
        workspace: Path,
        folder_mapping: FolderMapping
    ) -> Path:
        """Import a folder into agent workspace"""
        src_path = Path(folder_mapping.src_path)
        
        if not src_path.exists():
            raise WorkspaceError(f"Source folder not found: {src_path}")
            
        # Validate destination path
        dest_path = self._validate_dest_path(
            workspace,
            folder_mapping.dest_path
        )
        
        # Copy folder
        try:
            if dest_path.exists():
                shutil.rmtree(dest_path)
            shutil.copytree(src_path, dest_path)
            logger.info(f"Imported folder: {src_path} -> {dest_path}")
            return dest_path
        except Exception as e:
            raise WorkspaceError(f"Failed to import folder: {e}")
            
    async def clone_repository(
        self,
        workspace: Path,
        repo: GitHubRepo
    ) -> Path:
        """Clone a GitHub repository into workspace"""
        # Validate destination
        dest_path = self._validate_dest_path(
            workspace / "repos",
            repo.dest_path
        )
        
        # Build git command
        cmd = ["git", "clone"]
        
        if repo.branch:
            cmd.extend(["-b", repo.branch])
            
        cmd.extend([repo.url, str(dest_path)])
        
        try:
            # Run git clone
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await proc.communicate()
            
            if proc.returncode != 0:
                raise WorkspaceError(
                    f"Git clone failed: {stderr.decode()}"
                )
                
            logger.info(f"Cloned repository: {repo.url} -> {dest_path}")
            return dest_path
            
        except Exception as e:
            raise WorkspaceError(f"Failed to clone repository: {e}")
            
    def _validate_dest_path(
        self, 
        workspace: Path, 
        dest_path: str
    ) -> Path:
        """Validate and resolve destination path"""
        # Remove leading slashes and normalize
        clean_path = Path(dest_path.lstrip('/'))
        
        # Ensure path doesn't escape workspace
        full_path = (workspace / clean_path).resolve()
        
        if not str(full_path).startswith(str(workspace)):
            raise WorkspaceError(
                f"Destination path escapes workspace: {dest_path}"
            )
            
        return full_path
        
    async def cleanup_workspace(
        self, 
        workspace: Path,
        force: bool = False
    ):
        """Clean up agent workspace"""
        async with self._lock:
            if workspace not in self.active_workspaces and not force:
                logger.warning(f"Workspace not active: {workspace}")
                return
                
            try:
                if workspace.exists():
                    shutil.rmtree(workspace)
                    logger.info(f"Cleaned up workspace: {workspace}")
                    
                self.active_workspaces.discard(workspace)
                
            except Exception as e:
                logger.error(f"Failed to cleanup workspace: {e}")
                if not force:
                    raise WorkspaceError(f"Cleanup failed: {e}")
                    
    async def get_workspace_info(self, workspace: Path) -> Dict:
        """Get information about a workspace"""
        if not workspace.exists():
            raise WorkspaceError(f"Workspace not found: {workspace}")
            
        info = {
            "path": str(workspace),
            "size_bytes": 0,
            "file_count": 0,
            "subdirectories": []
        }
        
        # Calculate size and count files
        for root, dirs, files in os.walk(workspace):
            info["file_count"] += len(files)
            for file in files:
                file_path = Path(root) / file
                if file_path.exists():
                    info["size_bytes"] += file_path.stat().st_size
                    
        # List immediate subdirectories
        info["subdirectories"] = [
            d.name for d in workspace.iterdir() if d.is_dir()
        ]
        
        return info
        
    async def cleanup_all(self):
        """Clean up all active workspaces"""
        async with self._lock:
            workspaces = list(self.active_workspaces)
            
        for workspace in workspaces:
            await self.cleanup_workspace(workspace, force=True)
            
        logger.info("Cleaned up all workspaces")
```

### 2. Resource Lifecycle Manager
```python
# src/workspace/lifecycle.py
import asyncio
from typing import Dict, Optional, Set
from pathlib import Path
from datetime import datetime, timedelta
import logging

from src.workspace.manager import WorkspaceManager

logger = logging.getLogger(__name__)

class ResourceLifecycleManager:
    """Manages lifecycle of agent resources"""
    
    def __init__(self, workspace_manager: WorkspaceManager):
        self.workspace_manager = workspace_manager
        self.resource_registry: Dict[str, 'ResourceInfo'] = {}
        self._cleanup_task: Optional[asyncio.Task] = None
        self._lock = asyncio.Lock()
        
    async def register_resource(
        self,
        agent_id: str,
        workspace: Path,
        ttl_hours: Optional[int] = None
    ):
        """Register a resource for lifecycle management"""
        async with self._lock:
            self.resource_registry[agent_id] = ResourceInfo(
                agent_id=agent_id,
                workspace=workspace,
                created_at=datetime.now(),
                ttl_hours=ttl_hours or 24,
                last_accessed=datetime.now()
            )
            
    async def touch_resource(self, agent_id: str):
        """Update last access time"""
        async with self._lock:
            if agent_id in self.resource_registry:
                self.resource_registry[agent_id].last_accessed = datetime.now()
                
    async def start_cleanup_daemon(self, interval_minutes: int = 60):
        """Start background cleanup process"""
        if self._cleanup_task and not self._cleanup_task.done():
            logger.warning("Cleanup daemon already running")
            return
            
        self._cleanup_task = asyncio.create_task(
            self._cleanup_loop(interval_minutes)
        )
        logger.info("Started resource cleanup daemon")
        
    async def stop_cleanup_daemon(self):
        """Stop background cleanup process"""
        if self._cleanup_task:
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            logger.info("Stopped resource cleanup daemon")
            
    async def _cleanup_loop(self, interval_minutes: int):
        """Background cleanup loop"""
        while True:
            try:
                await asyncio.sleep(interval_minutes * 60)
                await self._cleanup_expired_resources()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Cleanup error: {e}")
                
    async def _cleanup_expired_resources(self):
        """Clean up resources past their TTL"""
        now = datetime.now()
        expired = []
        
        async with self._lock:
            for agent_id, info in self.resource_registry.items():
                expiry = info.last_accessed + timedelta(hours=info.ttl_hours)
                if now > expiry:
                    expired.append((agent_id, info))
                    
        for agent_id, info in expired:
            try:
                await self.workspace_manager.cleanup_workspace(
                    info.workspace
                )
                async with self._lock:
                    del self.resource_registry[agent_id]
                logger.info(f"Cleaned up expired resource: {agent_id}")
            except Exception as e:
                logger.error(f"Failed to cleanup {agent_id}: {e}")

class ResourceInfo:
    """Information about a managed resource"""
    def __init__(
        self,
        agent_id: str,
        workspace: Path,
        created_at: datetime,
        ttl_hours: int,
        last_accessed: datetime
    ):
        self.agent_id = agent_id
        self.workspace = workspace
        self.created_at = created_at
        self.ttl_hours = ttl_hours
        self.last_accessed = last_accessed
```

### 3. Workspace Security and Sandboxing
```python
# src/workspace/security.py
import os
import stat
from pathlib import Path
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

class WorkspaceSecurity:
    """Security measures for workspace isolation"""
    
    FORBIDDEN_PATHS = [
        "/etc", "/usr", "/bin", "/sbin", "/root",
        "/System", "/Library", "/Applications"
    ]
    
    @staticmethod
    def validate_path(path: Path) -> bool:
        """Validate path doesn't access forbidden locations"""
        resolved = path.resolve()
        path_str = str(resolved)
        
        for forbidden in WorkspaceSecurity.FORBIDDEN_PATHS:
            if path_str.startswith(forbidden):
                logger.warning(f"Blocked access to forbidden path: {path}")
                return False
                
        return True
        
    @staticmethod
    def set_workspace_permissions(workspace: Path):
        """Set restrictive permissions on workspace"""
        try:
            # Owner read/write/execute only
            os.chmod(workspace, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
            
            # Apply to all subdirectories
            for root, dirs, files in os.walk(workspace):
                for d in dirs:
                    dir_path = Path(root) / d
                    os.chmod(dir_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
                for f in files:
                    file_path = Path(root) / f
                    os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR)
                    
        except Exception as e:
            logger.error(f"Failed to set permissions: {e}")
            
    @staticmethod
    def create_sandbox_config(workspace: Path) -> Dict:
        """Create sandbox configuration for agent"""
        return {
            "allowed_paths": [str(workspace)],
            "forbidden_commands": [
                "rm -rf /",
                "sudo",
                "su",
                "chmod 777"
            ],
            "environment": {
                "HOME": str(workspace),
                "TMPDIR": str(workspace / "tmp"),
                "PATH": "/usr/local/bin:/usr/bin:/bin"
            }
        }
```

### 4. Comprehensive Test Suite
```python
# tests/unit/test_workspace_manager.py
import pytest
import tempfile
from pathlib import Path
import shutil

from src.workspace.manager import WorkspaceManager
from src.core.types import FileMapping, FolderMapping, GitHubRepo
from src.core.exceptions import WorkspaceError

class TestWorkspaceManager:
    
    @pytest.fixture
    def manager(self, tmp_path):
        return WorkspaceManager(tmp_path)
        
    @pytest.fixture
    def sample_file(self, tmp_path):
        file_path = tmp_path / "sample.txt"
        file_path.write_text("Sample content")
        return file_path
        
    @pytest.fixture
    def sample_folder(self, tmp_path):
        folder = tmp_path / "sample_folder"
        folder.mkdir()
        (folder / "file1.txt").write_text("File 1")
        (folder / "file2.txt").write_text("File 2")
        return folder
        
    @pytest.mark.asyncio
    async def test_create_workspace(self, manager):
        workspace = await manager.create_workspace("test-agent")
        
        assert workspace.exists()
        assert (workspace / "workspace").exists()
        assert (workspace / "imports").exists()
        assert (workspace / "repos").exists()
        assert workspace in manager.active_workspaces
        
    @pytest.mark.asyncio
    async def test_import_file(self, manager, sample_file):
        workspace = await manager.create_workspace("test-agent")
        
        mapping = FileMapping(
            name="sample.txt",
            src_path=str(sample_file),
            dest_path="imports/sample.txt"
        )
        
        dest = await manager.import_file(workspace, mapping)
        
        assert dest.exists()
        assert dest.read_text() == "Sample content"
        assert dest.parent.name == "imports"
        
    @pytest.mark.asyncio
    async def test_import_folder(self, manager, sample_folder):
        workspace = await manager.create_workspace("test-agent")
        
        mapping = FolderMapping(
            name="sample_folder",
            src_path=str(sample_folder),
            dest_path="imports/data"
        )
        
        dest = await manager.import_folder(workspace, mapping)
        
        assert dest.exists()
        assert (dest / "file1.txt").exists()
        assert (dest / "file2.txt").read_text() == "File 2"
        
    @pytest.mark.asyncio
    async def test_path_traversal_protection(self, manager, sample_file):
        workspace = await manager.create_workspace("test-agent")
        
        # Try to escape workspace
        mapping = FileMapping(
            name="evil.txt",
            src_path=str(sample_file),
            dest_path="../../evil.txt"
        )
        
        with pytest.raises(WorkspaceError, match="escapes workspace"):
            await manager.import_file(workspace, mapping)
            
    @pytest.mark.asyncio
    async def test_cleanup_workspace(self, manager):
        workspace = await manager.create_workspace("test-agent")
        test_file = workspace / "test.txt"
        test_file.write_text("test")
        
        await manager.cleanup_workspace(workspace)
        
        assert not workspace.exists()
        assert workspace not in manager.active_workspaces
        
    @pytest.mark.asyncio
    async def test_workspace_info(self, manager):
        workspace = await manager.create_workspace("test-agent")
        
        # Add some content
        (workspace / "file1.txt").write_text("Hello")
        (workspace / "file2.txt").write_text("World")
        
        info = await manager.get_workspace_info(workspace)
        
        assert info["file_count"] >= 2
        assert info["size_bytes"] >= 10
        assert "workspace" in info["subdirectories"]
```

### 5. Integration Tests
```python
# tests/integration/test_workspace_integration.py
import pytest
import asyncio
from pathlib import Path

from src.workspace.manager import WorkspaceManager
from src.workspace.lifecycle import ResourceLifecycleManager
from src.core.types import GitHubRepo

@pytest.mark.integration
class TestWorkspaceIntegration:
    
    @pytest.mark.asyncio
    async def test_git_clone(self, tmp_path):
        """Test real git clone operation"""
        manager = WorkspaceManager(tmp_path)
        workspace = await manager.create_workspace("git-test")
        
        repo = GitHubRepo(
            url="https://github.com/octocat/Hello-World.git",
            dest_path="hello-world"
        )
        
        dest = await manager.clone_repository(workspace, repo)
        
        assert dest.exists()
        assert (dest / "README").exists()
        
    @pytest.mark.asyncio
    async def test_lifecycle_management(self, tmp_path):
        """Test resource lifecycle with TTL"""
        manager = WorkspaceManager(tmp_path)
        lifecycle = ResourceLifecycleManager(manager)
        
        # Create workspace with short TTL
        workspace = await manager.create_workspace("ttl-test")
        await lifecycle.register_resource(
            "ttl-test",
            workspace,
            ttl_hours=0.001  # Very short for testing
        )
        
        # Start cleanup daemon
        await lifecycle.start_cleanup_daemon(interval_minutes=0.01)
        
        # Wait for cleanup
        await asyncio.sleep(0.1)
        
        # Verify cleanup
        assert not workspace.exists()
        
        await lifecycle.stop_cleanup_daemon()
```

### 6. Example Usage
```python
# examples/workspace_usage.py
import asyncio
from pathlib import Path

from src.workspace.manager import WorkspaceManager
from src.core.types import FileMapping, FolderMapping, GitHubRepo

async def main():
    # Create workspace manager
    manager = WorkspaceManager()
    
    # Create agent workspace
    workspace = await manager.create_workspace("example-agent")
    print(f"Created workspace: {workspace}")
    
    # Import a file
    file_mapping = FileMapping(
        name="config.yaml",
        src_path="/path/to/config.yaml",
        dest_path="config/config.yaml"
    )
    await manager.import_file(workspace, file_mapping)
    
    # Import a folder
    folder_mapping = FolderMapping(
        name="data",
        src_path="/path/to/data",
        dest_path="data"
    )
    await manager.import_folder(workspace, folder_mapping)
    
    # Clone a repository
    repo = GitHubRepo(
        url="https://github.com/example/repo.git",
        dest_path="code/repo",
        branch="main"
    )
    await manager.clone_repository(workspace, repo)
    
    # Get workspace info
    info = await manager.get_workspace_info(workspace)
    print(f"Workspace info: {info}")
    
    # Cleanup when done
    await manager.cleanup_workspace(workspace)
    
if __name__ == "__main__":
    asyncio.run(main())
```

## Success Criteria
- [ ] Workspace creation with proper structure
- [ ] Secure file/folder import with path validation
- [ ] Git repository cloning functionality
- [ ] Resource lifecycle management with TTL
- [ ] Path traversal protection
- [ ] Comprehensive cleanup procedures
- [ ] All tests passing with good coverage

## Next Steps
With workspace management complete, Step 4 will implement the core Agent class that combines shell execution, session tracking, and workspace management.