# Step 3a: Multi-Agent Terminal Management and Process Isolation

## Objective
Design and implement a robust terminal management system that handles multiple concurrent agents, each with isolated execution environments and dedicated terminal sessions.

## Critical Design Considerations

### 1. Terminal Allocation Strategies

#### 1.1 Dedicated Terminal per Agent
```typescript
// src/terminal/terminal-pool.ts
export interface ITerminalPool {
  allocate(agentId: string): Promise<ITerminalSession>;
  release(agentId: string): Promise<void>;
  getActiveCount(): number;
  getTerminalForAgent(agentId: string): ITerminalSession | undefined;
}

export interface ITerminalSession {
  id: string;
  agentId: string;
  workingDirectory: string;
  env: Record<string, string>;
  createdAt: Date;
  lastUsed: Date;
  execute(command: string): Promise<ICommandResult>;
  getOutput(): string[];
  clear(): void;
  destroy(): void;
}
```

#### 1.2 Virtual Terminal Implementation
```typescript
// src/terminal/virtual-terminal.ts
import { spawn, ChildProcess } from 'child_process';
import { v4 as uuidv4 } from 'uuid';
import * as path from 'path';
import * as fs from 'fs/promises';

export class VirtualTerminal implements ITerminalSession {
  public readonly id: string;
  public readonly agentId: string;
  public readonly workingDirectory: string;
  public readonly env: Record<string, string>;
  public readonly createdAt: Date;
  public lastUsed: Date;

  private shell?: ChildProcess;
  private outputBuffer: string[] = [];
  private commandQueue: IQueuedCommand[] = [];
  private isProcessing = false;
  private destroyed = false;

  constructor(agentId: string, config: ITerminalConfig) {
    this.id = `term_${uuidv4()}`;
    this.agentId = agentId;
    this.createdAt = new Date();
    this.lastUsed = new Date();
    
    // Create isolated working directory
    this.workingDirectory = path.join(
      config.baseWorkDir || '/tmp/claude-agents',
      agentId,
      this.id
    );
    
    // Isolated environment
    this.env = {
      ...process.env,
      ...config.env,
      CLAUDE_AGENT_ID: agentId,
      CLAUDE_TERMINAL_ID: this.id,
      HOME: this.workingDirectory,
      PWD: this.workingDirectory
    };
  }

  async initialize(): Promise<void> {
    // Create working directory
    await fs.mkdir(this.workingDirectory, { recursive: true });
    
    // Initialize shell process
    this.shell = spawn(this.getShell(), ['-i'], {
      cwd: this.workingDirectory,
      env: this.env,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    this.setupOutputCapture();
    
    // Wait for shell to be ready
    await this.waitForReady();
  }

  async execute(command: string): Promise<ICommandResult> {
    if (this.destroyed) {
      throw new Error('Terminal has been destroyed');
    }

    this.lastUsed = new Date();

    return new Promise((resolve, reject) => {
      const queuedCommand: IQueuedCommand = {
        id: uuidv4(),
        command,
        resolve,
        reject,
        startTime: Date.now()
      };

      this.commandQueue.push(queuedCommand);
      this.processQueue();
    });
  }

  getOutput(): string[] {
    return [...this.outputBuffer];
  }

  clear(): void {
    this.outputBuffer = [];
  }

  async destroy(): Promise<void> {
    this.destroyed = true;
    
    if (this.shell) {
      this.shell.kill('SIGTERM');
      
      // Force kill after timeout
      setTimeout(() => {
        if (this.shell && !this.shell.killed) {
          this.shell.kill('SIGKILL');
        }
      }, 5000);
    }

    // Clean up working directory
    try {
      await fs.rm(this.workingDirectory, { recursive: true, force: true });
    } catch (error) {
      console.error('Failed to clean up working directory:', error);
    }
  }

  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.commandQueue.length === 0) {
      return;
    }

    this.isProcessing = true;
    const command = this.commandQueue.shift()!;

    try {
      const result = await this.executeCommand(command);
      command.resolve(result);
    } catch (error) {
      command.reject(error);
    } finally {
      this.isProcessing = false;
      // Process next command
      this.processQueue();
    }
  }

  private async executeCommand(queuedCommand: IQueuedCommand): Promise<ICommandResult> {
    const { command, id, startTime } = queuedCommand;
    
    // Add command delimiter for parsing
    const delimiter = `<<<CLAUDE_CMD_${id}>>>`;
    const fullCommand = `echo "${delimiter}_START"; ${command}; echo -e "\\n${delimiter}_END:$?"`;

    // Write command to shell
    this.shell!.stdin!.write(fullCommand + '\n');

    // Wait for command completion
    const output = await this.waitForCommandOutput(delimiter);
    const duration = Date.now() - startTime;

    return {
      command,
      output: output.stdout,
      error: output.stderr,
      exitCode: output.exitCode,
      duration
    };
  }

  private async waitForCommandOutput(delimiter: string): Promise<{
    stdout: string;
    stderr: string;
    exitCode: number;
  }> {
    const startMarker = `${delimiter}_START`;
    const endMarker = `${delimiter}_END:`;
    
    let stdout = '';
    let stderr = '';
    let capturing = false;
    let exitCode = 0;

    return new Promise((resolve) => {
      const outputHandler = (data: Buffer) => {
        const lines = data.toString().split('\n');
        
        for (const line of lines) {
          if (line.includes(startMarker)) {
            capturing = true;
            continue;
          }
          
          if (line.includes(endMarker)) {
            exitCode = parseInt(line.split(endMarker)[1]) || 0;
            capturing = false;
            
            // Remove handler and resolve
            this.shell!.stdout!.removeListener('data', outputHandler);
            this.shell!.stderr!.removeListener('data', errorHandler);
            
            resolve({ stdout, stderr, exitCode });
            return;
          }
          
          if (capturing) {
            stdout += line + '\n';
            this.outputBuffer.push(line);
          }
        }
      };

      const errorHandler = (data: Buffer) => {
        if (capturing) {
          stderr += data.toString();
        }
      };

      this.shell!.stdout!.on('data', outputHandler);
      this.shell!.stderr!.on('data', errorHandler);
    });
  }

  private setupOutputCapture(): void {
    // Capture all output for history
    this.shell!.stdout!.on('data', (data) => {
      const lines = data.toString().split('\n').filter(line => line.trim());
      this.outputBuffer.push(...lines);
      
      // Limit buffer size
      if (this.outputBuffer.length > 10000) {
        this.outputBuffer = this.outputBuffer.slice(-5000);
      }
    });

    this.shell!.stderr!.on('data', (data) => {
      const lines = data.toString().split('\n').filter(line => line.trim());
      this.outputBuffer.push(...lines.map(line => `[ERROR] ${line}`));
    });
  }

  private async waitForReady(): Promise<void> {
    // Send a test command to ensure shell is ready
    const testCommand = 'echo "READY"';
    const result = await this.execute(testCommand);
    
    if (!result.output.includes('READY')) {
      throw new Error('Failed to initialize terminal');
    }
  }

  private getShell(): string {
    return process.env.SHELL || '/bin/bash';
  }
}

interface IQueuedCommand {
  id: string;
  command: string;
  resolve: (result: ICommandResult) => void;
  reject: (error: Error) => void;
  startTime: number;
}

interface ICommandResult {
  command: string;
  output: string;
  error: string;
  exitCode: number;
  duration: number;
}
```

### 2. Terminal Pool Management
```typescript
// src/terminal/terminal-pool-manager.ts
export class TerminalPoolManager implements ITerminalPool {
  private terminals = new Map<string, VirtualTerminal>();
  private agentToTerminal = new Map<string, string>();
  private readonly maxTerminals: number;
  private readonly maxIdleTime: number;

  constructor(
    private logger: Logger,
    config: ITerminalPoolConfig
  ) {
    this.maxTerminals = config.maxTerminals || 50;
    this.maxIdleTime = config.maxIdleTime || 30 * 60 * 1000; // 30 minutes
    
    this.startCleanupTimer();
  }

  async allocate(agentId: string): Promise<ITerminalSession> {
    // Check if agent already has a terminal
    const existingTerminalId = this.agentToTerminal.get(agentId);
    if (existingTerminalId) {
      const terminal = this.terminals.get(existingTerminalId);
      if (terminal) {
        terminal.lastUsed = new Date();
        return terminal;
      }
    }

    // Check capacity
    if (this.terminals.size >= this.maxTerminals) {
      await this.evictLeastRecentlyUsed();
    }

    // Create new terminal
    const terminal = new VirtualTerminal(agentId, {
      baseWorkDir: '/tmp/claude-agents',
      env: {
        NODE_ENV: 'agent',
        CLAUDE_EXECUTION_MODE: 'isolated'
      }
    });

    await terminal.initialize();

    this.terminals.set(terminal.id, terminal);
    this.agentToTerminal.set(agentId, terminal.id);

    this.logger.info('Allocated terminal for agent', {
      agentId,
      terminalId: terminal.id,
      activeTerminals: this.terminals.size
    });

    return terminal;
  }

  async release(agentId: string): Promise<void> {
    const terminalId = this.agentToTerminal.get(agentId);
    if (!terminalId) return;

    const terminal = this.terminals.get(terminalId);
    if (terminal) {
      await terminal.destroy();
      this.terminals.delete(terminalId);
    }

    this.agentToTerminal.delete(agentId);

    this.logger.info('Released terminal', {
      agentId,
      terminalId,
      remainingTerminals: this.terminals.size
    });
  }

  getActiveCount(): number {
    return this.terminals.size;
  }

  getTerminalForAgent(agentId: string): ITerminalSession | undefined {
    const terminalId = this.agentToTerminal.get(agentId);
    return terminalId ? this.terminals.get(terminalId) : undefined;
  }

  async shutdown(): Promise<void> {
    this.logger.info('Shutting down terminal pool', {
      activeTerminals: this.terminals.size
    });

    // Destroy all terminals
    const destroyPromises = Array.from(this.terminals.values()).map(
      terminal => terminal.destroy()
    );

    await Promise.all(destroyPromises);

    this.terminals.clear();
    this.agentToTerminal.clear();
  }

  private async evictLeastRecentlyUsed(): Promise<void> {
    let oldestTerminal: VirtualTerminal | undefined;
    let oldestTime = Date.now();

    for (const terminal of this.terminals.values()) {
      if (terminal.lastUsed.getTime() < oldestTime) {
        oldestTime = terminal.lastUsed.getTime();
        oldestTerminal = terminal;
      }
    }

    if (oldestTerminal) {
      await this.release(oldestTerminal.agentId);
    }
  }

  private startCleanupTimer(): void {
    setInterval(async () => {
      const now = Date.now();
      const toRemove: string[] = [];

      for (const [terminalId, terminal] of this.terminals.entries()) {
        if (now - terminal.lastUsed.getTime() > this.maxIdleTime) {
          toRemove.push(terminal.agentId);
        }
      }

      for (const agentId of toRemove) {
        await this.release(agentId);
        this.logger.info('Evicted idle terminal', { agentId });
      }
    }, 60000); // Check every minute
  }
}
```

### 3. Claude CLI Integration with Terminal Management
```typescript
// src/cli/terminal-aware-cli-manager.ts
export class TerminalAwareCLIManager extends CLIProcessManager {
  constructor(
    logger: Logger,
    private terminalPool: ITerminalPool,
    options?: IProcessOptions
  ) {
    super(logger, options);
  }

  async createSession(config: ISessionConfig): Promise<ClaudeSDKResponse> {
    // Get or create terminal for the requesting agent
    const agentId = config.metadata?.agentId;
    if (!agentId) {
      throw new Error('Agent ID required for terminal allocation');
    }

    const terminal = await this.terminalPool.allocate(agentId);
    
    // Override working directory with terminal's isolated directory
    const enhancedConfig: ISessionConfig = {
      ...config,
      workingDirectory: terminal.workingDirectory,
      env: {
        ...config.env,
        ...terminal.env
      }
    };

    return super.createSession(enhancedConfig);
  }

  async execute(config: IExecutionConfig): Promise<ClaudeSDKResponse> {
    // Ensure terminal context is maintained
    const agentId = config.metadata?.agentId;
    if (agentId) {
      const terminal = this.terminalPool.getTerminalForAgent(agentId);
      if (terminal) {
        config.workingDirectory = terminal.workingDirectory;
        config.env = { ...config.env, ...terminal.env };
      }
    }

    return super.execute(config);
  }
}
```

### 4. Docker-based Isolation (Advanced)
```typescript
// src/terminal/docker-terminal.ts
export class DockerTerminal implements ITerminalSession {
  private container?: Docker.Container;
  private readonly imageName = 'claude-agent-sandbox:latest';

  async initialize(): Promise<void> {
    const docker = new Docker();
    
    // Create container with resource limits
    this.container = await docker.createContainer({
      Image: this.imageName,
      name: `claude-agent-${this.agentId}`,
      WorkingDir: '/workspace',
      Env: Object.entries(this.env).map(([k, v]) => `${k}=${v}`),
      HostConfig: {
        Memory: 512 * 1024 * 1024, // 512MB
        CpuShares: 512, // Half CPU
        ReadonlyRootfs: false,
        Tmpfs: {
          '/tmp': 'rw,noexec,nosuid,size=100m'
        },
        Binds: [
          `${this.workingDirectory}:/workspace:rw`
        ],
        NetworkMode: 'none' // No network access by default
      },
      AttachStdin: true,
      AttachStdout: true,
      AttachStderr: true,
      Tty: true,
      OpenStdin: true,
      StdinOnce: false
    });

    await this.container.start();
  }

  async execute(command: string): Promise<ICommandResult> {
    if (!this.container) {
      throw new Error('Container not initialized');
    }

    const exec = await this.container.exec({
      Cmd: ['/bin/bash', '-c', command],
      WorkingDir: '/workspace',
      AttachStdout: true,
      AttachStderr: true
    });

    const stream = await exec.start({ Detach: false });
    
    return new Promise((resolve, reject) => {
      let stdout = '';
      let stderr = '';
      
      stream.on('data', (chunk: Buffer) => {
        // Docker multiplexes stdout/stderr
        const header = chunk.slice(0, 8);
        const streamType = header[0];
        const length = header.readUInt32BE(4);
        const data = chunk.slice(8, 8 + length).toString();
        
        if (streamType === 1) {
          stdout += data;
        } else if (streamType === 2) {
          stderr += data;
        }
      });

      stream.on('end', async () => {
        const inspection = await exec.inspect();
        resolve({
          command,
          output: stdout,
          error: stderr,
          exitCode: inspection.ExitCode || 0,
          duration: 0
        });
      });

      stream.on('error', reject);
    });
  }

  async destroy(): Promise<void> {
    if (this.container) {
      await this.container.stop({ t: 5 });
      await this.container.remove({ v: true });
    }
  }
}
```

### 5. Resource Management and Monitoring
```typescript
// src/terminal/resource-monitor.ts
export class TerminalResourceMonitor {
  private metrics = new Map<string, ITerminalMetrics>();

  async collectMetrics(terminal: ITerminalSession): Promise<ITerminalMetrics> {
    const metrics: ITerminalMetrics = {
      terminalId: terminal.id,
      agentId: terminal.agentId,
      cpuUsage: await this.getCPUUsage(terminal),
      memoryUsage: await this.getMemoryUsage(terminal),
      diskUsage: await this.getDiskUsage(terminal.workingDirectory),
      commandCount: await this.getCommandCount(terminal),
      uptime: Date.now() - terminal.createdAt.getTime()
    };

    this.metrics.set(terminal.id, metrics);
    return metrics;
  }

  async enforceResourceLimits(terminal: ITerminalSession): Promise<void> {
    const metrics = await this.collectMetrics(terminal);
    
    // Check memory limit (500MB)
    if (metrics.memoryUsage > 500 * 1024 * 1024) {
      throw new Error(`Terminal ${terminal.id} exceeded memory limit`);
    }
    
    // Check disk usage (1GB)
    if (metrics.diskUsage > 1024 * 1024 * 1024) {
      throw new Error(`Terminal ${terminal.id} exceeded disk limit`);
    }
  }

  private async getCPUUsage(terminal: ITerminalSession): Promise<number> {
    // Implementation would use process monitoring
    return 0;
  }

  private async getMemoryUsage(terminal: ITerminalSession): Promise<number> {
    // Implementation would check process memory
    return 0;
  }

  private async getDiskUsage(directory: string): Promise<number> {
    // Implementation would check directory size
    const { size } = await fs.stat(directory);
    return size;
  }

  private async getCommandCount(terminal: ITerminalSession): Promise<number> {
    return terminal.getOutput().length;
  }
}
```

### 6. Testing Terminal Management
```typescript
// src/terminal/__tests__/terminal-pool.spec.ts
describe('TerminalPoolManager', () => {
  let pool: TerminalPoolManager;
  let logger: jest.Mocked<Logger>;

  beforeEach(() => {
    logger = createMock<Logger>();
    pool = new TerminalPoolManager(logger, {
      maxTerminals: 3,
      maxIdleTime: 1000
    });
  });

  afterEach(async () => {
    await pool.shutdown();
  });

  describe('allocation', () => {
    it('should allocate unique terminal per agent', async () => {
      // Act
      const terminal1 = await pool.allocate('agent-1');
      const terminal2 = await pool.allocate('agent-2');

      // Assert
      expect(terminal1.id).not.toBe(terminal2.id);
      expect(terminal1.workingDirectory).not.toBe(terminal2.workingDirectory);
      expect(pool.getActiveCount()).toBe(2);
    });

    it('should reuse terminal for same agent', async () => {
      // Act
      const terminal1 = await pool.allocate('agent-1');
      const terminal2 = await pool.allocate('agent-1');

      // Assert
      expect(terminal1.id).toBe(terminal2.id);
      expect(pool.getActiveCount()).toBe(1);
    });

    it('should evict LRU when at capacity', async () => {
      // Arrange - allocate max terminals
      await pool.allocate('agent-1');
      await pool.allocate('agent-2');
      const terminal3 = await pool.allocate('agent-3');
      
      // Use terminal 3 to make it most recent
      await terminal3.execute('echo test');

      // Act - allocate one more
      await pool.allocate('agent-4');

      // Assert - agent-1 should be evicted (LRU)
      expect(pool.getTerminalForAgent('agent-1')).toBeUndefined();
      expect(pool.getActiveCount()).toBe(3);
    });
  });

  describe('command execution', () => {
    it('should execute commands in isolated environment', async () => {
      // Arrange
      const terminal = await pool.allocate('test-agent');

      // Act
      const result1 = await terminal.execute('echo $CLAUDE_AGENT_ID');
      const result2 = await terminal.execute('pwd');

      // Assert
      expect(result1.output).toContain('test-agent');
      expect(result2.output).toContain('test-agent');
      expect(result1.exitCode).toBe(0);
    });

    it('should maintain command history', async () => {
      // Arrange
      const terminal = await pool.allocate('test-agent');

      // Act
      await terminal.execute('echo "First command"');
      await terminal.execute('echo "Second command"');
      const output = terminal.getOutput();

      // Assert
      expect(output).toContain('First command');
      expect(output).toContain('Second command');
    });

    it('should handle command failures', async () => {
      // Arrange
      const terminal = await pool.allocate('test-agent');

      // Act
      const result = await terminal.execute('false');

      // Assert
      expect(result.exitCode).not.toBe(0);
    });
  });

  describe('cleanup', () => {
    it('should clean up idle terminals', async () => {
      // Arrange
      jest.useFakeTimers();
      
      const terminal = await pool.allocate('idle-agent');
      expect(pool.getActiveCount()).toBe(1);

      // Act - advance time past idle timeout
      jest.advanceTimersByTime(2000);

      // Assert
      await new Promise(resolve => setTimeout(resolve, 100));
      expect(pool.getActiveCount()).toBe(0);
      
      jest.useRealTimers();
    });

    it('should clean up on shutdown', async () => {
      // Arrange
      await pool.allocate('agent-1');
      await pool.allocate('agent-2');
      expect(pool.getActiveCount()).toBe(2);

      // Act
      await pool.shutdown();

      // Assert
      expect(pool.getActiveCount()).toBe(0);
    });
  });
});
```

## Integration with Agent System

### 7.1 Terminal-Aware Agent
```typescript
// Update BaseAgent to use terminal pool
export abstract class TerminalAwareAgent extends BaseAgent {
  private terminal?: ITerminalSession;

  protected async onInitialize(): Promise<void> {
    // Allocate terminal for this agent
    this.terminal = await this.terminalPool.allocate(this.id);
    
    // Initialize agent workspace
    await this.setupWorkspace();
  }

  protected async executeCommand(command: string): Promise<ICommandResult> {
    if (!this.terminal) {
      throw new Error('No terminal allocated for agent');
    }

    this.logger.debug('Executing command', { 
      agentId: this.id, 
      command 
    });

    const result = await this.terminal.execute(command);
    
    this.logger.debug('Command completed', {
      agentId: this.id,
      exitCode: result.exitCode,
      duration: result.duration
    });

    return result;
  }

  protected async onTerminate(): Promise<void> {
    if (this.terminal) {
      await this.terminalPool.release(this.id);
    }
  }

  private async setupWorkspace(): Promise<void> {
    // Create agent-specific directories
    await this.executeCommand('mkdir -p data output logs');
    
    // Set up any required files
    await this.executeCommand(`echo '${this.id}' > .agent-id`);
  }
}
```

## Key Benefits

1. **Complete Isolation**: Each agent has its own filesystem and environment
2. **Resource Control**: Memory, CPU, and disk limits per agent
3. **Security**: Agents cannot interfere with each other
4. **Debugging**: Complete command history per agent
5. **Scalability**: Efficient terminal pooling and reuse
6. **Flexibility**: Support for both process and container isolation

## Implementation Priority

1. **Phase 1**: Basic virtual terminal with process isolation
2. **Phase 2**: Terminal pool management and resource monitoring
3. **Phase 3**: Docker-based isolation (optional)
4. **Phase 4**: Advanced features (network isolation, persistent storage)

This design ensures that multiple agents can run concurrently without conflicts, each with their own isolated execution environment.