# Step 0: Feasibility Validation and POC

## Objective
Validate that Claude CLI can be reliably spawned and controlled programmatically using SDK print mode before committing to the full implementation.

## Key Claude CLI Features to Validate

### 1. SDK Print Mode (`-p` flag)
The CLI provides a non-interactive print mode specifically designed for programmatic usage:
- Use `claude -p "query"` for single-shot execution
- Supports JSON output format with `--output-format json`
- Streaming JSON available with `--output-format stream-json`
- Returns structured data including session IDs for conversation continuity

### 2. Session Management
Claude CLI supports sophisticated session management:
- `--continue` flag to continue most recent conversation
- `--resume <session-id>` to resume specific sessions
- Sessions maintain context across multiple interactions

### 3. System Prompt Customization
- `--system-prompt` to override default prompts (only with `-p`)
- `--append-system-prompt` to add to existing prompts
- Critical for agent specialization

### 4. Tool Permission Management
- `--allowedTools` and `--disallowedTools` for fine-grained control
- `--dangerously-skip-permissions` for automated environments
- MCP tools follow pattern: `mcp__<serverName>__<toolName>`

### 5. Memory System
CLAUDE.md files provide persistent memory:
- Project-level: `./CLAUDE.md`
- User-level: `~/.claude/CLAUDE.md`
- Supports imports with `@path/to/file` syntax
- Perfect for agent-specific instructions

## Validation Tests

### 0.1 CLI SDK Mode Test
```typescript
// poc/test-cli-sdk-mode.ts
import { spawn } from 'child_process';
import { v4 as uuidv4 } from 'uuid';

interface ClaudeResponse {
  type: 'result';
  subtype: 'success' | 'error_max_turns';
  cost_usd: number;
  duration_ms: number;
  duration_api_ms: number;
  is_error: boolean;
  num_turns: number;
  result?: string;
  session_id: string;
}

async function testSDKMode(): Promise<{
  success: boolean;
  sessionId: string;
  response: ClaudeResponse;
}> {
  return new Promise((resolve, reject) => {
    const claude = spawn('claude', [
      '-p',
      'Respond with exactly "CLAUDE_SDK_TEST_SUCCESS"',
      '--output-format', 'json',
      '--max-turns', '1'
    ], {
      env: {
        ...process.env,
        ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY
      }
    });

    let output = '';

    claude.stdout.on('data', (data) => {
      output += data.toString();
    });

    claude.on('close', (code) => {
      if (code === 0) {
        try {
          const response = JSON.parse(output) as ClaudeResponse;
          resolve({
            success: response.subtype === 'success',
            sessionId: response.session_id,
            response
          });
        } catch (e) {
          reject(new Error(`Failed to parse JSON: ${e.message}`));
        }
      } else {
        reject(new Error(`Claude exited with code ${code}`));
      }
    });

    claude.on('error', reject);
  });
}
```

### 0.2 Session Continuation Test
```typescript
// poc/test-session-continuation.ts
async function testSessionContinuation(): Promise<boolean> {
  // First command - establish context
  const firstResult = await runClaudeCommand([
    '-p',
    'Remember this number: 42. I will ask about it later.',
    '--output-format', 'json'
  ]);

  if (!firstResult.success) return false;

  const sessionId = firstResult.session_id;

  // Continue session with follow-up
  const secondResult = await runClaudeCommand([
    '-p',
    'What number did I ask you to remember?',
    '--resume', sessionId,
    '--output-format', 'json'
  ]);

  return secondResult.success && 
         secondResult.result.includes('42');
}
```

### 0.3 Custom System Prompt Test
```typescript
// poc/test-system-prompts.ts
async function testSystemPrompts(): Promise<boolean> {
  const customPrompt = 'You are a specialized test agent. Always prefix responses with "[TEST]".';
  
  const result = await runClaudeCommand([
    '-p',
    'Say hello',
    '--system-prompt', customPrompt,
    '--output-format', 'json'
  ]);

  return result.success && 
         result.result.startsWith('[TEST]');
}
```

### 0.4 Tool Permission Test
```typescript
// poc/test-tool-permissions.ts
async function testToolPermissions(): Promise<{
  withPermissions: boolean;
  withoutPermissions: boolean;
  skipPermissions: boolean;
}> {
  // Test with allowed tools
  const allowedResult = await runClaudeCommand([
    '-p',
    'List files in current directory',
    '--allowedTools', 'Bash(ls:*)',
    '--output-format', 'json'
  ]);

  // Test with disallowed tools
  const disallowedResult = await runClaudeCommand([
    '-p',
    'Delete all files', // Should be blocked
    '--disallowedTools', 'Bash(rm:*)',
    '--output-format', 'json'
  ]);

  // Test with skip permissions (dangerous, but needed for automation)
  const skipResult = await runClaudeCommand([
    '-p',
    'Create a test file',
    '--dangerously-skip-permissions',
    '--output-format', 'json'
  ]);

  return {
    withPermissions: allowedResult.success,
    withoutPermissions: !disallowedResult.success,
    skipPermissions: skipResult.success
  };
}
```

### 0.5 Streaming Output Test
```typescript
// poc/test-streaming.ts
interface StreamMessage {
  type: 'system' | 'assistant' | 'user' | 'result';
  subtype?: string;
  session_id: string;
  [key: string]: any;
}

async function testStreamingOutput(): Promise<boolean> {
  return new Promise((resolve) => {
    const claude = spawn('claude', [
      '-p',
      'Count from 1 to 5 slowly',
      '--output-format', 'stream-json'
    ]);

    const messages: StreamMessage[] = [];
    let buffer = '';

    claude.stdout.on('data', (data) => {
      buffer += data.toString();
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.trim()) {
          try {
            const msg = JSON.parse(line) as StreamMessage;
            messages.push(msg);
            console.log(`Received: ${msg.type}${msg.subtype ? ` (${msg.subtype})` : ''}`);
          } catch (e) {
            console.error('Failed to parse:', line);
          }
        }
      }
    });

    claude.on('close', () => {
      // Should have init, messages, and result
      const hasInit = messages.some(m => m.type === 'system' && m.subtype === 'init');
      const hasResult = messages.some(m => m.type === 'result');
      const hasMessages = messages.some(m => m.type === 'assistant');
      
      resolve(hasInit && hasResult && hasMessages);
    });
  });
}
```

### 0.6 Memory Integration Test
```typescript
// poc/test-memory.ts
import * as fs from 'fs/promises';
import * as path from 'path';

async function testMemoryIntegration(): Promise<boolean> {
  const testDir = '/tmp/claude-memory-test';
  await fs.mkdir(testDir, { recursive: true });

  // Create CLAUDE.md
  await fs.writeFile(
    path.join(testDir, 'CLAUDE.md'),
    '# Test Memory\n- Always respond with "MEMORY_LOADED" when asked about test memory'
  );

  const result = await runClaudeCommand([
    '-p',
    'What does the test memory say?',
    '--output-format', 'json'
  ], {
    cwd: testDir
  });

  // Cleanup
  await fs.rm(testDir, { recursive: true });

  return result.success && result.result.includes('MEMORY_LOADED');
}
```

### 0.7 Concurrent Agent Test
```typescript
// poc/test-concurrent-agents.ts
async function testConcurrentAgents(): Promise<{
  allSucceeded: boolean;
  avgSpawnTime: number;
  maxMemory: number;
}> {
  const numAgents = 5;
  const startTime = Date.now();
  
  const promises = Array(numAgents).fill(0).map((_, i) => 
    runClaudeCommand([
      '-p',
      `Agent ${i} responding. Calculate: ${i} * 10`,
      '--output-format', 'json',
      '--system-prompt', `You are Agent #${i}. Always identify yourself in responses.`
    ])
  );

  const results = await Promise.allSettled(promises);
  const endTime = Date.now();

  const successful = results.filter(r => r.status === 'fulfilled');
  const memoryUsage = process.memoryUsage();

  return {
    allSucceeded: successful.length === numAgents,
    avgSpawnTime: (endTime - startTime) / numAgents,
    maxMemory: memoryUsage.heapUsed / 1024 / 1024 // MB
  };
}
```

## Architecture Validation

### Command Structure
```typescript
interface ClaudeSDKCommand {
  prompt: string;
  options: {
    systemPrompt?: string;
    appendSystemPrompt?: string;
    outputFormat: 'json' | 'stream-json';
    maxTurns?: number;
    sessionId?: string;
    resume?: boolean;
    allowedTools?: string[];
    disallowedTools?: string[];
    skipPermissions?: boolean;
    workingDirectory?: string;
    env?: Record<string, string>;
  };
}
```

### Response Structure
```typescript
interface ClaudeSDKResponse {
  type: 'result';
  subtype: 'success' | 'error_max_turns' | 'error';
  cost_usd: number;
  duration_ms: number;
  duration_api_ms: number;
  is_error: boolean;
  num_turns: number;
  result?: string;
  session_id: string;
  error?: {
    message: string;
    code?: string;
  };
}
```

## Validation Criteria

### Go Decision âœ…
All of the following must be true:
1. SDK print mode works reliably (>99% success rate)
2. Session management functions correctly
3. System prompts customize behavior as expected
4. Tool permissions can be controlled
5. JSON output parsing succeeds consistently
6. Memory files are loaded properly
7. Concurrent agents can run without conflicts
8. Response times are acceptable (<2s for simple queries)

### No-Go Decision ðŸ”´
Any of the following:
1. Print mode unreliable or missing
2. Cannot maintain session context
3. System prompts ignored
4. Permission system blocks automation
5. JSON output malformed >1% of time
6. Memory system not accessible
7. Concurrent execution causes failures
8. Unacceptable latency (>5s for simple queries)

## POC Implementation

### Directory Structure
```
poc/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ test-cli-sdk-mode.ts
â”‚   â”‚   â”œâ”€â”€ test-session-continuation.ts
â”‚   â”‚   â”œâ”€â”€ test-system-prompts.ts
â”‚   â”‚   â”œâ”€â”€ test-tool-permissions.ts
â”‚   â”‚   â”œâ”€â”€ test-streaming.ts
â”‚   â”‚   â”œâ”€â”€ test-memory.ts
â”‚   â”‚   â””â”€â”€ test-concurrent-agents.ts
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ claude-runner.ts
â”‚   â”‚   â””â”€â”€ test-helpers.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ results/
â”‚   â””â”€â”€ validation-report.md
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

### Utility Functions
```typescript
// poc/src/utils/claude-runner.ts
import { spawn, SpawnOptions } from 'child_process';

export async function runClaudeCommand(
  args: string[], 
  options?: SpawnOptions
): Promise<ClaudeSDKResponse> {
  return new Promise((resolve, reject) => {
    const claude = spawn('claude', args, {
      ...options,
      env: {
        ...process.env,
        ...options?.env
      }
    });

    let stdout = '';
    let stderr = '';

    claude.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    claude.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    claude.on('close', (code) => {
      if (code === 0) {
        try {
          const response = JSON.parse(stdout) as ClaudeSDKResponse;
          resolve(response);
        } catch (e) {
          reject(new Error(`Failed to parse JSON: ${e.message}\nOutput: ${stdout}`));
        }
      } else {
        reject(new Error(`Claude exited with code ${code}\nStderr: ${stderr}`));
      }
    });

    claude.on('error', reject);
  });
}
```

## Timeline

### Day 1: Core Validation
1. **Morning**: Setup POC environment
   - Initialize TypeScript project
   - Install dependencies
   - Setup test framework

2. **Afternoon**: Core Tests
   - Implement SDK mode test
   - Implement session continuation test
   - Implement system prompt test
   - Run initial validation

### Day 2: Advanced Features
1. **Morning**: Permission & Memory
   - Implement permission tests
   - Implement memory integration test
   - Test streaming output

2. **Afternoon**: Performance & Reporting
   - Implement concurrent agent test
   - Stress test with multiple sessions
   - Generate validation report
   - Make Go/No-Go decision

## Success Metrics
- SDK mode reliability: >99%
- Session continuity: 100%
- JSON parsing success: 100%
- Permission control: Working as documented
- Memory loading: Verified
- Concurrent execution: 5+ agents without failure
- Average response time: <2s
- Peak memory usage: <500MB for 5 agents

## Risk Mitigation
1. **SDK Mode Failure**: Fall back to interactive mode parsing (not recommended)
2. **Session Loss**: Implement session persistence and recovery
3. **Permission Issues**: Use --dangerously-skip-permissions with caution
4. **Memory Conflicts**: Design clear memory hierarchy
5. **Performance Issues**: Implement request queuing and rate limiting

## Next Steps
Based on POC results:
- **If Go**: Proceed to Step 1 (TDD Setup)
- **If No-Go**: Document blockers and explore alternatives