# Step 3: CLI Process Manager and Session Management

## Objective
Implement a robust CLI process manager that handles Claude CLI spawning, session management, and communication using SDK print mode.

## Prerequisites
- Step 2 Base Agent implementation complete
- Understanding of Claude CLI's SDK mode and session features
- Node.js child_process expertise

## Core Components

### 3.1 CLI Process Manager Interface
```typescript
// src/cli/types.ts
export interface ICLIProcessManager {
  createSession(config: ISessionConfig): Promise<ClaudeSDKResponse>;
  execute(config: IExecutionConfig): Promise<ClaudeSDKResponse>;
  executeStreaming(config: IExecutionConfig): AsyncIterable<IStreamMessage>;
  endSession(sessionId: string): Promise<void>;
  getActiveSessionCount(): number;
  shutdown(): Promise<void>;
}

export interface ISessionConfig {
  prompt: string;
  systemPrompt?: string;
  appendSystemPrompt?: string;
  outputFormat: 'json' | 'stream-json';
  maxTurns?: number;
  workingDirectory?: string;
  env?: Record<string, string>;
  allowedTools?: string[];
  disallowedTools?: string[];
  skipPermissions?: boolean;
}

export interface IExecutionConfig extends ISessionConfig {
  sessionId: string;
  resume?: boolean;
}

export interface IStreamMessage {
  type: 'system' | 'assistant' | 'user' | 'result';
  subtype?: string;
  session_id: string;
  content?: string;
  [key: string]: any;
}

export interface IProcessOptions {
  maxConcurrentProcesses?: number;
  processTimeout?: number;
  memoryLimit?: number;
  cpuLimit?: number;
  retryAttempts?: number;
  retryDelay?: number;
}
```

### 3.2 CLI Process Manager Implementation
```typescript
// src/cli/cli-process-manager.ts
import { spawn, ChildProcess, SpawnOptions } from 'child_process';
import { EventEmitter } from 'events';
import { Logger } from '../utils/logger';
import { ProcessPool } from './process-pool';
import { SessionManager } from './session-manager';
import { CircuitBreaker } from '../utils/circuit-breaker';
import { RateLimiter } from '../utils/rate-limiter';

export class CLIProcessManager extends EventEmitter implements ICLIProcessManager {
  private processPool: ProcessPool;
  private sessionManager: SessionManager;
  private circuitBreaker: CircuitBreaker;
  private rateLimiter: RateLimiter;
  private activeProcesses = new Map<string, ChildProcess>();
  private shuttingDown = false;

  constructor(
    private logger: Logger,
    private options: IProcessOptions = {}
  ) {
    super();
    
    this.processPool = new ProcessPool({
      maxSize: options.maxConcurrentProcesses || 10,
      logger: this.logger
    });
    
    this.sessionManager = new SessionManager(this.logger);
    
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      resetTimeout: 60000, // 1 minute
      logger: this.logger
    });
    
    this.rateLimiter = new RateLimiter({
      maxRequests: 100,
      windowMs: 60000, // 1 minute
      logger: this.logger
    });
    
    this.setupProcessMonitoring();
  }

  async createSession(config: ISessionConfig): Promise<ClaudeSDKResponse> {
    this.validateNotShuttingDown();
    await this.rateLimiter.checkLimit();
    
    return this.circuitBreaker.execute(async () => {
      const args = this.buildArgs(config);
      const spawnOptions = this.buildSpawnOptions(config);
      
      this.logger.debug('Creating new Claude session', { 
        args, 
        workingDirectory: spawnOptions.cwd 
      });
      
      try {
        const response = await this.executeCommand(args, spawnOptions, config.prompt);
        
        if (response.session_id) {
          this.sessionManager.registerSession(response.session_id, {
            createdAt: Date.now(),
            lastUsed: Date.now(),
            config: config
          });
        }
        
        return response;
      } catch (error) {
        this.logger.error('Failed to create session', error);
        throw error;
      }
    });
  }

  async execute(config: IExecutionConfig): Promise<ClaudeSDKResponse> {
    this.validateNotShuttingDown();
    await this.rateLimiter.checkLimit();
    
    // Validate session exists
    if (!this.sessionManager.hasSession(config.sessionId)) {
      throw new Error(`Session ${config.sessionId} not found`);
    }
    
    return this.circuitBreaker.execute(async () => {
      const args = this.buildArgsForExecution(config);
      const spawnOptions = this.buildSpawnOptions(config);
      
      this.logger.debug('Executing command in session', {
        sessionId: config.sessionId,
        resume: config.resume
      });
      
      try {
        const response = await this.executeCommand(args, spawnOptions, config.prompt);
        
        // Update session last used time
        this.sessionManager.updateSessionUsage(config.sessionId);
        
        return response;
      } catch (error) {
        this.logger.error('Command execution failed', {
          sessionId: config.sessionId,
          error: error.message
        });
        throw error;
      }
    });
  }

  async *executeStreaming(config: IExecutionConfig): AsyncIterable<IStreamMessage> {
    this.validateNotShuttingDown();
    await this.rateLimiter.checkLimit();
    
    const args = this.buildArgsForExecution({
      ...config,
      outputFormat: 'stream-json'
    });
    const spawnOptions = this.buildSpawnOptions(config);
    
    const processId = `stream_${Date.now()}`;
    const claude = spawn('claude', args, spawnOptions);
    this.activeProcesses.set(processId, claude);
    
    try {
      // Write prompt to stdin if needed
      if (config.prompt && !args.includes('-p')) {
        claude.stdin?.write(config.prompt);
        claude.stdin?.end();
      }
      
      yield* this.streamOutput(claude, processId);
      
    } finally {
      this.activeProcesses.delete(processId);
      this.cleanupProcess(claude);
    }
  }

  async endSession(sessionId: string): Promise<void> {
    this.logger.debug('Ending session', { sessionId });
    
    // Claude CLI doesn't have explicit session end command
    // Just remove from our tracking
    this.sessionManager.removeSession(sessionId);
  }

  getActiveSessionCount(): number {
    return this.sessionManager.getActiveCount();
  }

  async shutdown(): Promise<void> {
    this.logger.info('Shutting down CLI Process Manager');
    this.shuttingDown = true;
    
    // Stop accepting new requests
    this.circuitBreaker.open();
    
    // Kill all active processes
    const killPromises = Array.from(this.activeProcesses.entries()).map(
      ([id, process]) => this.killProcess(id, process)
    );
    
    await Promise.all(killPromises);
    
    // Clear sessions
    this.sessionManager.clearAll();
    
    this.logger.info('CLI Process Manager shutdown complete');
  }

  // Private helper methods
  private buildArgs(config: ISessionConfig): string[] {
    const args: string[] = ['-p', config.prompt];
    
    if (config.systemPrompt) {
      args.push('--system-prompt', config.systemPrompt);
    }
    
    if (config.appendSystemPrompt) {
      args.push('--append-system-prompt', config.appendSystemPrompt);
    }
    
    args.push('--output-format', config.outputFormat);
    
    if (config.maxTurns) {
      args.push('--max-turns', String(config.maxTurns));
    }
    
    if (config.allowedTools && config.allowedTools.length > 0) {
      config.allowedTools.forEach(tool => {
        args.push('--allowedTools', tool);
      });
    }
    
    if (config.disallowedTools && config.disallowedTools.length > 0) {
      config.disallowedTools.forEach(tool => {
        args.push('--disallowedTools', tool);
      });
    }
    
    if (config.skipPermissions) {
      args.push('--dangerously-skip-permissions');
    }
    
    return args;
  }

  private buildArgsForExecution(config: IExecutionConfig): string[] {
    const args = this.buildArgs(config);
    
    if (config.resume) {
      // Replace -p with --resume
      const promptIndex = args.indexOf('-p');
      if (promptIndex !== -1) {
        args.splice(promptIndex, 2); // Remove -p and prompt
        args.unshift('--resume', config.sessionId);
        args.push('-p', config.prompt);
      }
    } else {
      // Use --continue
      const promptIndex = args.indexOf('-p');
      if (promptIndex !== -1) {
        args.splice(promptIndex, 0, '--continue');
      }
    }
    
    return args;
  }

  private buildSpawnOptions(config: ISessionConfig): SpawnOptions {
    const options: SpawnOptions = {
      cwd: config.workingDirectory || process.cwd(),
      env: {
        ...process.env,
        ...config.env,
        // Ensure JSON output isn't corrupted by color codes
        NO_COLOR: '1',
        CLAUDE_NO_COLOR: '1'
      },
      // Pipe all streams
      stdio: ['pipe', 'pipe', 'pipe']
    };
    
    // Add memory limit if specified
    if (this.options.memoryLimit) {
      options.env!.NODE_OPTIONS = `--max-old-space-size=${this.options.memoryLimit}`;
    }
    
    return options;
  }

  private async executeCommand(
    args: string[],
    spawnOptions: SpawnOptions,
    prompt?: string
  ): Promise<ClaudeSDKResponse> {
    const processId = `cmd_${Date.now()}`;
    
    return new Promise((resolve, reject) => {
      const claude = spawn('claude', args, spawnOptions);
      this.activeProcesses.set(processId, claude);
      
      let stdout = '';
      let stderr = '';
      let timeout: NodeJS.Timeout | undefined;
      
      // Set timeout if configured
      if (this.options.processTimeout) {
        timeout = setTimeout(() => {
          this.logger.warn('Process timeout reached', { processId });
          claude.kill('SIGTERM');
          reject(new Error('Process timeout'));
        }, this.options.processTimeout);
      }
      
      // Collect stdout
      claude.stdout?.on('data', (data) => {
        stdout += data.toString();
      });
      
      // Collect stderr
      claude.stderr?.on('data', (data) => {
        stderr += data.toString();
        this.logger.debug('Claude stderr', { data: data.toString() });
      });
      
      // Handle process exit
      claude.on('close', (code) => {
        if (timeout) clearTimeout(timeout);
        this.activeProcesses.delete(processId);
        
        if (code === 0) {
          try {
            const response = JSON.parse(stdout) as ClaudeSDKResponse;
            resolve(response);
          } catch (error) {
            this.logger.error('Failed to parse Claude output', { stdout, stderr });
            reject(new Error(`Invalid JSON response: ${error.message}`));
          }
        } else {
          reject(new Error(`Claude exited with code ${code}: ${stderr}`));
        }
      });
      
      // Handle process errors
      claude.on('error', (error) => {
        if (timeout) clearTimeout(timeout);
        this.activeProcesses.delete(processId);
        reject(error);
      });
      
      // Write prompt to stdin if not using -p flag
      if (prompt && !args.includes('-p')) {
        claude.stdin?.write(prompt);
        claude.stdin?.end();
      }
    });
  }

  private async *streamOutput(
    claude: ChildProcess,
    processId: string
  ): AsyncIterable<IStreamMessage> {
    let buffer = '';
    
    for await (const chunk of claude.stdout!) {
      buffer += chunk.toString();
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.trim()) {
          try {
            const message = JSON.parse(line) as IStreamMessage;
            yield message;
            
            // Check for result message (end of stream)
            if (message.type === 'result') {
              break;
            }
          } catch (error) {
            this.logger.warn('Failed to parse stream message', { line, error });
          }
        }
      }
    }
    
    // Process any remaining buffer
    if (buffer.trim()) {
      try {
        const message = JSON.parse(buffer) as IStreamMessage;
        yield message;
      } catch (error) {
        this.logger.warn('Failed to parse final stream message', { buffer, error });
      }
    }
  }

  private cleanupProcess(process: ChildProcess): void {
    try {
      process.stdout?.removeAllListeners();
      process.stderr?.removeAllListeners();
      process.removeAllListeners();
      
      if (process.exitCode === null) {
        process.kill('SIGTERM');
      }
    } catch (error) {
      this.logger.warn('Error during process cleanup', error);
    }
  }

  private async killProcess(id: string, process: ChildProcess): Promise<void> {
    this.logger.debug('Killing process', { id, pid: process.pid });
    
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        process.kill('SIGKILL');
        resolve();
      }, 5000);
      
      process.once('exit', () => {
        clearTimeout(timeout);
        resolve();
      });
      
      process.kill('SIGTERM');
    });
  }

  private validateNotShuttingDown(): void {
    if (this.shuttingDown) {
      throw new Error('CLI Process Manager is shutting down');
    }
  }

  private setupProcessMonitoring(): void {
    // Monitor process health
    setInterval(() => {
      const stats = {
        activeProcesses: this.activeProcesses.size,
        activeSessions: this.sessionManager.getActiveCount(),
        circuitBreakerState: this.circuitBreaker.getState(),
        rateLimiterRemaining: this.rateLimiter.getRemaining()
      };
      
      this.logger.debug('Process manager stats', stats);
      this.emit('stats', stats);
    }, 30000); // Every 30 seconds
  }
}
```

### 3.3 Session Manager
```typescript
// src/cli/session-manager.ts
export interface ISessionInfo {
  createdAt: number;
  lastUsed: number;
  config: ISessionConfig;
  metadata?: Record<string, any>;
}

export class SessionManager {
  private sessions = new Map<string, ISessionInfo>();
  private sessionTimeout = 30 * 60 * 1000; // 30 minutes
  
  constructor(private logger: Logger) {
    this.startCleanupTimer();
  }

  registerSession(sessionId: string, info: ISessionInfo): void {
    this.sessions.set(sessionId, info);
    this.logger.debug('Session registered', { sessionId });
  }

  hasSession(sessionId: string): boolean {
    return this.sessions.has(sessionId);
  }

  getSession(sessionId: string): ISessionInfo | undefined {
    return this.sessions.get(sessionId);
  }

  updateSessionUsage(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastUsed = Date.now();
    }
  }

  removeSession(sessionId: string): void {
    this.sessions.delete(sessionId);
    this.logger.debug('Session removed', { sessionId });
  }

  getActiveCount(): number {
    return this.sessions.size;
  }

  clearAll(): void {
    this.sessions.clear();
  }

  private startCleanupTimer(): void {
    setInterval(() => {
      const now = Date.now();
      const expired: string[] = [];
      
      for (const [sessionId, info] of this.sessions.entries()) {
        if (now - info.lastUsed > this.sessionTimeout) {
          expired.push(sessionId);
        }
      }
      
      for (const sessionId of expired) {
        this.removeSession(sessionId);
        this.logger.info('Session expired', { sessionId });
      }
    }, 60000); // Check every minute
  }
}
```

### 3.4 Process Pool
```typescript
// src/cli/process-pool.ts
export interface IProcessPoolOptions {
  maxSize: number;
  logger: Logger;
}

export class ProcessPool {
  private available: ChildProcess[] = [];
  private busy = new Set<ChildProcess>();
  
  constructor(private options: IProcessPoolOptions) {}

  async acquire(): Promise<ChildProcess> {
    // For Claude CLI, we don't pre-spawn processes
    // Each command is a new process
    // This is a placeholder for future optimization
    throw new Error('Process pooling not implemented for Claude CLI');
  }

  release(process: ChildProcess): void {
    // Cleanup and potentially reuse
    this.busy.delete(process);
  }

  getStats(): { available: number; busy: number } {
    return {
      available: this.available.length,
      busy: this.busy.size
    };
  }
}
```

## Error Handling and Resilience

### 4.1 Circuit Breaker
```typescript
// src/utils/circuit-breaker.ts
export interface ICircuitBreakerOptions {
  failureThreshold: number;
  resetTimeout: number;
  logger: Logger;
}

export class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  constructor(private options: ICircuitBreakerOptions) {}

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > this.options.resetTimeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failures = 0;
    this.state = 'closed';
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.options.failureThreshold) {
      this.state = 'open';
      this.options.logger.warn('Circuit breaker opened', {
        failures: this.failures
      });
    }
  }

  getState(): string {
    return this.state;
  }

  open(): void {
    this.state = 'open';
  }

  reset(): void {
    this.failures = 0;
    this.state = 'closed';
  }
}
```

### 4.2 Rate Limiter
```typescript
// src/utils/rate-limiter.ts
export interface IRateLimiterOptions {
  maxRequests: number;
  windowMs: number;
  logger: Logger;
}

export class RateLimiter {
  private requests: number[] = [];
  
  constructor(private options: IRateLimiterOptions) {}

  async checkLimit(): Promise<void> {
    const now = Date.now();
    const windowStart = now - this.options.windowMs;
    
    // Remove old requests
    this.requests = this.requests.filter(time => time > windowStart);
    
    if (this.requests.length >= this.options.maxRequests) {
      const oldestRequest = this.requests[0];
      const waitTime = oldestRequest + this.options.windowMs - now;
      
      this.options.logger.warn('Rate limit reached, waiting', { waitTime });
      await this.delay(waitTime);
      
      // Retry
      return this.checkLimit();
    }
    
    this.requests.push(now);
  }

  getRemaining(): number {
    const now = Date.now();
    const windowStart = now - this.options.windowMs;
    const activeRequests = this.requests.filter(time => time > windowStart);
    return Math.max(0, this.options.maxRequests - activeRequests.length);
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Testing the CLI Process Manager

### 5.1 Unit Tests
```typescript
// src/cli/__tests__/cli-process-manager.spec.ts
describe('CLIProcessManager', () => {
  let manager: CLIProcessManager;
  let mockSpawn: jest.SpyInstance;
  let mockChildProcess: MockChildProcess;
  let logger: jest.Mocked<Logger>;

  beforeEach(() => {
    logger = createMock<Logger>();
    mockChildProcess = new MockChildProcess();
    mockSpawn = jest.spyOn(childProcess, 'spawn').mockReturnValue(mockChildProcess as any);
    
    manager = new CLIProcessManager(logger);
  });

  afterEach(() => {
    mockSpawn.mockRestore();
  });

  describe('createSession', () => {
    it('should create session with correct arguments', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test prompt',
        systemPrompt: 'You are a test agent',
        outputFormat: 'json',
        maxTurns: 5
      };

      const mockResponse: ClaudeSDKResponse = {
        type: 'result',
        subtype: 'success',
        session_id: 'test-session-123',
        result: 'Session created',
        cost_usd: 0.001,
        duration_ms: 100,
        duration_api_ms: 80,
        num_turns: 1,
        is_error: false
      };

      // Act
      const responsePromise = manager.createSession(config);
      
      // Simulate Claude response
      mockChildProcess.stdout.emit('data', JSON.stringify(mockResponse));
      mockChildProcess.emit('close', 0);
      
      const response = await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude', [
        '-p', 'Test prompt',
        '--system-prompt', 'You are a test agent',
        '--output-format', 'json',
        '--max-turns', '5'
      ], expect.any(Object));
      
      expect(response.session_id).toBe('test-session-123');
      expect(manager.getActiveSessionCount()).toBe(1);
    });

    it('should handle permission configuration', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Test',
        outputFormat: 'json',
        allowedTools: ['Read(**)', 'Bash(ls:*)'],
        disallowedTools: ['Edit(**)', 'Bash(rm:*)'],
        skipPermissions: true
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.stdout.emit('data', JSON.stringify({ session_id: 'test' }));
      mockChildProcess.emit('close', 0);
      await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude', 
        expect.arrayContaining([
          '--allowedTools', 'Read(**)',
          '--allowedTools', 'Bash(ls:*)',
          '--disallowedTools', 'Edit(**)',
          '--disallowedTools', 'Bash(rm:*)',
          '--dangerously-skip-permissions'
        ]), 
        expect.any(Object)
      );
    });
  });

  describe('execute', () => {
    beforeEach(async () => {
      // Create a session first
      const createPromise = manager.createSession({
        prompt: 'Init',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        session_id: 'existing-session',
        type: 'result',
        subtype: 'success'
      }));
      mockChildProcess.emit('close', 0);
      
      await createPromise;
    });

    it('should execute in existing session', async () => {
      // Arrange
      const config: IExecutionConfig = {
        sessionId: 'existing-session',
        prompt: 'Continue conversation',
        outputFormat: 'json',
        resume: false
      };

      // Reset mock for new call
      mockChildProcess = new MockChildProcess();
      mockSpawn.mockReturnValue(mockChildProcess as any);

      // Act
      const responsePromise = manager.execute(config);
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        result: 'Continued',
        session_id: 'existing-session'
      }));
      mockChildProcess.emit('close', 0);
      
      const response = await responsePromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude',
        expect.arrayContaining(['--continue', '-p', 'Continue conversation']),
        expect.any(Object)
      );
      expect(response.result).toBe('Continued');
    });

    it('should handle session not found', async () => {
      // Arrange
      const config: IExecutionConfig = {
        sessionId: 'non-existent',
        prompt: 'Test',
        outputFormat: 'json'
      };

      // Act & Assert
      await expect(manager.execute(config)).rejects.toThrow('Session non-existent not found');
    });
  });

  describe('executeStreaming', () => {
    it('should stream messages', async () => {
      // Arrange
      const config: IExecutionConfig = {
        sessionId: 'test-session',
        prompt: 'Stream test',
        outputFormat: 'stream-json'
      };

      const messages: IStreamMessage[] = [];

      // Create session first
      const createPromise = manager.createSession({
        prompt: 'Init',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        session_id: 'test-session',
        type: 'result',
        subtype: 'success'
      }));
      mockChildProcess.emit('close', 0);
      
      await createPromise;

      // Reset for streaming
      mockChildProcess = new MockChildProcess();
      mockSpawn.mockReturnValue(mockChildProcess as any);

      // Act
      const streamPromise = (async () => {
        for await (const message of manager.executeStreaming(config)) {
          messages.push(message);
        }
      })();

      // Simulate streaming messages
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'system',
        subtype: 'init',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'assistant',
        content: 'Streaming response',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        type: 'result',
        subtype: 'success',
        session_id: 'test-session'
      }) + '\n');
      
      mockChildProcess.emit('close', 0);
      
      await streamPromise;

      // Assert
      expect(messages).toHaveLength(3);
      expect(messages[0].type).toBe('system');
      expect(messages[1].type).toBe('assistant');
      expect(messages[2].type).toBe('result');
    });
  });

  describe('error handling', () => {
    it('should handle process errors', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Error test',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.emit('error', new Error('Spawn failed'));
      
      // Assert
      await expect(responsePromise).rejects.toThrow('Spawn failed');
    });

    it('should handle invalid JSON response', async () => {
      // Arrange
      const config: ISessionConfig = {
        prompt: 'Invalid JSON test',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      mockChildProcess.stdout.emit('data', 'Not JSON');
      mockChildProcess.emit('close', 0);
      
      // Assert
      await expect(responsePromise).rejects.toThrow('Invalid JSON response');
    });

    it('should handle process timeout', async () => {
      // Arrange
      manager = new CLIProcessManager(logger, {
        processTimeout: 100 // 100ms timeout
      });

      const config: ISessionConfig = {
        prompt: 'Timeout test',
        outputFormat: 'json'
      };

      // Act
      const responsePromise = manager.createSession(config);
      
      // Wait for timeout
      await new Promise(resolve => setTimeout(resolve, 150));
      
      // Assert
      await expect(responsePromise).rejects.toThrow('Process timeout');
    });
  });

  describe('shutdown', () => {
    it('should clean up resources on shutdown', async () => {
      // Create some sessions
      const createPromise = manager.createSession({
        prompt: 'Test',
        outputFormat: 'json'
      });
      
      mockChildProcess.stdout.emit('data', JSON.stringify({
        session_id: 'session-1',
        type: 'result',
        subtype: 'success'
      }));
      mockChildProcess.emit('close', 0);
      
      await createPromise;

      // Shutdown
      await manager.shutdown();

      // Verify
      expect(manager.getActiveSessionCount()).toBe(0);
      await expect(manager.createSession({
        prompt: 'After shutdown',
        outputFormat: 'json'
      })).rejects.toThrow('CLI Process Manager is shutting down');
    });
  });
});

// Mock implementation
class MockChildProcess extends EventEmitter {
  stdout = new EventEmitter();
  stderr = new EventEmitter();
  stdin = {
    write: jest.fn(),
    end: jest.fn()
  };
  pid = Math.floor(Math.random() * 10000);
  exitCode: number | null = null;
  
  kill(signal?: string): boolean {
    this.exitCode = signal === 'SIGKILL' ? 137 : 143;
    this.emit('exit', this.exitCode, signal);
    return true;
  }
}
```

## Performance Monitoring

### 6.1 Metrics Collection
```typescript
// src/cli/cli-metrics.ts
export class CLIMetrics {
  private metrics = {
    sessionsCreated: 0,
    commandsExecuted: 0,
    errors: 0,
    totalDuration: 0,
    totalCost: 0
  };

  recordSessionCreation(duration: number, cost: number): void {
    this.metrics.sessionsCreated++;
    this.metrics.totalDuration += duration;
    this.metrics.totalCost += cost;
  }

  recordCommandExecution(duration: number, cost: number): void {
    this.metrics.commandsExecuted++;
    this.metrics.totalDuration += duration;
    this.metrics.totalCost += cost;
  }

  recordError(): void {
    this.metrics.errors++;
  }

  getMetrics(): typeof this.metrics {
    return { ...this.metrics };
  }

  reset(): void {
    Object.keys(this.metrics).forEach(key => {
      this.metrics[key as keyof typeof this.metrics] = 0;
    });
  }
}
```

## Implementation Timeline

### Day 1: Core Implementation
1. **Morning**:
   - Implement CLI Process Manager
   - Build argument construction
   - Process spawning logic

2. **Afternoon**:
   - Session management
   - Error handling
   - Circuit breaker pattern

### Day 2: Advanced Features
1. **Morning**:
   - Streaming support
   - Rate limiting
   - Process monitoring

2. **Afternoon**:
   - Complete testing
   - Performance optimization
   - Documentation

## Success Metrics
- All CLI commands execute successfully
- Session persistence works correctly
- Error handling is robust
- Performance targets met:
  - Command execution <2s average
  - Session creation <1s
  - Concurrent execution stable
- 100% test coverage maintained

## Next Steps
After completing CLI Process Manager:
1. Proceed to Step 4: Message Queue & Communication
2. Integrate with agent system
3. Build orchestration layer