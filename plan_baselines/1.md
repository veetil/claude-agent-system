# Step 1: TDD Setup and Base Infrastructure

## Objective
Establish a robust TDD foundation using London School methodology with comprehensive test infrastructure for the multi-agent system.

## Prerequisites
- Step 0 POC validated successfully
- Claude CLI SDK mode confirmed working
- Development environment ready

## Test Infrastructure Components

### 1.1 Test Framework Setup
```typescript
// test/setup.ts
import { jest } from '@jest/globals';
import { MockFactory } from './mocks/mock-factory';
import { TestFixtures } from './fixtures';

// Configure test environment
export const setupTests = () => {
  // Set test timeouts
  jest.setTimeout(30000); // 30s for integration tests
  
  // Setup global mocks
  MockFactory.setupGlobalMocks();
  
  // Load test fixtures
  TestFixtures.load();
  
  // Configure test database
  setupTestDatabase();
};

// test/jest.config.ts
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/test'],
  testMatch: ['**/__tests__/**/*.ts', '**/*.test.ts', '**/*.spec.ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts']
};
```

### 1.2 Mock Factory Infrastructure
```typescript
// test/mocks/mock-factory.ts
import { ChildProcess } from 'child_process';
import { EventEmitter } from 'events';

export class MockFactory {
  static createMockChildProcess(): jest.Mocked<ChildProcess> {
    const mockProcess = new EventEmitter() as jest.Mocked<ChildProcess>;
    
    mockProcess.stdout = new EventEmitter() as any;
    mockProcess.stderr = new EventEmitter() as any;
    mockProcess.stdin = {
      write: jest.fn(),
      end: jest.fn()
    } as any;
    
    mockProcess.kill = jest.fn();
    mockProcess.pid = Math.floor(Math.random() * 10000);
    
    return mockProcess;
  }

  static createMockClaudeResponse(overrides?: Partial<ClaudeSDKResponse>): ClaudeSDKResponse {
    return {
      type: 'result',
      subtype: 'success',
      cost_usd: 0.0001,
      duration_ms: 1000,
      duration_api_ms: 800,
      is_error: false,
      num_turns: 1,
      result: 'Mock response',
      session_id: `session_${Date.now()}`,
      ...overrides
    };
  }

  static createMockLogger(): jest.Mocked<Logger> {
    return {
      debug: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
      child: jest.fn().mockReturnThis()
    };
  }
}
```

### 1.3 Test Doubles Strategy
```typescript
// test/doubles/claude-cli-double.ts
export class ClaudeCLIDouble {
  private responses: Map<string, ClaudeSDKResponse> = new Map();
  private defaultResponse: ClaudeSDKResponse;

  constructor() {
    this.defaultResponse = MockFactory.createMockClaudeResponse();
  }

  whenPrompt(prompt: string): ResponseBuilder {
    return new ResponseBuilder(this, prompt);
  }

  getResponse(prompt: string): ClaudeSDKResponse {
    return this.responses.get(prompt) || this.defaultResponse;
  }

  reset(): void {
    this.responses.clear();
  }
}

class ResponseBuilder {
  constructor(
    private double: ClaudeCLIDouble,
    private prompt: string
  ) {}

  thenRespond(response: Partial<ClaudeSDKResponse>): void {
    this.double.responses.set(
      this.prompt,
      MockFactory.createMockClaudeResponse(response)
    );
  }
}
```

### 1.4 Integration Test Helpers
```typescript
// test/helpers/integration-helpers.ts
import { spawn } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';

export class IntegrationTestHelper {
  private tempDirs: string[] = [];

  async createTempProject(): Promise<string> {
    const tempDir = path.join('/tmp', `claude-test-${Date.now()}`);
    await fs.mkdir(tempDir, { recursive: true });
    this.tempDirs.push(tempDir);
    return tempDir;
  }

  async createMemoryFile(projectDir: string, content: string): Promise<void> {
    await fs.writeFile(
      path.join(projectDir, 'CLAUDE.md'),
      content
    );
  }

  async cleanup(): Promise<void> {
    for (const dir of this.tempDirs) {
      await fs.rm(dir, { recursive: true, force: true });
    }
    this.tempDirs = [];
  }

  async runRealClaude(args: string[], cwd?: string): Promise<ClaudeSDKResponse> {
    // Real implementation for integration tests
    return runClaudeCommand(args, { cwd });
  }
}
```

## Core Test Suites

### 2.1 Agent Lifecycle Tests
```typescript
// src/agents/__tests__/agent-lifecycle.spec.ts
describe('Agent Lifecycle', () => {
  let mockCLI: ClaudeCLIDouble;
  let logger: jest.Mocked<Logger>;

  beforeEach(() => {
    mockCLI = new ClaudeCLIDouble();
    logger = MockFactory.createMockLogger();
  });

  describe('Agent Creation', () => {
    it('should create agent with valid configuration', async () => {
      // Arrange
      const config: IAgentConfig = {
        id: 'test-agent',
        type: 'research',
        systemPrompt: 'You are a research agent',
        maxTurns: 5
      };

      // Act
      const agent = new BaseAgent(config, logger);

      // Assert
      expect(agent.id).toBe('test-agent');
      expect(agent.type).toBe('research');
      expect(agent.getState()).toBe('idle');
    });

    it('should reject invalid configuration', () => {
      // Arrange
      const invalidConfig = {
        id: '',  // Invalid: empty ID
        type: 'research'
      };

      // Act & Assert
      expect(() => new BaseAgent(invalidConfig as any, logger))
        .toThrow('Invalid agent configuration');
    });
  });

  describe('Agent State Transitions', () => {
    it('should transition from idle to running', async () => {
      // Test state machine
    });

    it('should handle error states correctly', async () => {
      // Test error handling
    });
  });
});
```

### 2.2 CLI Process Management Tests
```typescript
// src/cli/__tests__/cli-process-manager.spec.ts
describe('CLIProcessManager', () => {
  let manager: CLIProcessManager;
  let mockSpawn: jest.MockedFunction<typeof spawn>;

  beforeEach(() => {
    mockSpawn = spawn as jest.MockedFunction<typeof spawn>;
    manager = new CLIProcessManager();
  });

  describe('Process Spawning', () => {
    it('should spawn claude process with correct arguments', async () => {
      // Arrange
      const mockProcess = MockFactory.createMockChildProcess();
      mockSpawn.mockReturnValue(mockProcess);

      const config: CLISpawnConfig = {
        prompt: 'Test prompt',
        systemPrompt: 'Test system prompt',
        outputFormat: 'json',
        maxTurns: 3
      };

      // Act
      const processPromise = manager.spawn(config);

      // Simulate successful response
      process.nextTick(() => {
        mockProcess.stdout.emit('data', JSON.stringify(
          MockFactory.createMockClaudeResponse()
        ));
        mockProcess.emit('close', 0);
      });

      const result = await processPromise;

      // Assert
      expect(mockSpawn).toHaveBeenCalledWith('claude', [
        '-p', 'Test prompt',
        '--system-prompt', 'Test system prompt',
        '--output-format', 'json',
        '--max-turns', '3'
      ], expect.any(Object));
      
      expect(result.session_id).toBeDefined();
    });

    it('should handle process errors', async () => {
      // Test error scenarios
    });
  });

  describe('Session Management', () => {
    it('should maintain session continuity', async () => {
      // Test session resume functionality
    });
  });
});
```

### 2.3 Memory System Tests
```typescript
// src/memory/__tests__/memory-manager.spec.ts
describe('MemoryManager', () => {
  let helper: IntegrationTestHelper;
  let manager: MemoryManager;

  beforeEach(() => {
    helper = new IntegrationTestHelper();
    manager = new MemoryManager();
  });

  afterEach(async () => {
    await helper.cleanup();
  });

  describe('Memory Loading', () => {
    it('should load project memory correctly', async () => {
      // Arrange
      const projectDir = await helper.createTempProject();
      await helper.createMemoryFile(projectDir, '# Test Memory\n- Rule 1');

      // Act
      const memory = await manager.loadProjectMemory(projectDir);

      // Assert
      expect(memory.content).toContain('Rule 1');
      expect(memory.type).toBe('project');
    });

    it('should handle memory imports', async () => {
      // Test @import syntax
    });

    it('should merge memory hierarchy correctly', async () => {
      // Test user + project + local memory merge
    });
  });
});
```

### 2.4 Permission System Tests
```typescript
// src/permissions/__tests__/permission-manager.spec.ts
describe('PermissionManager', () => {
  describe('Tool Permissions', () => {
    it('should allow permitted tools', () => {
      // Arrange
      const manager = new PermissionManager({
        allow: ['Bash(ls:*)', 'Read(**)'],
        deny: []
      });

      // Act & Assert
      expect(manager.isAllowed('Bash', 'ls -la')).toBe(true);
      expect(manager.isAllowed('Read', '/any/file')).toBe(true);
    });

    it('should deny non-permitted tools', () => {
      // Test denial logic
    });

    it('should handle MCP tool patterns', () => {
      // Test mcp__server__tool patterns
    });
  });
});
```

## Testing Patterns

### 3.1 London School TDD Cycle
```typescript
// Example: Testing from outside-in
describe('Task Execution (London School)', () => {
  it('should execute task through the system', async () => {
    // 1. Start with the public API
    const orchestrator = new Orchestrator();
    
    // 2. Mock all collaborators
    const mockAgentPool = createMock<AgentPool>();
    const mockTaskQueue = createMock<TaskQueue>();
    const mockResultStore = createMock<ResultStore>();
    
    orchestrator.setDependencies({
      agentPool: mockAgentPool,
      taskQueue: mockTaskQueue,
      resultStore: mockResultStore
    });

    // 3. Define expected interactions
    mockTaskQueue.dequeue.mockResolvedValue(testTask);
    mockAgentPool.assignTask.mockResolvedValue(testAgent);
    mockResultStore.save.mockResolvedValue(undefined);

    // 4. Execute
    await orchestrator.processNextTask();

    // 5. Verify interactions
    expect(mockTaskQueue.dequeue).toHaveBeenCalledOnce();
    expect(mockAgentPool.assignTask).toHaveBeenCalledWith(testTask);
    expect(mockResultStore.save).toHaveBeenCalledWith(
      expect.objectContaining({ taskId: testTask.id })
    );
  });
});
```

### 3.2 Test Data Builders
```typescript
// test/builders/task-builder.ts
export class TaskBuilder {
  private task: Partial<ITask> = {
    id: `task_${Date.now()}`,
    type: 'research',
    status: 'pending',
    priority: 'medium'
  };

  withId(id: string): this {
    this.task.id = id;
    return this;
  }

  withType(type: TaskType): this {
    this.task.type = type;
    return this;
  }

  withHighPriority(): this {
    this.task.priority = 'high';
    return this;
  }

  build(): ITask {
    return this.task as ITask;
  }
}

// Usage
const task = new TaskBuilder()
  .withType('code_review')
  .withHighPriority()
  .build();
```

### 3.3 Custom Matchers
```typescript
// test/matchers/claude-matchers.ts
expect.extend({
  toBeValidClaudeResponse(received: any) {
    const pass = 
      received?.type === 'result' &&
      ['success', 'error_max_turns', 'error'].includes(received?.subtype) &&
      typeof received?.session_id === 'string' &&
      typeof received?.cost_usd === 'number';

    return {
      pass,
      message: () => pass
        ? `expected ${received} not to be a valid Claude response`
        : `expected ${received} to be a valid Claude response`
    };
  }
});

// Usage
expect(response).toBeValidClaudeResponse();
```

## Test Organization

### Directory Structure
```
src/
├── agents/
│   ├── __tests__/
│   │   ├── base-agent.spec.ts
│   │   ├── research-agent.spec.ts
│   │   └── code-agent.spec.ts
│   ├── base-agent.ts
│   └── ...
├── cli/
│   ├── __tests__/
│   │   ├── cli-process-manager.spec.ts
│   │   └── session-manager.spec.ts
│   └── ...
├── orchestration/
│   ├── __tests__/
│   │   ├── orchestrator.spec.ts
│   │   └── task-scheduler.spec.ts
│   └── ...
└── ...

test/
├── setup.ts
├── teardown.ts
├── jest.config.ts
├── tsconfig.json
├── mocks/
├── doubles/
├── builders/
├── fixtures/
├── helpers/
└── integration/
    ├── end-to-end.spec.ts
    └── system.spec.ts
```

## Implementation Plan

### Phase 1: Test Infrastructure (Day 1)
1. **Morning**:
   - Setup Jest configuration
   - Create mock factory
   - Implement test doubles

2. **Afternoon**:
   - Create test builders
   - Setup custom matchers
   - Configure coverage tools

### Phase 2: Core Test Suites (Day 2)
1. **Morning**:
   - Write agent lifecycle tests
   - Write CLI process management tests

2. **Afternoon**:
   - Write memory system tests
   - Write permission system tests

### Phase 3: Integration Tests (Day 3)
1. **Morning**:
   - Create integration test helpers
   - Write end-to-end test scenarios

2. **Afternoon**:
   - Performance test setup
   - Stress test implementation

## Testing Guidelines

### 1. Test Naming Convention
```typescript
// Format: should_expectedBehavior_when_condition
it('should_return_error_when_invalid_prompt_provided', () => {});
it('should_maintain_session_when_resuming_conversation', () => {});
```

### 2. AAA Pattern
```typescript
it('should execute task successfully', async () => {
  // Arrange
  const task = new TaskBuilder().build();
  const agent = new AgentBuilder().build();
  
  // Act
  const result = await agent.execute(task);
  
  // Assert
  expect(result.status).toBe('completed');
});
```

### 3. Mock Verification
```typescript
// Always verify mock interactions
expect(mockCLI.spawn).toHaveBeenCalledWith(
  expect.objectContaining({
    prompt: expect.stringContaining('research'),
    outputFormat: 'json'
  })
);

// Verify call order when important
const { order } = mockCLI.spawn.mock;
expect(order).toEqual(['init', 'execute', 'cleanup']);
```

## CI/CD Integration

### GitHub Actions Configuration
```yaml
# .github/workflows/test.yml
name: Test Suite

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Check coverage
        run: npm run coverage:check
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

## Success Metrics
- 100% test coverage (enforced)
- All tests pass reliably
- Test execution time <30s
- No flaky tests
- Clear test failure messages
- Comprehensive mock coverage
- Integration tests validate real CLI

## Next Steps
After completing TDD setup:
1. Proceed to Step 2: Base Agent Implementation
2. Use TDD to drive all development
3. Maintain 100% coverage throughout