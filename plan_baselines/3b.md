# Step 3b: Concurrent Repository Access and Conflict Management

## Objective
Design and implement a robust system for multiple agents to safely work on different parts of the same repository in parallel, preventing conflicts and ensuring code integrity.

## Core Challenges

1. **File-level conflicts**: Two agents editing the same file
2. **Semantic conflicts**: Changes that don't conflict textually but break functionality
3. **Build state consistency**: Ensuring tests pass after concurrent changes
4. **Git conflicts**: Managing commits and branches from multiple agents
5. **Race conditions**: Rapid successive edits to the same code

## Architecture Overview

### 1. Repository Access Patterns

#### 1.1 Branch-per-Agent Strategy
```typescript
// src/repository/branch-strategy.ts
export interface IBranchStrategy {
  createAgentBranch(agentId: string, taskId: string): Promise<string>;
  mergeBranch(branchName: string, targetBranch: string): Promise<IMergeResult>;
  detectConflicts(branchName: string): Promise<IConflict[]>;
  cleanupBranch(branchName: string): Promise<void>;
}

export class GitBranchStrategy implements IBranchStrategy {
  constructor(
    private repoPath: string,
    private logger: Logger
  ) {}

  async createAgentBranch(agentId: string, taskId: string): Promise<string> {
    const branchName = `agent/${agentId}/task/${taskId}`;
    
    // Ensure we're on the latest main
    await this.git(['checkout', 'main']);
    await this.git(['pull', 'origin', 'main']);
    
    // Create and checkout new branch
    await this.git(['checkout', '-b', branchName]);
    
    this.logger.info('Created agent branch', { agentId, taskId, branchName });
    return branchName;
  }

  async mergeBranch(branchName: string, targetBranch: string = 'main'): Promise<IMergeResult> {
    try {
      // Attempt merge
      await this.git(['checkout', targetBranch]);
      await this.git(['merge', '--no-ff', branchName]);
      
      return {
        success: true,
        branch: branchName,
        conflicts: []
      };
    } catch (error) {
      // Handle merge conflicts
      const conflicts = await this.detectConflicts(branchName);
      return {
        success: false,
        branch: branchName,
        conflicts,
        error: error.message
      };
    }
  }

  async detectConflicts(branchName: string): Promise<IConflict[]> {
    const output = await this.git(['diff', '--name-only', '--diff-filter=U']);
    const conflictedFiles = output.split('\n').filter(f => f.trim());
    
    return conflictedFiles.map(file => ({
      file,
      type: 'merge_conflict',
      branch: branchName
    }));
  }

  private async git(args: string[]): Promise<string> {
    const result = await execAsync('git', args, { cwd: this.repoPath });
    return result.stdout;
  }
}
```

#### 1.2 File Locking Mechanism
```typescript
// src/repository/file-lock-manager.ts
export interface IFileLockManager {
  acquireLock(agentId: string, files: string[]): Promise<ILockResult>;
  releaseLock(agentId: string, files: string[]): Promise<void>;
  checkLocks(files: string[]): Promise<ILockStatus[]>;
  forceReleaseStaleLocks(): Promise<void>;
}

export class DistributedFileLockManager implements IFileLockManager {
  private locks = new Map<string, IFileLock>();
  private lockTimeout = 5 * 60 * 1000; // 5 minutes

  async acquireLock(agentId: string, files: string[]): Promise<ILockResult> {
    const timestamp = Date.now();
    const locksToAcquire: IFileLock[] = [];
    const conflicts: string[] = [];

    // Check all files first (atomic check)
    for (const file of files) {
      const existingLock = this.locks.get(file);
      
      if (existingLock && !this.isLockStale(existingLock)) {
        if (existingLock.agentId !== agentId) {
          conflicts.push(file);
        }
      } else {
        locksToAcquire.push({
          file,
          agentId,
          timestamp,
          taskId: `task_${timestamp}`
        });
      }
    }

    if (conflicts.length > 0) {
      return {
        success: false,
        conflicts,
        lockedBy: conflicts.map(f => ({
          file: f,
          agentId: this.locks.get(f)!.agentId
        }))
      };
    }

    // Acquire all locks atomically
    for (const lock of locksToAcquire) {
      this.locks.set(lock.file, lock);
    }

    this.logger.info('Acquired file locks', {
      agentId,
      files,
      count: locksToAcquire.length
    });

    return { success: true, locks: locksToAcquire };
  }

  async releaseLock(agentId: string, files: string[]): Promise<void> {
    for (const file of files) {
      const lock = this.locks.get(file);
      if (lock && lock.agentId === agentId) {
        this.locks.delete(file);
      }
    }

    this.logger.info('Released file locks', { agentId, files });
  }

  async checkLocks(files: string[]): Promise<ILockStatus[]> {
    return files.map(file => {
      const lock = this.locks.get(file);
      return {
        file,
        locked: !!lock && !this.isLockStale(lock),
        agentId: lock?.agentId,
        since: lock?.timestamp
      };
    });
  }

  async forceReleaseStaleLocks(): Promise<void> {
    const now = Date.now();
    const staleFiles: string[] = [];

    for (const [file, lock] of this.locks.entries()) {
      if (this.isLockStale(lock)) {
        staleFiles.push(file);
      }
    }

    for (const file of staleFiles) {
      this.locks.delete(file);
    }

    if (staleFiles.length > 0) {
      this.logger.warn('Released stale locks', { count: staleFiles.length, files: staleFiles });
    }
  }

  private isLockStale(lock: IFileLock): boolean {
    return Date.now() - lock.timestamp > this.lockTimeout;
  }
}

interface IFileLock {
  file: string;
  agentId: string;
  timestamp: number;
  taskId: string;
}
```

### 2. Workspace Isolation Strategies

#### 2.1 Copy-on-Write Workspace
```typescript
// src/repository/cow-workspace.ts
export class CopyOnWriteWorkspace {
  private baseRepo: string;
  private workspaces = new Map<string, IWorkspace>();

  async createWorkspace(agentId: string): Promise<IWorkspace> {
    const workspaceId = `ws_${agentId}_${Date.now()}`;
    const workspacePath = path.join('/tmp/workspaces', workspaceId);

    // Create workspace directory
    await fs.mkdir(workspacePath, { recursive: true });

    // Use git worktree for efficient workspace creation
    await execAsync('git', [
      'worktree', 'add',
      workspacePath,
      '-b', `workspace/${agentId}`
    ], { cwd: this.baseRepo });

    const workspace: IWorkspace = {
      id: workspaceId,
      agentId,
      path: workspacePath,
      baseBranch: 'main',
      createdAt: new Date()
    };

    this.workspaces.set(workspaceId, workspace);
    
    this.logger.info('Created COW workspace', { agentId, workspaceId });
    return workspace;
  }

  async syncWorkspace(workspaceId: string): Promise<ISyncResult> {
    const workspace = this.workspaces.get(workspaceId);
    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    try {
      // Fetch latest changes
      await execAsync('git', ['fetch', 'origin'], { cwd: workspace.path });
      
      // Check for conflicts
      const mergeBase = await execAsync('git', [
        'merge-base', 'HEAD', 'origin/main'
      ], { cwd: workspace.path });

      const conflicts = await execAsync('git', [
        'diff', '--name-only', mergeBase.stdout.trim(), 'origin/main'
      ], { cwd: workspace.path });

      return {
        success: true,
        conflicts: conflicts.stdout.split('\n').filter(f => f.trim())
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  async mergeWorkspace(workspaceId: string): Promise<IMergeResult> {
    const workspace = this.workspaces.get(workspaceId);
    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    // Create a merge commit in the main repo
    try {
      await execAsync('git', ['checkout', 'main'], { cwd: this.baseRepo });
      await execAsync('git', ['merge', '--no-ff', `workspace/${workspace.agentId}`], 
        { cwd: this.baseRepo });

      return { success: true };
    } catch (error) {
      // Handle merge conflicts
      return {
        success: false,
        conflicts: await this.detectMergeConflicts(this.baseRepo)
      };
    }
  }

  async destroyWorkspace(workspaceId: string): Promise<void> {
    const workspace = this.workspaces.get(workspaceId);
    if (!workspace) return;

    // Remove git worktree
    await execAsync('git', ['worktree', 'remove', workspace.path], 
      { cwd: this.baseRepo });

    // Clean up branch
    await execAsync('git', ['branch', '-D', `workspace/${workspace.agentId}`], 
      { cwd: this.baseRepo });

    this.workspaces.delete(workspaceId);
  }
}
```

#### 2.2 Semantic Conflict Detection
```typescript
// src/repository/semantic-conflict-detector.ts
export class SemanticConflictDetector {
  constructor(
    private astAnalyzer: IASTAnalyzer,
    private testRunner: ITestRunner
  ) {}

  async detectConflicts(
    changes1: IFileChange[],
    changes2: IFileChange[]
  ): Promise<ISemanticConflict[]> {
    const conflicts: ISemanticConflict[] = [];

    // Check for function/class modifications
    const symbols1 = await this.extractSymbols(changes1);
    const symbols2 = await this.extractSymbols(changes2);

    // Find overlapping symbol modifications
    for (const symbol1 of symbols1) {
      const overlap = symbols2.find(s2 => 
        s2.name === symbol1.name && 
        s2.file === symbol1.file
      );

      if (overlap) {
        conflicts.push({
          type: 'symbol_conflict',
          symbol: symbol1.name,
          file: symbol1.file,
          agents: [symbol1.agentId, overlap.agentId]
        });
      }
    }

    // Check for import/dependency conflicts
    const imports1 = await this.extractImports(changes1);
    const imports2 = await this.extractImports(changes2);

    // Detect conflicting import changes
    for (const imp1 of imports1.modified) {
      if (imports2.removed.includes(imp1)) {
        conflicts.push({
          type: 'import_conflict',
          description: `Import ${imp1} modified by one agent, removed by another`,
          severity: 'high'
        });
      }
    }

    return conflicts;
  }

  async validateIntegration(
    workspace1: string,
    workspace2: string
  ): Promise<IIntegrationResult> {
    // Create temporary merge
    const tempDir = await fs.mkdtemp('/tmp/merge-test-');
    
    try {
      // Clone and merge both workspaces
      await execAsync('git', ['clone', workspace1, tempDir]);
      await execAsync('git', ['remote', 'add', 'workspace2', workspace2], 
        { cwd: tempDir });
      await execAsync('git', ['fetch', 'workspace2'], { cwd: tempDir });
      await execAsync('git', ['merge', 'workspace2/main'], { cwd: tempDir });

      // Run tests
      const testResult = await this.testRunner.runTests(tempDir);

      return {
        success: testResult.passed,
        failedTests: testResult.failed,
        conflicts: []
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        conflicts: ['merge_failed']
      };
    } finally {
      // Cleanup
      await fs.rm(tempDir, { recursive: true, force: true });
    }
  }

  private async extractSymbols(changes: IFileChange[]): Promise<ISymbol[]> {
    const symbols: ISymbol[] = [];

    for (const change of changes) {
      if (change.type === 'modify' || change.type === 'create') {
        const ast = await this.astAnalyzer.parse(change.content);
        const fileSymbols = this.astAnalyzer.extractSymbols(ast);
        
        symbols.push(...fileSymbols.map(s => ({
          ...s,
          file: change.file,
          agentId: change.agentId
        })));
      }
    }

    return symbols;
  }
}
```

### 3. Coordination and Communication

#### 3.1 Change Coordination Service
```typescript
// src/repository/change-coordinator.ts
export class ChangeCoordinator {
  private pendingChanges = new Map<string, IPendingChange[]>();
  private activeAgents = new Map<string, IAgentActivity>();

  async registerIntent(
    agentId: string,
    intent: IChangeIntent
  ): Promise<IIntentResponse> {
    // Check for conflicts with other agents' intents
    const conflicts = await this.checkIntentConflicts(intent);
    
    if (conflicts.length > 0) {
      return {
        approved: false,
        conflicts,
        suggestions: await this.generateAlternatives(intent, conflicts)
      };
    }

    // Register the intent
    this.addPendingChange({
      agentId,
      intent,
      timestamp: Date.now(),
      status: 'pending'
    });

    // Notify other agents
    await this.notifyAgents(agentId, intent);

    return { approved: true };
  }

  async checkIntentConflicts(intent: IChangeIntent): Promise<IConflict[]> {
    const conflicts: IConflict[] = [];

    for (const [file, changes] of this.pendingChanges.entries()) {
      if (intent.files.includes(file)) {
        for (const change of changes) {
          if (change.status === 'pending' || change.status === 'in_progress') {
            conflicts.push({
              type: 'pending_change',
              file,
              agentId: change.agentId,
              description: `Agent ${change.agentId} is modifying ${file}`
            });
          }
        }
      }
    }

    return conflicts;
  }

  async coordinateMerge(
    agents: string[]
  ): Promise<IMergeCoordinationResult> {
    // Sort agents by priority and change complexity
    const sortedAgents = await this.prioritizeAgents(agents);
    const mergeOrder: IMergeStep[] = [];

    for (const agentId of sortedAgents) {
      const changes = await this.getAgentChanges(agentId);
      const dependencies = await this.analyzeDependencies(changes);

      mergeOrder.push({
        agentId,
        order: mergeOrder.length,
        dependencies,
        estimatedImpact: await this.estimateImpact(changes)
      });
    }

    return {
      mergeOrder,
      estimatedDuration: this.estimateMergeDuration(mergeOrder),
      riskLevel: this.assessMergeRisk(mergeOrder)
    };
  }

  private async generateAlternatives(
    intent: IChangeIntent,
    conflicts: IConflict[]
  ): Promise<IAlternativeSuggestion[]> {
    const suggestions: IAlternativeSuggestion[] = [];

    // Suggest working on different files
    const conflictedFiles = conflicts.map(c => c.file);
    const relatedFiles = await this.findRelatedFiles(intent.files);
    const availableFiles = relatedFiles.filter(f => !conflictedFiles.includes(f));

    if (availableFiles.length > 0) {
      suggestions.push({
        type: 'alternative_files',
        description: 'Work on related files that are not currently locked',
        files: availableFiles
      });
    }

    // Suggest delayed execution
    const estimatedFreeTime = await this.estimateFileAvailability(conflictedFiles);
    suggestions.push({
      type: 'delayed_execution',
      description: `Wait ${estimatedFreeTime}ms for files to become available`,
      delay: estimatedFreeTime
    });

    // Suggest collaboration
    suggestions.push({
      type: 'collaboration',
      description: 'Collaborate with the other agent',
      collaborators: conflicts.map(c => c.agentId)
    });

    return suggestions;
  }
}
```

#### 3.2 Real-time Conflict Resolution
```typescript
// src/repository/realtime-conflict-resolver.ts
export class RealtimeConflictResolver {
  private resolutionStrategies: IResolutionStrategy[];

  constructor() {
    this.resolutionStrategies = [
      new AutoMergeStrategy(),
      new SemanticMergeStrategy(),
      new CollaborativeStrategy(),
      new PriorityBasedStrategy()
    ];
  }

  async resolveConflict(conflict: IConflict): Promise<IResolution> {
    // Try strategies in order
    for (const strategy of this.resolutionStrategies) {
      if (strategy.canHandle(conflict)) {
        const resolution = await strategy.resolve(conflict);
        if (resolution.success) {
          return resolution;
        }
      }
    }

    // If all strategies fail, escalate
    return {
      success: false,
      requiresHumanIntervention: true,
      conflict
    };
  }
}

// Strategy implementations
class AutoMergeStrategy implements IResolutionStrategy {
  canHandle(conflict: IConflict): boolean {
    return conflict.type === 'non_overlapping_changes';
  }

  async resolve(conflict: IConflict): Promise<IResolution> {
    // Use git's auto-merge capabilities
    try {
      const result = await execAsync('git', [
        'merge-file',
        conflict.base,
        conflict.ours,
        conflict.theirs
      ]);

      return {
        success: true,
        mergedContent: result.stdout,
        strategy: 'auto_merge'
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

class SemanticMergeStrategy implements IResolutionStrategy {
  canHandle(conflict: IConflict): boolean {
    return conflict.type === 'semantic_conflict';
  }

  async resolve(conflict: IConflict): Promise<IResolution> {
    // Parse AST of both versions
    const ast1 = await parseAST(conflict.version1);
    const ast2 = await parseAST(conflict.version2);

    // Attempt to merge at semantic level
    const mergedAST = await this.mergeASTs(ast1, ast2);

    if (mergedAST) {
      return {
        success: true,
        mergedContent: generateCode(mergedAST),
        strategy: 'semantic_merge'
      };
    }

    return { success: false };
  }
}
```

### 4. Advanced Conflict Prevention

#### 4.1 Predictive Conflict Detection
```typescript
// src/repository/predictive-conflict-detector.ts
export class PredictiveConflictDetector {
  private changeHistory: IChangeHistory[] = [];
  private ml: IMLModel;

  async predictConflicts(
    agent1Plan: ITaskPlan,
    agent2Plan: ITaskPlan
  ): Promise<IPredictedConflict[]> {
    const features = this.extractFeatures(agent1Plan, agent2Plan);
    const prediction = await this.ml.predict(features);

    if (prediction.conflictProbability > 0.7) {
      return [{
        probability: prediction.conflictProbability,
        files: prediction.likelyFiles,
        type: prediction.conflictType,
        estimatedImpact: prediction.impact
      }];
    }

    return [];
  }

  private extractFeatures(plan1: ITaskPlan, plan2: ITaskPlan): IFeatures {
    return {
      fileOverlap: this.calculateFileOverlap(plan1.files, plan2.files),
      symbolOverlap: this.calculateSymbolOverlap(plan1.symbols, plan2.symbols),
      taskSimilarity: this.calculateTaskSimilarity(plan1.task, plan2.task),
      historicalConflictRate: this.getHistoricalRate(plan1.agentId, plan2.agentId)
    };
  }
}
```

#### 4.2 Smart Task Distribution
```typescript
// src/orchestration/smart-task-distributor.ts
export class SmartTaskDistributor {
  async distributeTasks(
    tasks: ITask[],
    agents: IAgent[]
  ): Promise<ITaskAssignment[]> {
    // Build conflict graph
    const conflictGraph = await this.buildConflictGraph(tasks);
    
    // Use graph coloring algorithm to assign non-conflicting tasks
    const assignments = this.graphColoring(conflictGraph, agents);

    // Optimize for parallelism
    return this.optimizeAssignments(assignments);
  }

  private async buildConflictGraph(tasks: ITask[]): Promise<IGraph> {
    const graph = new Graph();

    for (let i = 0; i < tasks.length; i++) {
      for (let j = i + 1; j < tasks.length; j++) {
        const conflict = await this.tasksConflict(tasks[i], tasks[j]);
        if (conflict) {
          graph.addEdge(i, j);
        }
      }
    }

    return graph;
  }

  private async tasksConflict(task1: ITask, task2: ITask): Promise<boolean> {
    // Check file overlap
    const files1 = await this.predictTaskFiles(task1);
    const files2 = await this.predictTaskFiles(task2);
    
    const overlap = files1.filter(f => files2.includes(f));
    return overlap.length > 0;
  }
}
```

### 5. Testing Concurrent Operations

```typescript
// src/repository/__tests__/concurrent-operations.spec.ts
describe('Concurrent Repository Operations', () => {
  let coordinator: ChangeCoordinator;
  let workspace: CopyOnWriteWorkspace;
  let conflictDetector: SemanticConflictDetector;

  describe('Parallel modifications', () => {
    it('should handle non-conflicting parallel edits', async () => {
      // Create two agent workspaces
      const ws1 = await workspace.createWorkspace('agent-1');
      const ws2 = await workspace.createWorkspace('agent-2');

      // Agent 1 modifies file A
      await modifyFile(ws1.path, 'src/moduleA.ts', 'content A');
      
      // Agent 2 modifies file B
      await modifyFile(ws2.path, 'src/moduleB.ts', 'content B');

      // Both should merge successfully
      const merge1 = await workspace.mergeWorkspace(ws1.id);
      const merge2 = await workspace.mergeWorkspace(ws2.id);

      expect(merge1.success).toBe(true);
      expect(merge2.success).toBe(true);
    });

    it('should detect and prevent conflicting edits', async () => {
      // Register intent for agent 1
      const intent1 = await coordinator.registerIntent('agent-1', {
        files: ['src/shared.ts'],
        operation: 'modify',
        description: 'Update shared module'
      });

      expect(intent1.approved).toBe(true);

      // Agent 2 tries to modify same file
      const intent2 = await coordinator.registerIntent('agent-2', {
        files: ['src/shared.ts'],
        operation: 'modify',
        description: 'Also update shared module'
      });

      expect(intent2.approved).toBe(false);
      expect(intent2.conflicts).toHaveLength(1);
      expect(intent2.suggestions).toBeDefined();
    });

    it('should detect semantic conflicts', async () => {
      const changes1 = [{
        file: 'src/calculator.ts',
        type: 'modify',
        content: 'function add(a: number, b: number) { return a + b + 1; }',
        agentId: 'agent-1'
      }];

      const changes2 = [{
        file: 'src/calculator.ts',
        type: 'modify',
        content: 'function add(a: number, b: number) { return a + b - 1; }',
        agentId: 'agent-2'
      }];

      const conflicts = await conflictDetector.detectConflicts(changes1, changes2);
      
      expect(conflicts).toContainEqual(
        expect.objectContaining({
          type: 'symbol_conflict',
          symbol: 'add',
          file: 'src/calculator.ts'
        })
      );
    });
  });

  describe('Integration testing', () => {
    it('should validate merged changes pass tests', async () => {
      const ws1 = await workspace.createWorkspace('agent-1');
      const ws2 = await workspace.createWorkspace('agent-2');

      // Make changes in both workspaces
      await implementFeature(ws1.path, 'feature-1');
      await implementFeature(ws2.path, 'feature-2');

      // Validate integration
      const validation = await conflictDetector.validateIntegration(
        ws1.path,
        ws2.path
      );

      expect(validation.success).toBe(true);
      expect(validation.failedTests).toHaveLength(0);
    });
  });
});
```

## Best Practices for Parallel Development

### 1. **File Granularity**
- Encourage small, focused files
- Use dependency injection to reduce coupling
- Implement clear module boundaries

### 2. **Communication Patterns**
- Agents announce their intentions early
- Real-time updates on file modifications
- Collaborative conflict resolution

### 3. **Testing Strategy**
- Each agent runs tests in isolation
- Integration tests before merging
- Continuous validation of main branch

### 4. **Recovery Mechanisms**
- Automatic rollback on test failures
- Checkpoint system for complex changes
- Human escalation for unresolved conflicts

## Implementation Priority

1. **Phase 1**: Basic file locking and branch-per-agent
2. **Phase 2**: Copy-on-write workspaces
3. **Phase 3**: Semantic conflict detection
4. **Phase 4**: Predictive conflict prevention
5. **Phase 5**: Advanced ML-based optimization

This comprehensive system ensures that multiple agents can work on the same repository efficiently while maintaining code integrity and preventing conflicts.