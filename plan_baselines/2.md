# Step 2: Base Agent Implementation with Claude CLI Integration

## Objective
Implement the base agent abstraction that leverages Claude CLI's SDK mode, session management, and memory system.

## Prerequisites
- Step 1 TDD infrastructure complete
- Mock factories and test doubles ready
- 100% test coverage requirement established

## Core Agent Architecture

### 2.1 Agent Interfaces
```typescript
// src/types/agent.types.ts
export interface IAgent {
  readonly id: string;
  readonly type: AgentType;
  readonly sessionId?: string;
  
  initialize(): Promise<void>;
  execute(task: ITask): Promise<IAgentResult>;
  terminate(): Promise<void>;
  getState(): AgentState;
  getMetrics(): IAgentMetrics;
}

export interface IAgentConfig {
  id: string;
  type: AgentType;
  systemPrompt?: string;
  appendSystemPrompt?: string;
  maxTurns?: number;
  allowedTools?: string[];
  disallowedTools?: string[];
  memoryPath?: string;
  workingDirectory?: string;
  env?: Record<string, string>;
}

export interface IAgentResult {
  taskId: string;
  agentId: string;
  sessionId: string;
  status: 'completed' | 'failed' | 'partial';
  result?: string;
  error?: Error;
  metrics: {
    duration_ms: number;
    cost_usd: number;
    turns_used: number;
    tokens_used?: number;
  };
  timestamp: Date;
}

export interface IAgentMetrics {
  tasksCompleted: number;
  tasksFailed: number;
  totalCost: number;
  totalDuration: number;
  averageResponseTime: number;
  sessionContinuity: number;
}

export type AgentType = 'research' | 'code' | 'review' | 'test' | 'orchestrator';
export type AgentState = 'idle' | 'initializing' | 'ready' | 'busy' | 'error' | 'terminated';
```

### 2.2 Base Agent Implementation
```typescript
// src/agents/base-agent.ts
import { EventEmitter } from 'events';
import { Logger } from '../utils/logger';
import { CLIProcessManager } from '../cli/cli-process-manager';
import { MemoryManager } from '../memory/memory-manager';
import { MetricsCollector } from '../metrics/metrics-collector';

export abstract class BaseAgent extends EventEmitter implements IAgent {
  public readonly id: string;
  public readonly type: AgentType;
  
  protected config: IAgentConfig;
  protected state: AgentState = 'idle';
  protected logger: Logger;
  protected cliManager: CLIProcessManager;
  protected memoryManager: MemoryManager;
  protected metrics: MetricsCollector;
  
  private _sessionId?: string;
  private _isInitialized = false;

  constructor(
    config: IAgentConfig,
    logger: Logger,
    cliManager?: CLIProcessManager,
    memoryManager?: MemoryManager
  ) {
    super();
    this.validateConfig(config);
    
    this.id = config.id;
    this.type = config.type;
    this.config = config;
    this.logger = logger.child({ agentId: this.id, agentType: this.type });
    
    // Dependency injection with defaults
    this.cliManager = cliManager || new CLIProcessManager(this.logger);
    this.memoryManager = memoryManager || new MemoryManager(this.logger);
    this.metrics = new MetricsCollector(this.id);
    
    this.logger.info('Agent created', { config: this.sanitizeConfig(config) });
  }

  get sessionId(): string | undefined {
    return this._sessionId;
  }

  async initialize(): Promise<void> {
    if (this._isInitialized) {
      this.logger.warn('Agent already initialized');
      return;
    }

    this.setState('initializing');
    this.logger.info('Initializing agent');

    try {
      // Load memory files
      await this.loadMemory();
      
      // Create initial session
      await this.createSession();
      
      // Perform agent-specific initialization
      await this.onInitialize();
      
      this._isInitialized = true;
      this.setState('ready');
      this.logger.info('Agent initialized successfully', { sessionId: this._sessionId });
    } catch (error) {
      this.setState('error');
      this.logger.error('Failed to initialize agent', error);
      throw new Error(`Agent initialization failed: ${error.message}`);
    }
  }

  async execute(task: ITask): Promise<IAgentResult> {
    if (!this._isInitialized) {
      throw new Error('Agent not initialized');
    }

    if (this.state !== 'ready') {
      throw new Error(`Agent not ready. Current state: ${this.state}`);
    }

    this.setState('busy');
    const startTime = Date.now();
    
    this.logger.info('Executing task', { 
      taskId: task.id, 
      taskType: task.type,
      taskPriority: task.priority 
    });

    try {
      // Validate task compatibility
      this.validateTask(task);
      
      // Prepare execution context
      const context = await this.prepareContext(task);
      
      // Execute via Claude CLI
      const response = await this.executeClaude(task, context);
      
      // Process and validate response
      const result = await this.processResponse(response, task);
      
      // Update metrics
      const duration = Date.now() - startTime;
      this.metrics.recordSuccess(duration, response.cost_usd);
      
      this.setState('ready');
      
      return {
        taskId: task.id,
        agentId: this.id,
        sessionId: this._sessionId!,
        status: 'completed',
        result: result,
        metrics: {
          duration_ms: duration,
          cost_usd: response.cost_usd,
          turns_used: response.num_turns,
          tokens_used: response.tokens_used
        },
        timestamp: new Date()
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      this.metrics.recordFailure(duration);
      
      this.logger.error('Task execution failed', { 
        taskId: task.id, 
        error: error.message 
      });
      
      this.setState('ready');
      
      return {
        taskId: task.id,
        agentId: this.id,
        sessionId: this._sessionId!,
        status: 'failed',
        error: error,
        metrics: {
          duration_ms: duration,
          cost_usd: 0,
          turns_used: 0
        },
        timestamp: new Date()
      };
    }
  }

  async terminate(): Promise<void> {
    this.logger.info('Terminating agent');
    
    this.setState('terminated');
    
    // Clean up resources
    if (this._sessionId) {
      await this.cliManager.endSession(this._sessionId);
    }
    
    // Allow subclasses to cleanup
    await this.onTerminate();
    
    this.removeAllListeners();
    this.logger.info('Agent terminated');
  }

  getState(): AgentState {
    return this.state;
  }

  getMetrics(): IAgentMetrics {
    return this.metrics.getMetrics();
  }

  // Protected methods for subclasses
  protected abstract onInitialize(): Promise<void>;
  protected abstract prepareContext(task: ITask): Promise<IExecutionContext>;
  protected abstract processResponse(response: ClaudeSDKResponse, task: ITask): Promise<string>;
  protected abstract onTerminate(): Promise<void>;

  // Private helper methods
  private validateConfig(config: IAgentConfig): void {
    if (!config.id || typeof config.id !== 'string') {
      throw new Error('Invalid agent configuration: id is required');
    }
    
    if (!config.type || !['research', 'code', 'review', 'test', 'orchestrator'].includes(config.type)) {
      throw new Error('Invalid agent configuration: valid type is required');
    }
  }

  private sanitizeConfig(config: IAgentConfig): Partial<IAgentConfig> {
    // Remove sensitive information from logs
    const { env, ...safeConfig } = config;
    return safeConfig;
  }

  private setState(state: AgentState): void {
    const previousState = this.state;
    this.state = state;
    this.emit('stateChange', { previousState, currentState: state });
    this.logger.debug('Agent state changed', { previousState, currentState: state });
  }

  private async loadMemory(): Promise<void> {
    if (this.config.memoryPath) {
      const memory = await this.memoryManager.loadFromPath(this.config.memoryPath);
      this.logger.debug('Loaded agent memory', { 
        memorySize: memory.content.length 
      });
    }
  }

  private async createSession(): Promise<void> {
    // Create initial session with test prompt
    const response = await this.cliManager.createSession({
      prompt: 'Initialize session. Respond with "READY".',
      systemPrompt: this.buildSystemPrompt(),
      outputFormat: 'json',
      maxTurns: 1,
      workingDirectory: this.config.workingDirectory,
      env: this.config.env
    });

    this._sessionId = response.session_id;
  }

  private buildSystemPrompt(): string {
    const prompts: string[] = [];
    
    // Base system prompt for agent type
    prompts.push(this.getBaseSystemPrompt());
    
    // Custom system prompt
    if (this.config.systemPrompt) {
      prompts.push(this.config.systemPrompt);
    }
    
    // Append system prompt
    if (this.config.appendSystemPrompt) {
      prompts.push(this.config.appendSystemPrompt);
    }
    
    return prompts.join('\n\n');
  }

  private getBaseSystemPrompt(): string {
    const basePrompts: Record<AgentType, string> = {
      research: 'You are a specialized research agent. Focus on thorough analysis and cite sources.',
      code: 'You are a specialized coding agent. Write clean, maintainable code with tests.',
      review: 'You are a code review agent. Provide constructive feedback on code quality.',
      test: 'You are a testing agent. Write comprehensive tests and identify edge cases.',
      orchestrator: 'You are an orchestrator agent. Coordinate tasks between other agents.'
    };
    
    return basePrompts[this.type];
  }

  private validateTask(task: ITask): void {
    // Validate task is compatible with agent type
    const validTaskTypes = this.getValidTaskTypes();
    
    if (!validTaskTypes.includes(task.type)) {
      throw new Error(
        `Task type '${task.type}' not compatible with agent type '${this.type}'`
      );
    }
  }

  private getValidTaskTypes(): TaskType[] {
    const mapping: Record<AgentType, TaskType[]> = {
      research: ['research', 'analysis', 'documentation'],
      code: ['implementation', 'refactoring', 'optimization'],
      review: ['code_review', 'architecture_review'],
      test: ['unit_test', 'integration_test', 'test_planning'],
      orchestrator: ['planning', 'coordination', 'delegation']
    };
    
    return mapping[this.type];
  }

  private async executeClaude(
    task: ITask, 
    context: IExecutionContext
  ): Promise<ClaudeSDKResponse> {
    const prompt = this.buildPrompt(task, context);
    
    const response = await this.cliManager.execute({
      prompt,
      sessionId: this._sessionId!,
      outputFormat: 'json',
      maxTurns: this.config.maxTurns || 10,
      allowedTools: this.config.allowedTools,
      disallowedTools: this.config.disallowedTools,
      workingDirectory: context.workingDirectory || this.config.workingDirectory
    });
    
    return response;
  }

  private buildPrompt(task: ITask, context: IExecutionContext): string {
    return `
Task ID: ${task.id}
Task Type: ${task.type}
Priority: ${task.priority}

Description:
${task.description}

Context:
${JSON.stringify(context, null, 2)}

Please complete this task according to your specialization as a ${this.type} agent.
`;
  }
}
```

### 2.3 Specialized Agent Examples
```typescript
// src/agents/research-agent.ts
export class ResearchAgent extends BaseAgent {
  constructor(config: IAgentConfig, logger: Logger) {
    super(
      { ...config, type: 'research' },
      logger
    );
  }

  protected async onInitialize(): Promise<void> {
    // Research-specific initialization
    this.logger.debug('Initializing research agent capabilities');
  }

  protected async prepareContext(task: ITask): Promise<IExecutionContext> {
    return {
      workingDirectory: task.context?.projectPath,
      searchPaths: task.context?.searchPaths || [],
      sources: task.context?.sources || [],
      constraints: {
        maxDepth: 3,
        maxSources: 10,
        requiredSources: task.context?.requiredSources || []
      }
    };
  }

  protected async processResponse(
    response: ClaudeSDKResponse, 
    task: ITask
  ): Promise<string> {
    // Validate research output format
    if (!response.result) {
      throw new Error('No research results returned');
    }

    // Extract structured research data
    const research = this.parseResearchOutput(response.result);
    
    // Validate citations
    if (research.citations.length === 0 && task.context?.requireCitations) {
      throw new Error('Research missing required citations');
    }

    return JSON.stringify(research, null, 2);
  }

  protected async onTerminate(): Promise<void> {
    // Cleanup research resources
    this.logger.debug('Cleaning up research agent resources');
  }

  private parseResearchOutput(output: string): IResearchResult {
    // Parse structured research output
    // This would be more sophisticated in practice
    return {
      summary: output,
      findings: [],
      citations: [],
      confidence: 0.8
    };
  }
}

// src/agents/code-agent.ts  
export class CodeAgent extends BaseAgent {
  constructor(config: IAgentConfig, logger: Logger) {
    super(
      { ...config, type: 'code' },
      logger
    );
  }

  protected async onInitialize(): Promise<void> {
    // Setup code-specific tools
    this.config.allowedTools = [
      ...(this.config.allowedTools || []),
      'Edit(**)',
      'Read(**)',
      'Bash(npm test:*)',
      'Bash(npm run:*)'
    ];
  }

  protected async prepareContext(task: ITask): Promise<IExecutionContext> {
    return {
      workingDirectory: task.context?.projectPath,
      targetFiles: task.context?.files || [],
      testCommand: task.context?.testCommand || 'npm test',
      lintCommand: task.context?.lintCommand || 'npm run lint',
      requirements: task.context?.requirements || []
    };
  }

  protected async processResponse(
    response: ClaudeSDKResponse,
    task: ITask
  ): Promise<string> {
    // Validate code changes
    if (!response.result) {
      throw new Error('No code changes returned');
    }

    // Extract file modifications
    const changes = this.parseCodeChanges(response.result);
    
    // Validate tests were run
    if (task.context?.requireTests && !changes.testsRun) {
      throw new Error('Tests were not run as required');
    }

    return JSON.stringify(changes, null, 2);
  }

  protected async onTerminate(): Promise<void> {
    // Revert any uncommitted changes if needed
    this.logger.debug('Cleaning up code agent workspace');
  }

  private parseCodeChanges(output: string): ICodeChanges {
    // Parse code modification details
    return {
      filesModified: [],
      filesCreated: [],
      testsRun: false,
      testsPassed: false,
      lintPassed: false
    };
  }
}
```

### 2.4 Agent Factory
```typescript
// src/agents/agent-factory.ts
export class AgentFactory {
  constructor(
    private logger: Logger,
    private cliManager: CLIProcessManager,
    private memoryManager: MemoryManager
  ) {}

  createAgent(config: IAgentConfig): IAgent {
    const commonDeps = {
      logger: this.logger,
      cliManager: this.cliManager,
      memoryManager: this.memoryManager
    };

    switch (config.type) {
      case 'research':
        return new ResearchAgent(config, commonDeps);
      
      case 'code':
        return new CodeAgent(config, commonDeps);
      
      case 'review':
        return new ReviewAgent(config, commonDeps);
      
      case 'test':
        return new TestAgent(config, commonDeps);
      
      case 'orchestrator':
        return new OrchestratorAgent(config, commonDeps);
      
      default:
        throw new Error(`Unknown agent type: ${config.type}`);
    }
  }

  async createAndInitialize(config: IAgentConfig): Promise<IAgent> {
    const agent = this.createAgent(config);
    await agent.initialize();
    return agent;
  }
}
```

## Testing the Base Agent

### 3.1 Base Agent Tests
```typescript
// src/agents/__tests__/base-agent.spec.ts
describe('BaseAgent', () => {
  let agent: TestableBaseAgent;
  let mockCLIManager: jest.Mocked<CLIProcessManager>;
  let mockMemoryManager: jest.Mocked<MemoryManager>;
  let logger: jest.Mocked<Logger>;

  class TestableBaseAgent extends BaseAgent {
    async onInitialize(): Promise<void> {}
    async prepareContext(task: ITask): Promise<IExecutionContext> {
      return { workingDirectory: '/test' };
    }
    async processResponse(response: ClaudeSDKResponse): Promise<string> {
      return response.result || '';
    }
    async onTerminate(): Promise<void> {}
  }

  beforeEach(() => {
    mockCLIManager = createMock<CLIProcessManager>();
    mockMemoryManager = createMock<MemoryManager>();
    logger = createMock<Logger>();
    logger.child.mockReturnValue(logger);

    agent = new TestableBaseAgent(
      {
        id: 'test-agent',
        type: 'research',
        systemPrompt: 'Test prompt'
      },
      logger,
      mockCLIManager,
      mockMemoryManager
    );
  });

  describe('initialization', () => {
    it('should initialize successfully', async () => {
      // Arrange
      mockCLIManager.createSession.mockResolvedValue({
        session_id: 'test-session',
        subtype: 'success'
      } as ClaudeSDKResponse);

      // Act
      await agent.initialize();

      // Assert
      expect(agent.getState()).toBe('ready');
      expect(agent.sessionId).toBe('test-session');
      expect(mockCLIManager.createSession).toHaveBeenCalledWith(
        expect.objectContaining({
          systemPrompt: expect.stringContaining('research agent')
        })
      );
    });

    it('should handle initialization failure', async () => {
      // Arrange
      mockCLIManager.createSession.mockRejectedValue(
        new Error('Session creation failed')
      );

      // Act & Assert
      await expect(agent.initialize()).rejects.toThrow(
        'Agent initialization failed: Session creation failed'
      );
      expect(agent.getState()).toBe('error');
    });
  });

  describe('task execution', () => {
    beforeEach(async () => {
      mockCLIManager.createSession.mockResolvedValue({
        session_id: 'test-session',
        subtype: 'success'
      } as ClaudeSDKResponse);
      await agent.initialize();
    });

    it('should execute task successfully', async () => {
      // Arrange
      const task: ITask = {
        id: 'task-1',
        type: 'research',
        priority: 'high',
        description: 'Test research task'
      };

      mockCLIManager.execute.mockResolvedValue({
        type: 'result',
        subtype: 'success',
        result: 'Research completed',
        cost_usd: 0.01,
        duration_ms: 1000,
        num_turns: 2,
        session_id: 'test-session'
      } as ClaudeSDKResponse);

      // Act
      const result = await agent.execute(task);

      // Assert
      expect(result.status).toBe('completed');
      expect(result.result).toBe('Research completed');
      expect(result.metrics.cost_usd).toBe(0.01);
      expect(mockCLIManager.execute).toHaveBeenCalledWith(
        expect.objectContaining({
          sessionId: 'test-session',
          prompt: expect.stringContaining('task-1')
        })
      );
    });

    it('should handle execution failure', async () => {
      // Arrange
      const task: ITask = {
        id: 'task-2',
        type: 'research',
        priority: 'medium',
        description: 'Failing task'
      };

      mockCLIManager.execute.mockRejectedValue(
        new Error('CLI execution failed')
      );

      // Act
      const result = await agent.execute(task);

      // Assert
      expect(result.status).toBe('failed');
      expect(result.error?.message).toBe('CLI execution failed');
    });
  });

  describe('state management', () => {
    it('should track state transitions', async () => {
      const stateChanges: any[] = [];
      agent.on('stateChange', (change) => stateChanges.push(change));

      // Initialize
      mockCLIManager.createSession.mockResolvedValue({
        session_id: 'test-session',
        subtype: 'success'
      } as ClaudeSDKResponse);

      await agent.initialize();

      // Verify state transitions
      expect(stateChanges).toEqual([
        { previousState: 'idle', currentState: 'initializing' },
        { previousState: 'initializing', currentState: 'ready' }
      ]);
    });
  });

  describe('metrics collection', () => {
    beforeEach(async () => {
      mockCLIManager.createSession.mockResolvedValue({
        session_id: 'test-session',
        subtype: 'success'
      } as ClaudeSDKResponse);
      await agent.initialize();
    });

    it('should track success metrics', async () => {
      // Execute successful task
      const task: ITask = {
        id: 'metric-task',
        type: 'research',
        priority: 'low',
        description: 'Metric test'
      };

      mockCLIManager.execute.mockResolvedValue({
        type: 'result',
        subtype: 'success',
        result: 'Done',
        cost_usd: 0.02,
        duration_ms: 1500,
        num_turns: 1,
        session_id: 'test-session'
      } as ClaudeSDKResponse);

      await agent.execute(task);

      // Check metrics
      const metrics = agent.getMetrics();
      expect(metrics.tasksCompleted).toBe(1);
      expect(metrics.tasksFailed).toBe(0);
      expect(metrics.totalCost).toBe(0.02);
    });
  });
});
```

## Performance Considerations

### 4.1 Session Pooling
```typescript
// src/agents/session-pool.ts
export class SessionPool {
  private availableSessions: Map<AgentType, string[]> = new Map();
  private activeSessions: Map<string, SessionInfo> = new Map();
  
  async getSession(type: AgentType): Promise<string> {
    const available = this.availableSessions.get(type) || [];
    
    if (available.length > 0) {
      const sessionId = available.pop()!;
      this.activeSessions.set(sessionId, {
        type,
        checkoutTime: Date.now()
      });
      return sessionId;
    }
    
    // Create new session
    return this.createNewSession(type);
  }
  
  async returnSession(sessionId: string): Promise<void> {
    const info = this.activeSessions.get(sessionId);
    if (!info) return;
    
    this.activeSessions.delete(sessionId);
    
    // Add back to available pool
    const available = this.availableSessions.get(info.type) || [];
    available.push(sessionId);
    this.availableSessions.set(info.type, available);
  }
}
```

### 4.2 Agent Pool Management
```typescript
// src/agents/agent-pool.ts
export class AgentPool {
  private agents: Map<string, IAgent> = new Map();
  private idleAgents: Set<string> = new Set();
  private busyAgents: Map<string, string> = new Map(); // agentId -> taskId
  
  async addAgent(config: IAgentConfig): Promise<void> {
    const agent = await this.factory.createAndInitialize(config);
    this.agents.set(agent.id, agent);
    this.idleAgents.add(agent.id);
    
    // Monitor state changes
    agent.on('stateChange', ({ currentState }) => {
      if (currentState === 'ready') {
        this.busyAgents.delete(agent.id);
        this.idleAgents.add(agent.id);
      } else if (currentState === 'busy') {
        this.idleAgents.delete(agent.id);
      }
    });
  }
  
  async assignTask(task: ITask): Promise<IAgent> {
    // Find compatible idle agent
    const agent = this.findIdleAgent(task.type);
    
    if (!agent) {
      throw new Error(`No available agent for task type: ${task.type}`);
    }
    
    this.busyAgents.set(agent.id, task.id);
    return agent;
  }
}
```

## Implementation Timeline

### Day 1: Core Implementation
1. **Morning**:
   - Implement base agent class
   - Create agent interfaces
   - Setup state management

2. **Afternoon**:
   - Implement agent initialization
   - Create session management
   - Add metrics collection

### Day 2: Specialized Agents
1. **Morning**:
   - Implement research agent
   - Implement code agent
   - Create agent factory

2. **Afternoon**:
   - Add remaining agent types
   - Implement agent pool
   - Performance optimizations

### Day 3: Testing & Integration
1. **Morning**:
   - Complete unit tests
   - Integration testing
   - Performance testing

2. **Afternoon**:
   - Documentation
   - Code review
   - Prepare for Step 3

## Success Metrics
- All agent types implemented
- 100% test coverage maintained
- Session management working
- Metrics collection accurate
- Performance targets met:
  - Agent initialization <1s
  - Task assignment <100ms
  - Session reuse working

## Next Steps
After completing base agent implementation:
1. Proceed to Step 3: CLI Process Manager
2. Integrate with message queue
3. Implement orchestration layer